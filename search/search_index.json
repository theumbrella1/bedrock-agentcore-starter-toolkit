{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Amazon Bedrock AgentCore","text":"<p>Amazon Bedrock AgentCore is a comprehensive platform for deploying and operating highly effective AI agents securely at scale. The platform includes a Python SDK and Starter Toolkit that work together to help you build, deploy, and manage agent applications.</p> <p> </p> Python SDK Starter Toolkit Samples"},{"location":"index.html#from-local-development-to-bedrock-agentcore","title":"\ud83d\ude80 From Local Development to Bedrock AgentCore","text":"<pre><code># Your existing agent (any framework)\nfrom strands import Agent\n# or LangGraph, CrewAI, Autogen, custom logic - doesn't matter\n\ndef my_local_agent(query):\n    # Your carefully crafted agent logic\n    return agent.process(query)\n\n# Deploy to Bedrock AgentCore\nfrom bedrock_agentcore import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef production_agent(request):\n    return my_local_agent(request['query'])  # Same logic, enterprise platform\n\nproduction_agent.run()  # Ready to run on Bedrock AgentCore\n</code></pre> <p>What you get with Bedrock AgentCore:</p> <ul> <li>\u2705 Keep your agent logic - Works with Strands, LangGraph, CrewAI, Autogen, custom frameworks.</li> <li>\u2705 Zero infrastructure management - No servers, containers, or scaling concerns.</li> <li>\u2705 Enterprise-grade platform - Built-in auth, memory, observability, security.</li> <li>\u2705 Production-ready deployment - Reliable, scalable, compliant hosting.</li> </ul> <p>Your function is now a production-ready API server with health monitoring, streaming support, and AWS integration.</p>"},{"location":"index.html#platform-components","title":"Platform Components","text":""},{"location":"index.html#bedrock-agentcore-sdk","title":"\ud83d\udd27 Bedrock AgentCore SDK","text":"<p>The SDK provides Python primitives for agent development with built-in support for:</p> <ul> <li>Runtime: Lightweight wrapper to convert functions into API servers</li> <li>Memory: Persistent storage for conversation history and agent context</li> <li>Tools: Built-in clients for code interpretation and browser automation</li> <li>Identity: Secure authentication and access management</li> </ul>"},{"location":"index.html#bedrock-agentcore-starter-toolkit","title":"\ud83d\ude80 Bedrock AgentCore Starter Toolkit","text":"<p>The Toolkit provides CLI tools and higher-level abstractions for:</p> <ul> <li>Deployment: Containerize and deploy agents to AWS infrastructure</li> <li>Import Agent: Migrate existing Bedrock Agents to AgentCore with framework conversion</li> <li>Gateway Integration: Transform existing APIs into agent tools</li> <li>Configuration Management: Manage environment and deployment settings</li> <li>Observability: Monitor agents in production environments</li> </ul>"},{"location":"index.html#platform-services","title":"Platform Services","text":"<p>Amazon Bedrock AgentCore provides enterprise-grade services for AI agent development:</p> <ul> <li>\ud83d\ude80 AgentCore Runtime - Serverless deployment and scaling for dynamic AI agents</li> <li>\ud83e\udde0 AgentCore Memory - Persistent knowledge with event and semantic memory</li> <li>\ud83d\udcbb AgentCore Code Interpreter - Secure code execution in isolated sandboxes</li> <li>\ud83c\udf10 AgentCore Browser - Fast, secure cloud-based browser for web interaction</li> <li>\ud83d\udd17 AgentCore Gateway - Transform existing APIs into agent tools</li> <li>\ud83d\udcca AgentCore Observability - Real-time monitoring and tracing</li> <li>\ud83d\udd10 AgentCore Identity - Secure authentication and access management</li> </ul>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<ul> <li> <p> SDK Quickstart</p> <p>Get started with the core SDK for agent development</p> <p> Start coding</p> </li> <li> <p> Toolkit Guide</p> <p>Learn to deploy and manage agents in production</p> <p> Deploy agents</p> </li> <li> <p> Import Agent</p> <p>Migrate existing Bedrock Agents to AgentCore</p> <p> Import agents</p> </li> <li> <p> API Reference</p> <p>Detailed API documentation for developers</p> <p> Explore APIs</p> </li> </ul>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Zero Code Changes: Your existing functions remain untouched</li> <li>Production Ready: Automatic HTTP endpoints with health monitoring</li> <li>Streaming Support: Native support for generators and async generators</li> <li>Framework Agnostic: Works with any AI framework (Strands, LangGraph, LangChain, custom)</li> <li>AWS Optimized: Ready for deployment to AWS infrastructure</li> <li>Enterprise Security: Built-in identity, isolation, and access controls</li> </ul>"},{"location":"api-reference/cli.html","title":"CLI","text":"<p>Command-line interface for BedrockAgentCore Starter Toolkit.</p> <p>The <code>agentcore</code> CLI provides commands for configuring, launching, managing agents, and working with gateways.</p>"},{"location":"api-reference/cli.html#runtime-commands","title":"Runtime Commands","text":""},{"location":"api-reference/cli.html#configure","title":"Configure","text":"<p>Configure agents and runtime environments.</p> <pre><code>agentcore configure [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--entrypoint, -e TEXT</code>: Python file of agent</p> </li> <li> <p><code>--name, -n TEXT</code>: Agent name (defaults to Python file name)</p> </li> <li> <p><code>--execution-role, -er TEXT</code>: IAM execution role ARN</p> </li> <li> <p><code>--ecr, -ecr TEXT</code>: ECR repository name (use \"auto\" for automatic creation)</p> </li> <li> <p><code>--container-runtime, -ctr TEXT</code>: Container runtime</p> </li> <li> <p><code>--requirements-file, -rf TEXT</code>: Path to requirements file of agent</p> </li> <li> <p><code>--disable-otel, -do</code>: Disable OpenTelemetry</p> </li> <li> <p><code>--authorizer-config, -ac TEXT</code>: OAuth authorizer configuration as JSON string</p> </li> <li> <p><code>--verbose, -v</code>: Enable verbose output</p> </li> <li> <p><code>--region, -r TEXT</code>: AWS region</p> </li> <li> <p><code>--protocol, -p TEXT</code>: Agent server protocol (HTTP or MCP)</p> </li> </ul> <p>Subcommands:</p> <ul> <li> <p><code>list</code>: List configured agents</p> </li> <li> <p><code>set-default</code>: Set default agent</p> </li> </ul> <p>Region Configuration:</p> <pre><code># Use specific region\nagentcore configure -e agent.py --region us-east-1\n\n# Region precedence:\n# 1. --region flag\n# 2. AWS_DEFAULT_REGION environment variable\n# 3. AWS CLI configured region\n</code></pre>"},{"location":"api-reference/cli.html#launch","title":"Launch","text":"<p>Deploy agents to AWS or run locally.</p> <pre><code>agentcore launch [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--local, -l</code>: Run locally</p> </li> <li> <p><code>--push-ecr, -p</code>: Build and push to ECR only (no deployment)</p> </li> <li> <p><code>--env, -env TEXT</code>: Environment variables for agent (format: KEY=VALUE)</p> </li> </ul>"},{"location":"api-reference/cli.html#invoke","title":"Invoke","text":"<p>Invoke deployed agents.</p> <pre><code>agentcore invoke [PAYLOAD] [OPTIONS]\n</code></pre> <p>Arguments:</p> <ul> <li><code>PAYLOAD</code>: JSON payload to send</li> </ul> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--session-id, -s TEXT</code>: Session ID</p> </li> <li> <p><code>--bearer-token, -bt TEXT</code>: Bearer token for OAuth authentication</p> </li> <li> <p><code>--local, -l</code>: Send request to a running local container</p> </li> <li> <p><code>--user-id, -u TEXT</code>: User ID for authorization flows</p> </li> </ul> <p>Example Output:</p> <ul> <li>Session and Request IDs displayed in panel header</li> <li>CloudWatch log commands ready to copy</li> <li>Proper UTF-8 character rendering</li> <li>Clean response formatting without raw data structures</li> </ul> <p>Example output:</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 agent_name \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Session: abc-123                \u2502\n\u2502 Request ID: req-456             \u2502\n\u2502 ARN: arn:aws:bedrock...         \u2502\n\u2502 Logs: aws logs tail ... --follow\u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nResponse:\nYour formatted response here\n</code></pre>"},{"location":"api-reference/cli.html#status","title":"Status","text":"<p>Get Bedrock AgentCore status including config and runtime details.</p> <pre><code>agentcore status [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--agent, -a TEXT</code>: Agent name</p> </li> <li> <p><code>--verbose, -v</code>: Verbose JSON output of config, agent, and endpoint status</p> </li> </ul>"},{"location":"api-reference/cli.html#gateway-commands","title":"Gateway Commands","text":"<p>Access gateway subcommands:</p> <pre><code>agentcore gateway [COMMAND]\n</code></pre>"},{"location":"api-reference/cli.html#create-mcp-gateway","title":"Create MCP Gateway","text":"<pre><code>agentcore gateway create-mcp-gateway [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--region TEXT</code>: Region to use (defaults to us-west-2)</p> </li> <li> <p><code>--name TEXT</code>: Name of the gateway (defaults to TestGateway)</p> </li> <li> <p><code>--role-arn TEXT</code>: Role ARN to use (creates one if none provided)</p> </li> <li> <p><code>--authorizer-config TEXT</code>: Serialized authorizer config</p> </li> <li> <p><code>--enable-semantic-search, -sem</code>: Whether to enable search tool (defaults to True)</p> </li> </ul>"},{"location":"api-reference/cli.html#create-mcp-gateway-target","title":"Create MCP Gateway Target","text":"<pre><code>agentcore gateway create-mcp-gateway-target [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li> <p><code>--gateway-arn TEXT</code>: ARN of the created gateway</p> </li> <li> <p><code>--gateway-url TEXT</code>: URL of the created gateway</p> </li> <li> <p><code>--role-arn TEXT</code>: Role ARN of the created gateway</p> </li> <li> <p><code>--region TEXT</code>: Region to use (defaults to us-west-2)</p> </li> <li> <p><code>--name TEXT</code>: Name of the target (defaults to TestGatewayTarget)</p> </li> <li> <p><code>--target-type TEXT</code>: Type of target (lambda, openApiSchema, smithyModel)</p> </li> <li> <p><code>--target-payload TEXT</code>: Specification of the target (required for openApiSchema)</p> </li> <li> <p><code>--credentials TEXT</code>: Credentials for calling this target (API key or OAuth2)</p> </li> </ul>"},{"location":"api-reference/cli.html#example-usage","title":"Example Usage","text":""},{"location":"api-reference/cli.html#configure-an-agent","title":"Configure an Agent","text":"<pre><code># Basic configuration\nagentcore configure --entrypoint agent_example.pt\n\n# Configure with execution role\nagentcore configure --entrypoint agent_example.py --execution-role arn:aws:iam::123456789012:role/MyRole\n\n# List configured agents\nagentcore configure list\n\n# Set default agent\nagentcore configure set-default my_agent\n</code></pre>"},{"location":"api-reference/cli.html#deploy-and-run-agents","title":"Deploy and Run Agents","text":"<pre><code># Deploy to AWS\nagentcore launch\n\n# Run locally\nagentcore launch --local\n\n# Launch with environment variables\nagentcore launch --env API_KEY=abc123 --env DEBUG=true\n</code></pre>"},{"location":"api-reference/cli.html#invoke-agents","title":"Invoke Agents","text":"<pre><code># Basic invocation\nagentcore invoke '{\"prompt\": \"Hello world!\"}'\n\n# Invoke with session ID\nagentcore invoke '{\"prompt\": \"Continue our conversation\"}' --session-id abc123\n\n# Invoke with OAuth authentication\nagentcore invoke '{\"prompt\": \"Secure request\"}' --bearer-token eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n\n# Invoke local agent\nagentcore invoke '{\"prompt\": \"Test locally\"}' --local\n</code></pre>"},{"location":"api-reference/cli.html#check-status","title":"Check Status","text":"<pre><code># Get status of default agent\nagentcore status\n\n# Get status of specific agent\nagentcore status --agent my-agent\n</code></pre>"},{"location":"api-reference/cli.html#gateway-operations","title":"Gateway Operations","text":"<pre><code># Create MCP Gateway\nagentcore gateway create-mcp-gateway --name MyGateway\n\n# Create MCP Gateway Target\nagentcore gateway create-mcp-gateway-target \\\n  --gateway-arn arn:aws:bedrock-agentcore:us-west-2:123456789012:gateway/abcdef \\\n  --gateway-url https://gateway-url.us-west-2.amazonaws.com \\\n  --role-arn arn:aws:iam::123456789012:role/GatewayRole\n</code></pre>"},{"location":"api-reference/cli.html#importing-from-bedrock-agents","title":"Importing from Bedrock Agents","text":"<pre><code># Interactive Mode\nagentcore import-agent\n\n# For Automation\nagentcore import-agent \\\n  --region us-east-1 \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --output-dir ./my-agent \\\n  --deploy-runtime \\\n  --run-option runtime\n\n# AgentCore Primitive Opt-out\nagentcore import-agent --disable-gateway --disable-memory --disable-code-interpreter --disable-observability\n</code></pre>"},{"location":"api-reference/identity.html","title":"Identity","text":"<p>Memory management for Bedrock AgentCore SDK.</p>"},{"location":"api-reference/identity.html#service-client","title":"Service client","text":""},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity","title":"<code>bedrock_agentcore.services.identity</code>","text":"<p>The main high-level client for the Bedrock AgentCore Identity service.</p>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient","title":"<code>IdentityClient</code>","text":"<p>A high-level client for Bedrock AgentCore Identity.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>class IdentityClient:\n    \"\"\"A high-level client for Bedrock AgentCore Identity.\"\"\"\n\n    def __init__(self, region: str):\n        \"\"\"Initialize the identity client with the specified region.\"\"\"\n        self.region = region\n        self.cp_client = boto3.client(\n            \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_control_plane_endpoint(region)\n        )\n        self.identity_client = boto3.client(\n            \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self.dp_client = boto3.client(\n            \"bedrock-agentcore\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self.logger = logging.getLogger(\"bedrock_agentcore.identity_client\")\n\n    def create_oauth2_credential_provider(self, req):\n        \"\"\"Create an OAuth2 credential provider.\"\"\"\n        self.logger.info(\"Creating OAuth2 credential provider...\")\n        return self.cp_client.create_oauth2_credential_provider(**req)\n\n    def create_api_key_credential_provider(self, req):\n        \"\"\"Create an API key credential provider.\"\"\"\n        self.logger.info(\"Creating API key credential provider...\")\n        return self.cp_client.create_api_key_credential_provider(**req)\n\n    def get_workload_access_token(\n        self, workload_name: str, user_token: Optional[str] = None, user_id: Optional[str] = None\n    ) -&gt; Dict:\n        \"\"\"Get a workload access token using workload name and optionally user token.\"\"\"\n        if user_token:\n            if user_id is not None:\n                self.logger.warning(\"Both user token and user id are supplied, using user token\")\n            self.logger.info(\"Getting workload access token for JWT...\")\n            resp = self.dp_client.get_workload_access_token_for_jwt(workloadName=workload_name, userToken=user_token)\n        elif user_id:\n            self.logger.info(\"Getting workload access token for user id...\")\n            resp = self.dp_client.get_workload_access_token_for_user_id(workloadName=workload_name, userId=user_id)\n        else:\n            self.logger.info(\"Getting workload access token...\")\n            resp = self.dp_client.get_workload_access_token(workloadName=workload_name)\n\n        self.logger.info(\"Successfully retrieved workload access token\")\n        return resp\n\n    def create_workload_identity(self, name: Optional[str] = None) -&gt; Dict:\n        \"\"\"Create workload identity with optional name.\"\"\"\n        self.logger.info(\"Creating workload identity...\")\n        if not name:\n            name = f\"workload-{uuid.uuid4().hex[:8]}\"\n        return self.identity_client.create_workload_identity(name=name)\n\n    async def get_token(\n        self,\n        *,\n        provider_name: str,\n        scopes: Optional[List[str]] = None,\n        agent_identity_token: str,\n        on_auth_url: Optional[Callable[[str], Any]] = None,\n        auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n        callback_url: Optional[str] = None,\n        force_authentication: bool = False,\n        token_poller: Optional[TokenPoller] = None,\n    ) -&gt; str:\n        \"\"\"Get an OAuth2 access token for the specified provider.\n\n        Args:\n            provider_name: The credential provider name\n            scopes: Optional list of OAuth2 scopes to request\n            agent_identity_token: Agent identity token for authentication\n            on_auth_url: Callback for handling authorization URLs\n            auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n            callback_url: OAuth2 callback URL (must be pre-registered)\n            force_authentication: Force re-authentication even if token exists in the token vault\n            token_poller: Custom token poller implementation\n\n        Returns:\n            The access token string\n\n        Raises:\n            RequiresUserConsentException: When user consent is needed\n            Various other exceptions for error conditions\n        \"\"\"\n        self.logger.info(\"Getting OAuth2 token...\")\n\n        # Build parameters\n        req = {\n            \"resourceCredentialProviderName\": provider_name,\n            \"scopes\": scopes,\n            \"oauth2Flow\": auth_flow,\n            \"workloadIdentityToken\": agent_identity_token,\n        }\n\n        # Add optional parameters\n        if callback_url:\n            req[\"resourceOauth2ReturnUrl\"] = callback_url\n        if force_authentication:\n            req[\"forceAuthentication\"] = force_authentication\n\n        response = self.dp_client.get_resource_oauth2_token(**req)\n\n        # If we got a token directly, return it\n        if \"accessToken\" in response:\n            return response[\"accessToken\"]\n\n        # If we got an authorization URL, handle the OAuth flow\n        if \"authorizationUrl\" in response:\n            auth_url = response[\"authorizationUrl\"]\n            # Notify about the auth URL if callback provided\n            if on_auth_url:\n                if asyncio.iscoroutinefunction(on_auth_url):\n                    await on_auth_url(auth_url)\n                else:\n                    on_auth_url(auth_url)\n\n            # only the initial request should have force authentication\n            if force_authentication:\n                req[\"forceAuthentication\"] = False\n\n            # Poll for the token\n            active_poller = token_poller or _DefaultApiTokenPoller(\n                auth_url, lambda: self.dp_client.get_resource_oauth2_token(**req).get(\"accessToken\", None)\n            )\n            return await active_poller.poll_for_token()\n\n        raise RuntimeError(\"Identity service did not return a token or an authorization URL.\")\n\n    async def get_api_key(self, *, provider_name: str, agent_identity_token: str) -&gt; str:\n        \"\"\"Programmatically retrieves an API key from the Identity service.\"\"\"\n        self.logger.info(\"Getting API key...\")\n        req = {\"resourceCredentialProviderName\": provider_name, \"workloadIdentityToken\": agent_identity_token}\n\n        return self.dp_client.get_resource_api_key(**req)[\"apiKey\"]\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize the identity client with the specified region.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def __init__(self, region: str):\n    \"\"\"Initialize the identity client with the specified region.\"\"\"\n    self.region = region\n    self.cp_client = boto3.client(\n        \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_control_plane_endpoint(region)\n    )\n    self.identity_client = boto3.client(\n        \"bedrock-agentcore-control\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self.dp_client = boto3.client(\n        \"bedrock-agentcore\", region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self.logger = logging.getLogger(\"bedrock_agentcore.identity_client\")\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_api_key_credential_provider","title":"<code>create_api_key_credential_provider(req)</code>","text":"<p>Create an API key credential provider.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_api_key_credential_provider(self, req):\n    \"\"\"Create an API key credential provider.\"\"\"\n    self.logger.info(\"Creating API key credential provider...\")\n    return self.cp_client.create_api_key_credential_provider(**req)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_oauth2_credential_provider","title":"<code>create_oauth2_credential_provider(req)</code>","text":"<p>Create an OAuth2 credential provider.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_oauth2_credential_provider(self, req):\n    \"\"\"Create an OAuth2 credential provider.\"\"\"\n    self.logger.info(\"Creating OAuth2 credential provider...\")\n    return self.cp_client.create_oauth2_credential_provider(**req)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.create_workload_identity","title":"<code>create_workload_identity(name=None)</code>","text":"<p>Create workload identity with optional name.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def create_workload_identity(self, name: Optional[str] = None) -&gt; Dict:\n    \"\"\"Create workload identity with optional name.\"\"\"\n    self.logger.info(\"Creating workload identity...\")\n    if not name:\n        name = f\"workload-{uuid.uuid4().hex[:8]}\"\n    return self.identity_client.create_workload_identity(name=name)\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_api_key","title":"<code>get_api_key(*, provider_name, agent_identity_token)</code>  <code>async</code>","text":"<p>Programmatically retrieves an API key from the Identity service.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>async def get_api_key(self, *, provider_name: str, agent_identity_token: str) -&gt; str:\n    \"\"\"Programmatically retrieves an API key from the Identity service.\"\"\"\n    self.logger.info(\"Getting API key...\")\n    req = {\"resourceCredentialProviderName\": provider_name, \"workloadIdentityToken\": agent_identity_token}\n\n    return self.dp_client.get_resource_api_key(**req)[\"apiKey\"]\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_token","title":"<code>get_token(*, provider_name, scopes=None, agent_identity_token, on_auth_url=None, auth_flow, callback_url=None, force_authentication=False, token_poller=None)</code>  <code>async</code>","text":"<p>Get an OAuth2 access token for the specified provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>scopes</code> <code>Optional[List[str]]</code> <p>Optional list of OAuth2 scopes to request</p> <code>None</code> <code>agent_identity_token</code> <code>str</code> <p>Agent identity token for authentication</p> required <code>on_auth_url</code> <code>Optional[Callable[[str], Any]]</code> <p>Callback for handling authorization URLs</p> <code>None</code> <code>auth_flow</code> <code>Literal['M2M', 'USER_FEDERATION']</code> <p>Authentication flow type (\"M2M\" or \"USER_FEDERATION\")</p> required <code>callback_url</code> <code>Optional[str]</code> <p>OAuth2 callback URL (must be pre-registered)</p> <code>None</code> <code>force_authentication</code> <code>bool</code> <p>Force re-authentication even if token exists in the token vault</p> <code>False</code> <code>token_poller</code> <code>Optional[TokenPoller]</code> <p>Custom token poller implementation</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The access token string</p> <p>Raises:</p> Type Description <code>RequiresUserConsentException</code> <p>When user consent is needed</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>async def get_token(\n    self,\n    *,\n    provider_name: str,\n    scopes: Optional[List[str]] = None,\n    agent_identity_token: str,\n    on_auth_url: Optional[Callable[[str], Any]] = None,\n    auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n    callback_url: Optional[str] = None,\n    force_authentication: bool = False,\n    token_poller: Optional[TokenPoller] = None,\n) -&gt; str:\n    \"\"\"Get an OAuth2 access token for the specified provider.\n\n    Args:\n        provider_name: The credential provider name\n        scopes: Optional list of OAuth2 scopes to request\n        agent_identity_token: Agent identity token for authentication\n        on_auth_url: Callback for handling authorization URLs\n        auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n        callback_url: OAuth2 callback URL (must be pre-registered)\n        force_authentication: Force re-authentication even if token exists in the token vault\n        token_poller: Custom token poller implementation\n\n    Returns:\n        The access token string\n\n    Raises:\n        RequiresUserConsentException: When user consent is needed\n        Various other exceptions for error conditions\n    \"\"\"\n    self.logger.info(\"Getting OAuth2 token...\")\n\n    # Build parameters\n    req = {\n        \"resourceCredentialProviderName\": provider_name,\n        \"scopes\": scopes,\n        \"oauth2Flow\": auth_flow,\n        \"workloadIdentityToken\": agent_identity_token,\n    }\n\n    # Add optional parameters\n    if callback_url:\n        req[\"resourceOauth2ReturnUrl\"] = callback_url\n    if force_authentication:\n        req[\"forceAuthentication\"] = force_authentication\n\n    response = self.dp_client.get_resource_oauth2_token(**req)\n\n    # If we got a token directly, return it\n    if \"accessToken\" in response:\n        return response[\"accessToken\"]\n\n    # If we got an authorization URL, handle the OAuth flow\n    if \"authorizationUrl\" in response:\n        auth_url = response[\"authorizationUrl\"]\n        # Notify about the auth URL if callback provided\n        if on_auth_url:\n            if asyncio.iscoroutinefunction(on_auth_url):\n                await on_auth_url(auth_url)\n            else:\n                on_auth_url(auth_url)\n\n        # only the initial request should have force authentication\n        if force_authentication:\n            req[\"forceAuthentication\"] = False\n\n        # Poll for the token\n        active_poller = token_poller or _DefaultApiTokenPoller(\n            auth_url, lambda: self.dp_client.get_resource_oauth2_token(**req).get(\"accessToken\", None)\n        )\n        return await active_poller.poll_for_token()\n\n    raise RuntimeError(\"Identity service did not return a token or an authorization URL.\")\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.IdentityClient.get_workload_access_token","title":"<code>get_workload_access_token(workload_name, user_token=None, user_id=None)</code>","text":"<p>Get a workload access token using workload name and optionally user token.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>def get_workload_access_token(\n    self, workload_name: str, user_token: Optional[str] = None, user_id: Optional[str] = None\n) -&gt; Dict:\n    \"\"\"Get a workload access token using workload name and optionally user token.\"\"\"\n    if user_token:\n        if user_id is not None:\n            self.logger.warning(\"Both user token and user id are supplied, using user token\")\n        self.logger.info(\"Getting workload access token for JWT...\")\n        resp = self.dp_client.get_workload_access_token_for_jwt(workloadName=workload_name, userToken=user_token)\n    elif user_id:\n        self.logger.info(\"Getting workload access token for user id...\")\n        resp = self.dp_client.get_workload_access_token_for_user_id(workloadName=workload_name, userId=user_id)\n    else:\n        self.logger.info(\"Getting workload access token...\")\n        resp = self.dp_client.get_workload_access_token(workloadName=workload_name)\n\n    self.logger.info(\"Successfully retrieved workload access token\")\n    return resp\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.TokenPoller","title":"<code>TokenPoller</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for token polling implementations.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>class TokenPoller(ABC):\n    \"\"\"Abstract base class for token polling implementations.\"\"\"\n\n    @abstractmethod\n    async def poll_for_token(self) -&gt; str:\n        \"\"\"Poll for a token and return it when available.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.services.identity.TokenPoller.poll_for_token","title":"<code>poll_for_token()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Poll for a token and return it when available.</p> Source code in <code>bedrock_agentcore/services/identity.py</code> <pre><code>@abstractmethod\nasync def poll_for_token(self) -&gt; str:\n    \"\"\"Poll for a token and return it when available.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api-reference/identity.html#decorators","title":"Decorators","text":""},{"location":"api-reference/identity.html#bedrock_agentcore.identity","title":"<code>bedrock_agentcore.identity</code>","text":"<p>Bedrock AgentCore SDK identity package.</p>"},{"location":"api-reference/identity.html#bedrock_agentcore.identity.requires_access_token","title":"<code>requires_access_token(*, provider_name, into='access_token', scopes, on_auth_url=None, auth_flow, callback_url=None, force_authentication=False, token_poller=None)</code>","text":"<p>Decorator that fetches an OAuth2 access token before calling the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>into</code> <code>str</code> <p>Parameter name to inject the token into</p> <code>'access_token'</code> <code>scopes</code> <code>List[str]</code> <p>OAuth2 scopes to request</p> required <code>on_auth_url</code> <code>Optional[Callable[[str], Any]]</code> <p>Callback for handling authorization URLs</p> <code>None</code> <code>auth_flow</code> <code>Literal['M2M', 'USER_FEDERATION']</code> <p>Authentication flow type (\"M2M\" or \"USER_FEDERATION\")</p> required <code>callback_url</code> <code>Optional[str]</code> <p>OAuth2 callback URL</p> <code>None</code> <code>force_authentication</code> <code>bool</code> <p>Force re-authentication</p> <code>False</code> <code>token_poller</code> <code>Optional[TokenPoller]</code> <p>Custom token poller implementation</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorator function</p> Source code in <code>bedrock_agentcore/identity/auth.py</code> <pre><code>def requires_access_token(\n    *,\n    provider_name: str,\n    into: str = \"access_token\",\n    scopes: List[str],\n    on_auth_url: Optional[Callable[[str], Any]] = None,\n    auth_flow: Literal[\"M2M\", \"USER_FEDERATION\"],\n    callback_url: Optional[str] = None,\n    force_authentication: bool = False,\n    token_poller: Optional[TokenPoller] = None,\n) -&gt; Callable:\n    \"\"\"Decorator that fetches an OAuth2 access token before calling the decorated function.\n\n    Args:\n        provider_name: The credential provider name\n        into: Parameter name to inject the token into\n        scopes: OAuth2 scopes to request\n        on_auth_url: Callback for handling authorization URLs\n        auth_flow: Authentication flow type (\"M2M\" or \"USER_FEDERATION\")\n        callback_url: OAuth2 callback URL\n        force_authentication: Force re-authentication\n        token_poller: Custom token poller implementation\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        client = IdentityClient(_get_region())\n\n        async def _get_token() -&gt; str:\n            \"\"\"Common token fetching logic.\"\"\"\n            return await client.get_token(\n                provider_name=provider_name,\n                agent_identity_token=await _get_workload_access_token(client),\n                scopes=scopes,\n                on_auth_url=on_auth_url,\n                auth_flow=auth_flow,\n                callback_url=callback_url,\n                force_authentication=force_authentication,\n                token_poller=token_poller,\n            )\n\n        @wraps(func)\n        async def async_wrapper(*args: Any, **kwargs_func: Any) -&gt; Any:\n            token = await _get_token()\n            kwargs_func[into] = token\n            return await func(*args, **kwargs_func)\n\n        @wraps(func)\n        def sync_wrapper(*args: Any, **kwargs_func: Any) -&gt; Any:\n            if _has_running_loop():\n                # for async env, eg. runtime\n                ctx = contextvars.copy_context()\n                import concurrent.futures\n\n                with concurrent.futures.ThreadPoolExecutor() as executor:\n                    future = executor.submit(ctx.run, asyncio.run, _get_token())\n                    token = future.result()\n            else:\n                # for sync env, eg. local dev\n                token = asyncio.run(_get_token())\n\n            kwargs_func[into] = token\n            return func(*args, **kwargs_func)\n\n        # Return appropriate wrapper based on function type\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api-reference/identity.html#bedrock_agentcore.identity.requires_api_key","title":"<code>requires_api_key(*, provider_name, into='api_key')</code>","text":"<p>Decorator that fetches an API key before calling the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>The credential provider name</p> required <code>into</code> <code>str</code> <p>Parameter name to inject the API key into</p> <code>'api_key'</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorator function</p> Source code in <code>bedrock_agentcore/identity/auth.py</code> <pre><code>def requires_api_key(*, provider_name: str, into: str = \"api_key\") -&gt; Callable:\n    \"\"\"Decorator that fetches an API key before calling the decorated function.\n\n    Args:\n        provider_name: The credential provider name\n        into: Parameter name to inject the API key into\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        client = IdentityClient(_get_region())\n\n        async def _get_api_key():\n            return await client.get_api_key(\n                provider_name=provider_name,\n                agent_identity_token=await _get_workload_access_token(client),\n            )\n\n        @wraps(func)\n        async def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            api_key = await _get_api_key()\n            kwargs[into] = api_key\n            return await func(*args, **kwargs)\n\n        @wraps(func)\n        def sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            if _has_running_loop():\n                # for async env, eg. runtime\n                ctx = contextvars.copy_context()\n                import concurrent.futures\n\n                with concurrent.futures.ThreadPoolExecutor() as executor:\n                    future = executor.submit(ctx.run, asyncio.run, _get_api_key())\n                    api_key = future.result()\n            else:\n                # for sync env, eg. local dev\n                api_key = asyncio.run(_get_api_key())\n\n            kwargs[into] = api_key\n            return func(*args, **kwargs)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        else:\n            return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api-reference/memory.html","title":"Memory","text":"<p>Memory management for Bedrock AgentCore SDK.</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory","title":"<code>bedrock_agentcore.memory</code>","text":"<p>Bedrock AgentCore Memory module for agent memory management capabilities.</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.Actor","title":"<code>Actor</code>","text":"<p>               Bases: <code>DictWrapper</code></p> <p>Represents an actor within a session.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>class Actor(DictWrapper):\n    \"\"\"Represents an actor within a session.\"\"\"\n\n    def __init__(self, actor_id: str, session_manager: MemorySessionManager):\n        \"\"\"Represents an actor within a session.\n\n        :param actor_id: id of the actor\n        :param session_manager: Behaviour manager for the operations\n        \"\"\"\n        self._id = actor_id\n        self._session_manager = session_manager\n        super().__init__(self._construct_session_dict())\n\n    def _construct_session_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Constructs a dictionary representing the actor.\"\"\"\n        return {\n            \"actorId\": self._id,\n        }\n\n    def list_sessions(self) -&gt; List[SessionSummary]:\n        \"\"\"Delegates to _session_manager.list_actor_sessions.\"\"\"\n        return self._session_manager.list_actor_sessions(self._id)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.Actor.__init__","title":"<code>__init__(actor_id, session_manager)</code>","text":"<p>Represents an actor within a session.</p> <p>:param actor_id: id of the actor :param session_manager: Behaviour manager for the operations</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def __init__(self, actor_id: str, session_manager: MemorySessionManager):\n    \"\"\"Represents an actor within a session.\n\n    :param actor_id: id of the actor\n    :param session_manager: Behaviour manager for the operations\n    \"\"\"\n    self._id = actor_id\n    self._session_manager = session_manager\n    super().__init__(self._construct_session_dict())\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.Actor.list_sessions","title":"<code>list_sessions()</code>","text":"<p>Delegates to _session_manager.list_actor_sessions.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_sessions(self) -&gt; List[SessionSummary]:\n    \"\"\"Delegates to _session_manager.list_actor_sessions.\"\"\"\n    return self._session_manager.list_actor_sessions(self._id)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient","title":"<code>MemoryClient</code>","text":"<p>High-level Bedrock AgentCore Memory client with essential operations.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>class MemoryClient:\n    \"\"\"High-level Bedrock AgentCore Memory client with essential operations.\"\"\"\n\n    # AgentCore Memory data plane methods\n    _ALLOWED_GMDP_METHODS = {\n        \"retrieve_memory_records\",\n        \"get_memory_record\",\n        \"delete_memory_record\",\n        \"list_memory_records\",\n        \"create_event\",\n        \"get_event\",\n        \"delete_event\",\n        \"list_events\",\n    }\n\n    # AgentCore Memory control plane methods\n    _ALLOWED_GMCP_METHODS = {\n        \"create_memory\",\n        \"get_memory\",\n        \"list_memories\",\n        \"update_memory\",\n        \"delete_memory\",\n        \"list_memory_strategies\",\n    }\n\n    def __init__(self, region_name: Optional[str] = None):\n        \"\"\"Initialize the Memory client.\"\"\"\n        self.region_name = region_name or boto3.Session().region_name or \"us-west-2\"\n\n        self.gmcp_client = boto3.client(\"bedrock-agentcore-control\", region_name=self.region_name)\n        self.gmdp_client = boto3.client(\"bedrock-agentcore\", region_name=self.region_name)\n\n        logger.info(\n            \"Initialized MemoryClient for control plane: %s, data plane: %s\",\n            self.gmcp_client.meta.region_name,\n            self.gmdp_client.meta.region_name,\n        )\n\n    def __getattr__(self, name: str):\n        \"\"\"Dynamically forward method calls to the appropriate boto3 client.\n\n        This method enables access to all boto3 client methods without explicitly\n        defining them. Methods are looked up in the following order:\n        1. gmdp_client (bedrock-agentcore) - for data plane operations\n        2. gmcp_client (bedrock-agentcore-control) - for control plane operations\n\n        Args:\n            name: The method name being accessed\n\n        Returns:\n            A callable method from the appropriate boto3 client\n\n        Raises:\n            AttributeError: If the method doesn't exist on either client\n\n        Example:\n            # Access any boto3 method directly\n            client = MemoryClient()\n\n            # These calls are forwarded to the appropriate boto3 client\n            response = client.list_memory_records(memoryId=\"mem-123\", namespace=\"test\")\n            metadata = client.get_memory_metadata(memoryId=\"mem-123\")\n        \"\"\"\n        if name in self._ALLOWED_GMDP_METHODS and hasattr(self.gmdp_client, name):\n            method = getattr(self.gmdp_client, name)\n            logger.debug(\"Forwarding method '%s' to gmdp_client\", name)\n            return method\n\n        if name in self._ALLOWED_GMCP_METHODS and hasattr(self.gmcp_client, name):\n            method = getattr(self.gmcp_client, name)\n            logger.debug(\"Forwarding method '%s' to gmcp_client\", name)\n            return method\n\n        # Method not found on either client\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{name}'. \"\n            f\"Method not found on gmdp_client or gmcp_client. \"\n            f\"Available methods can be found in the boto3 documentation for \"\n            f\"'bedrock-agentcore' and 'bedrock-agentcore-control' services.\"\n        )\n\n    def create_memory(\n        self,\n        name: str,\n        strategies: Optional[List[Dict[str, Any]]] = None,\n        description: Optional[str] = None,\n        event_expiry_days: int = 90,\n        memory_execution_role_arn: Optional[str] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory with simplified configuration.\"\"\"\n        if strategies is None:\n            strategies = []\n\n        try:\n            processed_strategies = self._add_default_namespaces(strategies)\n\n            params = {\n                \"name\": name,\n                \"eventExpiryDuration\": event_expiry_days,\n                \"memoryStrategies\": processed_strategies,  # Using old field name for input\n                \"clientToken\": str(uuid.uuid4()),\n            }\n\n            if description is not None:\n                params[\"description\"] = description\n\n            if memory_execution_role_arn is not None:\n                params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n            response = self.gmcp_client.create_memory(**params)\n\n            memory = response[\"memory\"]\n            # Normalize response to handle new field names\n            memory = self._normalize_memory_response(memory)\n\n            logger.info(\"Created memory: %s\", memory[\"memoryId\"])\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to create memory: %s\", e)\n            raise\n\n    def create_or_get_memory(\n        self,\n        name: str,\n        strategies: Optional[List[Dict[str, Any]]] = None,\n        description: Optional[str] = None,\n        event_expiry_days: int = 90,\n        memory_execution_role_arn: Optional[str] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory resource or fetch the existing memory details if it already exists.\n\n        Returns:\n            Memory object, either newly created or existing\n        \"\"\"\n        try:\n            memory = self.create_memory_and_wait(\n                name=name,\n                strategies=strategies,\n                description=description,\n                event_expiry_days=event_expiry_days,\n                memory_execution_role_arn=memory_execution_role_arn,\n            )\n            return memory\n        except ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == \"ValidationException\" and \"already exists\" in str(e):\n                memories = self.list_memories()\n                memory = next((m for m in memories if m[\"id\"].startswith(name)), None)\n                logger.info(\"Memory already exists. Using existing memory ID: %s\", memory[\"id\"])\n                return memory\n            else:\n                logger.error(\"ClientError: Failed to create or get memory: %s\", e)\n                raise\n        except Exception:\n            raise\n\n    def create_memory_and_wait(\n        self,\n        name: str,\n        strategies: List[Dict[str, Any]],\n        description: Optional[str] = None,\n        event_expiry_days: int = 90,\n        memory_execution_role_arn: Optional[str] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory and wait for it to become ACTIVE.\n\n        This method creates a memory and polls until it reaches ACTIVE status,\n        providing a convenient way to ensure the memory is ready for use.\n\n        Args:\n            name: Name for the memory resource\n            strategies: List of strategy configurations\n            description: Optional description\n            event_expiry_days: How long to retain events (default: 90 days)\n            memory_execution_role_arn: IAM role ARN for memory execution\n            max_wait: Maximum seconds to wait (default: 300)\n            poll_interval: Seconds between status checks (default: 10)\n\n        Returns:\n            Created memory object in ACTIVE status\n\n        Raises:\n            TimeoutError: If memory doesn't become ACTIVE within max_wait\n            RuntimeError: If memory creation fails\n        \"\"\"\n        # Create the memory\n        memory = self.create_memory(\n            name=name,\n            strategies=strategies,\n            description=description,\n            event_expiry_days=event_expiry_days,\n            memory_execution_role_arn=memory_execution_role_arn,\n        )\n\n        memory_id = memory.get(\"memoryId\", memory.get(\"id\"))  # Handle both field names\n        if memory_id is None:\n            memory_id = \"\"\n        logger.info(\"Created memory %s, waiting for ACTIVE status...\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                status = self.get_memory_status(memory_id)\n\n                if status == MemoryStatus.ACTIVE.value:\n                    logger.info(\"Memory %s is now ACTIVE (took %d seconds)\", memory_id, elapsed)\n                    # Get fresh memory details\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    memory = self._normalize_memory_response(response[\"memory\"])\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    # Get failure reason if available\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(\"Memory creation failed: %s\" % failure_reason)\n                else:\n                    logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s did not become ACTIVE within %d seconds\" % (memory_id, max_wait))\n\n    def retrieve_memories(\n        self, memory_id: str, namespace: str, query: str, actor_id: Optional[str] = None, top_k: int = 3\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Retrieve relevant memories from a namespace.\n\n        Note: Wildcards (*) are NOT supported in namespaces. You must provide the\n        exact namespace path with all variables resolved.\n\n        Args:\n            memory_id: Memory resource ID\n            namespace: Exact namespace path (no wildcards)\n            query: Search query\n            actor_id: Optional actor ID (deprecated, use namespace)\n            top_k: Number of results to return\n\n        Returns:\n            List of memory records\n\n        Example:\n            # Correct - exact namespace\n            memories = client.retrieve_memories(\n                memory_id=\"mem-123\",\n                namespace=\"support/facts/session-456\",\n                query=\"customer preferences\"\n            )\n\n            # Incorrect - wildcards not supported\n            # memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)\n        \"\"\"\n        if \"*\" in namespace:\n            logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n            return []\n\n        try:\n            # Let service handle all namespace validation\n            response = self.gmdp_client.retrieve_memory_records(\n                memoryId=memory_id, namespace=namespace, searchCriteria={\"searchQuery\": query, \"topK\": top_k}\n            )\n\n            memories = response.get(\"memoryRecordSummaries\", [])\n            logger.info(\"Retrieved %d memories from namespace: %s\", len(memories), namespace)\n            return memories\n\n        except ClientError as e:\n            error_code = e.response[\"Error\"][\"Code\"]\n            error_msg = e.response[\"Error\"][\"Message\"]\n\n            if error_code == \"ResourceNotFoundException\":\n                logger.warning(\n                    \"Memory or namespace not found. Ensure memory %s exists and namespace '%s' is configured\",\n                    memory_id,\n                    namespace,\n                )\n            elif error_code == \"ValidationException\":\n                logger.warning(\"Invalid search parameters: %s\", error_msg)\n            elif error_code == \"ServiceException\":\n                logger.warning(\"Service error: %s. This may be temporary - try again later\", error_msg)\n            else:\n                logger.warning(\"Memory retrieval failed (%s): %s\", error_code, error_msg)\n\n            return []\n\n    def create_event(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n        branch: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Save an event of an agent interaction or conversation with a user.\n\n        This is the basis of short-term memory. If you configured your Memory resource\n        to have MemoryStrategies, then events that are saved in short-term memory via\n        create_event will be used to extract long-term memory records.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier (could be id of your user or an agent)\n            session_id: Session identifier (meant to logically group a series of events)\n            messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n            event_timestamp: timestamp for the entire event (not per message)\n            branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n                   For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n                   A branch is used when you want to have a different history of events.\n\n        Returns:\n            Created event\n\n        Example:\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                messages=[\n                    (\"What's the weather?\", \"USER\"),\n                    (\"Today is sunny\", \"ASSISTANT\")\n                ]\n            )\n            root_event_id = event.get(\"eventId\")\n            print(event)\n\n            # Continue the conversation\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                messages=[\n                    (\"How about the weather tomorrow\", \"USER\"),\n                    (\"Tomorrow is cold!\", \"ASSISTANT\")\n                ]\n            )\n            print(event)\n\n            # branch the conversation so that the previous message is not part of the history\n            # (suppose you did not mean to ask about the weather tomorrow and want to undo\n            # that, and replace with a new message)\n            event = client.create_event(\n                memory_id=memory.get(\"id\"),\n                actor_id=\"weatherWorrier\",\n                session_id=\"WeatherSession\",\n                branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},\n                messages=[\n                    (\"How about the weather a year from now\", \"USER\"),\n                    (\"I can't predict that far into the future!\", \"ASSISTANT\")\n                ]\n            )\n            print(event)\n        \"\"\"\n        try:\n            if not messages:\n                raise ValueError(\"At least one message is required\")\n\n            payload = []\n            for msg in messages:\n                if len(msg) != 2:\n                    raise ValueError(\"Each message must be (text, role)\")\n\n                text, role = msg\n\n                try:\n                    role_enum = MessageRole(role.upper())\n                except ValueError as err:\n                    raise ValueError(\n                        \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                    ) from err\n\n                payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n            # Use provided timestamp or current time\n            if event_timestamp is None:\n                event_timestamp = datetime.utcnow()\n\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"eventTimestamp\": event_timestamp,\n                \"payload\": payload,\n            }\n\n            if branch:\n                params[\"branch\"] = branch\n\n            response = self.gmdp_client.create_event(**params)\n\n            event = response[\"event\"]\n            logger.info(\"Created event: %s\", event[\"eventId\"])\n\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to create event: %s\", e)\n            raise\n\n    def create_blob_event(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        blob_data: Any,\n        event_timestamp: Optional[datetime] = None,\n        branch: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Save a blob event to AgentCore Memory.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            blob_data: Binary or structured data to store\n            event_timestamp: Optional timestamp for the event\n            branch: Optional branch info\n\n        Returns:\n            Created event\n\n        Example:\n            # Store binary data\n            event = client.create_blob_event(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                blob_data={\"file_content\": \"base64_encoded_data\", \"metadata\": {\"type\": \"image\"}}\n            )\n        \"\"\"\n        try:\n            payload = [{\"blob\": blob_data}]\n\n            if event_timestamp is None:\n                event_timestamp = datetime.utcnow()\n\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"eventTimestamp\": event_timestamp,\n                \"payload\": payload,\n            }\n\n            if branch:\n                params[\"branch\"] = branch\n\n            response = self.gmdp_client.create_event(**params)\n\n            event = response[\"event\"]\n            logger.info(\"Created blob event: %s\", event[\"eventId\"])\n\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to create blob event: %s\", e)\n            raise\n\n    def save_conversation(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n        branch: Optional[Dict[str, str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"DEPRECATED: Use create_event() instead.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n            event_timestamp: Optional timestamp for the entire event (not per message)\n            branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n                   For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n\n        Returns:\n            Created event\n\n        Example:\n            # Save multi-turn conversation\n            event = client.save_conversation(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                messages=[\n                    (\"What's the weather?\", \"USER\"),\n                    (\"And tomorrow?\", \"USER\"),\n                    (\"Checking weather...\", \"TOOL\"),\n                    (\"Today sunny, tomorrow rain\", \"ASSISTANT\")\n                ]\n            )\n\n            # Continue existing branch (only name required)\n            event = client.save_conversation(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                messages=[(\"Continue conversation\", \"USER\")],\n                branch={\"name\": \"existing-branch\"}\n            )\n        \"\"\"\n        try:\n            if not messages:\n                raise ValueError(\"At least one message is required\")\n\n            # Build payload\n            payload = []\n\n            for msg in messages:\n                if len(msg) != 2:\n                    raise ValueError(\"Each message must be (text, role)\")\n\n                text, role = msg\n\n                # Validate role\n                try:\n                    role_enum = MessageRole(role.upper())\n                except ValueError as err:\n                    raise ValueError(\n                        \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                    ) from err\n\n                payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n            # Use provided timestamp or current time\n            if event_timestamp is None:\n                event_timestamp = datetime.utcnow()\n\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"eventTimestamp\": event_timestamp,\n                \"payload\": payload,\n                \"clientToken\": str(uuid.uuid4()),\n            }\n\n            if branch:\n                params[\"branch\"] = branch\n\n            response = self.gmdp_client.create_event(**params)\n\n            event = response[\"event\"]\n            logger.info(\"Created event: %s\", event[\"eventId\"])\n\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to create event: %s\", e)\n            raise\n\n    def save_turn(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        agent_response: str,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"DEPRECATED: Use save_conversation() for more flexibility.\n\n        This method will be removed in v1.0.0.\n        \"\"\"\n        warnings.warn(\n            \"save_turn() is deprecated and will be removed in v1.0.0. \"\n            \"Use save_conversation() for flexible message handling.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        messages = [(user_input, \"USER\"), (agent_response, \"ASSISTANT\")]\n\n        return self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=messages,\n            event_timestamp=event_timestamp,\n        )\n\n    def process_turn(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        agent_response: str,\n        event_timestamp: Optional[datetime] = None,\n        retrieval_namespace: Optional[str] = None,\n        retrieval_query: Optional[str] = None,\n        top_k: int = 3,\n    ) -&gt; Tuple[List[Dict[str, Any]], Dict[str, Any]]:\n        \"\"\"DEPRECATED: Use retrieve_memories() and save_conversation() separately.\n\n        This method will be removed in v1.0.0.\n        \"\"\"\n        warnings.warn(\n            \"process_turn() is deprecated and will be removed in v1.0.0. \"\n            \"Use retrieve_memories() and save_conversation() separately, or use process_turn_with_llm().\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n        retrieved_memories = []\n\n        if retrieval_namespace:\n            search_query = retrieval_query or user_input\n            retrieved_memories = self.retrieve_memories(\n                memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n            )\n\n        event = self.save_turn(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            user_input=user_input,\n            agent_response=agent_response,\n            event_timestamp=event_timestamp,\n        )\n\n        return retrieved_memories, event\n\n    def process_turn_with_llm(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n        retrieval_namespace: Optional[str] = None,\n        retrieval_query: Optional[str] = None,\n        top_k: int = 3,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n        r\"\"\"Complete conversation turn with LLM callback integration.\n\n        This method combines memory retrieval, LLM invocation, and response storage\n        in a single call using a callback pattern.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier (e.g., \"user-123\")\n            session_id: Session identifier\n            user_input: The user's message\n            llm_callback: Function that takes (user_input, memories) and returns agent_response\n                         The callback receives the user input and retrieved memories,\n                         and should return the agent's response string\n            retrieval_namespace: Namespace to search for memories (optional)\n            retrieval_query: Custom search query (defaults to user_input)\n            top_k: Number of memories to retrieve\n            event_timestamp: Optional timestamp for the event\n\n        Returns:\n            Tuple of (retrieved_memories, agent_response, created_event)\n\n        Example:\n            def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n                # Format context from memories\n                context = \"\\\\n\".join([m['content']['text'] for m in memories])\n\n                # Call your LLM (Bedrock, OpenAI, etc.)\n                response = bedrock.invoke_model(\n                    messages=[\n                        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                        {\"role\": \"user\", \"content\": user_input}\n                    ]\n                )\n                return response['content']\n\n            memories, response, event = client.process_turn_with_llm(\n                memory_id=\"mem-xyz\",\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                user_input=\"What did we discuss yesterday?\",\n                llm_callback=my_llm,\n                retrieval_namespace=\"support/facts/{sessionId}\"\n            )\n        \"\"\"\n        # Step 1: Retrieve relevant memories\n        retrieved_memories = []\n        if retrieval_namespace:\n            search_query = retrieval_query or user_input\n            retrieved_memories = self.retrieve_memories(\n                memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n            )\n            logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n        # Step 2: Invoke LLM callback\n        try:\n            agent_response = llm_callback(user_input, retrieved_memories)\n            if not isinstance(agent_response, str):\n                raise ValueError(\"LLM callback must return a string response\")\n            logger.info(\"LLM callback generated response\")\n        except Exception as e:\n            logger.error(\"LLM callback failed: %s\", e)\n            raise\n\n        # Step 3: Save the conversation turn\n        event = self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=[(user_input, \"USER\"), (agent_response, \"ASSISTANT\")],\n            event_timestamp=event_timestamp,\n        )\n\n        logger.info(\"Completed full conversation turn with LLM\")\n        return retrieved_memories, agent_response, event\n\n    def list_events(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        branch_name: Optional[str] = None,\n        include_parent_branches: bool = False,\n        max_results: int = 100,\n        include_payload: bool = True,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all events in a session with pagination support.\n\n        This method provides direct access to the raw events API, allowing developers\n        to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Optional branch name to filter events (None for all branches)\n            include_parent_branches: Whether to include parent branch events (only applies with branch_name)\n            max_results: Maximum number of events to return\n            include_payload: Whether to include event payloads in response\n\n        Returns:\n            List of event dictionaries in chronological order\n\n        Example:\n            # Get all events\n            events = client.list_events(memory_id, actor_id, session_id)\n\n            # Get only main branch events\n            main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")\n\n            # Get events from a specific branch\n            branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")\n        \"\"\"\n        try:\n            all_events = []\n            next_token = None\n\n            while len(all_events) &lt; max_results:\n                params = {\n                    \"memoryId\": memory_id,\n                    \"actorId\": actor_id,\n                    \"sessionId\": session_id,\n                    \"maxResults\": min(100, max_results - len(all_events)),\n                    \"includePayloads\": include_payload,\n                }\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                # Add branch filter if specified (but not for \"main\")\n                if branch_name and branch_name != \"main\":\n                    params[\"filter\"] = {\n                        \"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_branches}\n                    }\n\n                response = self.gmdp_client.list_events(**params)\n\n                events = response.get(\"events\", [])\n                all_events.extend(events)\n\n                next_token = response.get(\"nextToken\")\n                if not next_token or len(all_events) &gt;= max_results:\n                    break\n\n            logger.info(\"Retrieved total of %d events\", len(all_events))\n            return all_events[:max_results]\n\n        except ClientError as e:\n            logger.error(\"Failed to list events: %s\", e)\n            raise\n\n    def list_branches(self, memory_id: str, actor_id: str, session_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all branches in a session.\n\n        This method handles pagination automatically and provides a structured view\n        of all conversation branches, which would require complex pagination and\n        grouping logic if done with raw boto3 calls.\n\n        Returns:\n            List of branch information including name and root event\n        \"\"\"\n        try:\n            # Get all events - need to handle pagination for complete list\n            all_events = []\n            next_token = None\n\n            while True:\n                params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.gmdp_client.list_events(**params)\n                all_events.extend(response.get(\"events\", []))\n\n                next_token = response.get(\"nextToken\")\n                if not next_token:\n                    break\n\n            branches = {}\n            main_branch_events = []\n\n            for event in all_events:\n                branch_info = event.get(\"branch\")\n                if branch_info:\n                    branch_name = branch_info[\"name\"]\n                    if branch_name not in branches:\n                        branches[branch_name] = {\n                            \"name\": branch_name,\n                            \"rootEventId\": branch_info.get(\"rootEventId\"),\n                            \"firstEventId\": event[\"eventId\"],\n                            \"eventCount\": 1,\n                            \"created\": event[\"eventTimestamp\"],\n                        }\n                    else:\n                        branches[branch_name][\"eventCount\"] += 1\n                else:\n                    main_branch_events.append(event)\n\n            # Build result list\n            result = []\n\n            # Only add main branch if there are actual events\n            if main_branch_events:\n                result.append(\n                    {\n                        \"name\": \"main\",\n                        \"rootEventId\": None,\n                        \"firstEventId\": main_branch_events[0][\"eventId\"],\n                        \"eventCount\": len(main_branch_events),\n                        \"created\": main_branch_events[0][\"eventTimestamp\"],\n                    }\n                )\n\n            # Add other branches\n            result.extend(list(branches.values()))\n\n            logger.info(\"Found %d branches in session %s\", len(result), session_id)\n            return result\n\n        except ClientError as e:\n            logger.error(\"Failed to list branches: %s\", e)\n            raise\n\n    def list_branch_events(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        branch_name: Optional[str] = None,\n        include_parent_branches: bool = False,\n        max_results: int = 100,\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"List events in a specific branch.\n\n        This method provides complex filtering and pagination that would require\n        significant boilerplate code with raw boto3. It handles:\n        - Automatic pagination across multiple API calls\n        - Branch filtering with parent event inclusion logic\n        - Main branch isolation (events without branch info)\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Branch name (None for main branch)\n            include_parent_branches: Whether to include events from parent branches\n            max_results: Maximum events to return\n\n        Returns:\n            List of events in the branch\n        \"\"\"\n        try:\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"maxResults\": min(100, max_results),\n            }\n\n            # Only add filter when we have a specific branch name\n            if branch_name:\n                params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_branches}}\n\n            response = self.gmdp_client.list_events(**params)\n            events = response.get(\"events\", [])\n\n            # Handle pagination\n            next_token = response.get(\"nextToken\")\n            while next_token and len(events) &lt; max_results:\n                params[\"nextToken\"] = next_token\n                params[\"maxResults\"] = min(100, max_results - len(events))\n                response = self.gmdp_client.list_events(**params)\n                events.extend(response.get(\"events\", []))\n                next_token = response.get(\"nextToken\")\n\n            # Filter for main branch if no branch specified\n            if not branch_name:\n                events = [e for e in events if not e.get(\"branch\")]\n\n            logger.info(\"Retrieved %d events from branch '%s'\", len(events), branch_name or \"main\")\n            return events\n\n        except ClientError as e:\n            logger.error(\"Failed to list branch events: %s\", e)\n            raise\n\n    def get_conversation_tree(self, memory_id: str, actor_id: str, session_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get a tree structure of the conversation with all branches.\n\n        This method transforms a flat list of events into a hierarchical tree structure,\n        providing visualization-ready data that would be complex to build from raw events.\n        It handles:\n        - Full pagination to get all events\n        - Grouping by branches\n        - Message summarization\n        - Tree structure building\n\n        Returns:\n            Dictionary representing the conversation tree structure\n        \"\"\"\n        try:\n            # Get all events - need to handle pagination for complete list\n            all_events = []\n            next_token = None\n\n            while True:\n                params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.gmdp_client.list_events(**params)\n                all_events.extend(response.get(\"events\", []))\n\n                next_token = response.get(\"nextToken\")\n                if not next_token:\n                    break\n\n            # Build tree structure\n            tree = {\"session_id\": session_id, \"actor_id\": actor_id, \"main_branch\": {\"events\": [], \"branches\": {}}}\n\n            # Group events by branch\n            for event in all_events:\n                event_summary = {\"eventId\": event[\"eventId\"], \"timestamp\": event[\"eventTimestamp\"], \"messages\": []}\n\n                # Extract message summaries\n                if \"payload\" in event:\n                    for payload_item in event.get(\"payload\", []):\n                        if \"conversational\" in payload_item:\n                            conv = payload_item[\"conversational\"]\n                            event_summary[\"messages\"].append(\n                                {\"role\": conv.get(\"role\"), \"text\": conv.get(\"content\", {}).get(\"text\", \"\")[:50] + \"...\"}\n                            )\n\n                branch_info = event.get(\"branch\")\n                if branch_info:\n                    branch_name = branch_info[\"name\"]\n                    root_event = branch_info.get(\"rootEventId\")  # Use .get() to handle missing field\n\n                    if branch_name not in tree[\"main_branch\"][\"branches\"]:\n                        tree[\"main_branch\"][\"branches\"][branch_name] = {\"root_event_id\": root_event, \"events\": []}\n\n                    tree[\"main_branch\"][\"branches\"][branch_name][\"events\"].append(event_summary)\n                else:\n                    tree[\"main_branch\"][\"events\"].append(event_summary)\n\n            logger.info(\"Built conversation tree with %d branches\", len(tree[\"main_branch\"][\"branches\"]))\n            return tree\n\n        except ClientError as e:\n            logger.error(\"Failed to build conversation tree: %s\", e)\n            raise\n\n    def merge_branch_context(\n        self, memory_id: str, actor_id: str, session_id: str, branch_name: str, include_parent: bool = True\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get all messages from a branch for context building.\n\n        Args:\n            memory_id: Memory resource ID\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Branch to get context from\n            include_parent: Whether to include parent branch events\n\n        Returns:\n            List of all messages in chronological order\n        \"\"\"\n        events = self.list_branch_events(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            branch_name=branch_name,\n            include_parent_branches=include_parent,\n            max_results=100,\n        )\n\n        messages = []\n        for event in events:\n            if \"payload\" in event:\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        conv = payload_item[\"conversational\"]\n                        messages.append(\n                            {\n                                \"timestamp\": event[\"eventTimestamp\"],\n                                \"eventId\": event[\"eventId\"],\n                                \"branch\": event.get(\"branch\", {}).get(\"name\", \"main\"),\n                                \"role\": conv.get(\"role\"),\n                                \"content\": conv.get(\"content\", {}).get(\"text\", \"\"),\n                            }\n                        )\n\n        # Sort by timestamp\n        messages.sort(key=lambda x: x[\"timestamp\"])\n\n        logger.info(\"Retrieved %d messages from branch '%s'\", len(messages), branch_name)\n        return messages\n\n    def get_last_k_turns(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        k: int = 5,\n        branch_name: Optional[str] = None,\n        include_branches: bool = False,\n        max_results: int = 100,\n    ) -&gt; List[List[Dict[str, Any]]]:\n        \"\"\"Get the last K conversation turns.\n\n        A \"turn\" typically consists of a user message followed by assistant response(s).\n        This method groups messages into logical turns for easier processing.\n\n        Returns:\n            List of turns, where each turn is a list of message dictionaries\n        \"\"\"\n        try:\n            # Use the new list_events method\n            events = self.list_events(\n                memory_id=memory_id,\n                actor_id=actor_id,\n                session_id=session_id,\n                branch_name=branch_name,\n                include_parent_branches=False,\n                max_results=max_results,\n            )\n\n            if not events:\n                return []\n\n            # Process events to group into turns\n            turns = []\n            current_turn = []\n\n            for event in events:\n                if len(turns) &gt;= k:\n                    break  # Only need last K turns\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        role = payload_item[\"conversational\"].get(\"role\")\n\n                        # Start new turn on USER message\n                        if role == Role.USER.value and current_turn:\n                            turns.append(current_turn)\n                            current_turn = []\n\n                        current_turn.append(payload_item[\"conversational\"])\n\n            # Don't forget the last turn\n            if current_turn:\n                turns.append(current_turn)\n\n            # Return the last k turns\n            return turns[:k] if len(turns) &gt; k else turns\n\n        except ClientError as e:\n            logger.error(\"Failed to get last K turns: %s\", e)\n            raise\n\n    def fork_conversation(\n        self,\n        memory_id: str,\n        actor_id: str,\n        session_id: str,\n        root_event_id: str,\n        branch_name: str,\n        new_messages: List[Tuple[str, str]],\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n        try:\n            branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n            event = self.create_event(\n                memory_id=memory_id,\n                actor_id=actor_id,\n                session_id=session_id,\n                messages=new_messages,\n                branch=branch,\n                event_timestamp=event_timestamp,\n            )\n\n            logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to fork conversation: %s\", e)\n            raise\n\n    def get_memory_strategies(self, memory_id: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get all strategies for a memory.\"\"\"\n        try:\n            response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            memory = response[\"memory\"]\n\n            # Handle both old and new field names in response\n            strategies = memory.get(\"strategies\", memory.get(\"memoryStrategies\", []))\n\n            # Normalize strategy fields\n            normalized_strategies = []\n            for strategy in strategies:\n                # Create normalized version with both old and new field names\n                normalized = strategy.copy()\n\n                # Ensure both field name versions exist\n                if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                    normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n                elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                    normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n                if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                    normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n                elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                    normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n                normalized_strategies.append(normalized)\n\n            return normalized_strategies\n        except ClientError as e:\n            logger.error(\"Failed to get memory strategies: %s\", e)\n            raise\n\n    def get_memory_status(self, memory_id: str) -&gt; str:\n        \"\"\"Get current memory status.\"\"\"\n        try:\n            response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            return response[\"memory\"][\"status\"]\n        except ClientError as e:\n            logger.error(\"Failed to get memory status: %s\", e)\n            raise\n\n    def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all memories for the account.\"\"\"\n        try:\n            # Ensure max_results doesn't exceed API limit per request\n            results_per_request = min(max_results, 100)\n\n            response = self.gmcp_client.list_memories(maxResults=results_per_request)\n            memories = response.get(\"memories\", [])\n\n            next_token = response.get(\"nextToken\")\n            while next_token and len(memories) &lt; max_results:\n                remaining = max_results - len(memories)\n                results_per_request = min(remaining, 100)\n\n                response = self.gmcp_client.list_memories(maxResults=results_per_request, nextToken=next_token)\n                memories.extend(response.get(\"memories\", []))\n                next_token = response.get(\"nextToken\")\n\n            # Normalize memory summaries if they contain new field names\n            normalized_memories = []\n            for memory in memories[:max_results]:\n                normalized = memory.copy()\n                # Ensure both field name versions exist\n                if \"id\" in memory and \"memoryId\" not in normalized:\n                    normalized[\"memoryId\"] = memory[\"id\"]\n                elif \"memoryId\" in memory and \"id\" not in normalized:\n                    normalized[\"id\"] = memory[\"memoryId\"]\n                normalized_memories.append(normalized)\n\n            return normalized_memories\n\n        except ClientError as e:\n            logger.error(\"Failed to list memories: %s\", e)\n            raise\n\n    def delete_memory(self, memory_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory resource.\"\"\"\n        try:\n            response = self.gmcp_client.delete_memory(\n                memoryId=memory_id, clientToken=str(uuid.uuid4())\n            )  # Input uses old field name\n            logger.info(\"Deleted memory: %s\", memory_id)\n            return response\n        except ClientError as e:\n            logger.error(\"Failed to delete memory: %s\", e)\n            raise\n\n    def delete_memory_and_wait(self, memory_id: str, max_wait: int = 300, poll_interval: int = 10) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory and wait for deletion to complete.\n\n        This method deletes a memory and polls until it's fully deleted,\n        ensuring clean resource cleanup.\n\n        Args:\n            memory_id: Memory resource ID to delete\n            max_wait: Maximum seconds to wait (default: 300)\n            poll_interval: Seconds between checks (default: 10)\n\n        Returns:\n            Final deletion response\n\n        Raises:\n            TimeoutError: If deletion doesn't complete within max_wait\n        \"\"\"\n        # Initiate deletion\n        response = self.delete_memory(memory_id)\n        logger.info(\"Initiated deletion of memory %s\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                # Try to get the memory - if it doesn't exist, deletion is complete\n                self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                logger.debug(\"Memory still exists, waiting... (%d seconds elapsed)\", elapsed)\n\n            except ClientError as e:\n                if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                    logger.info(\"Memory %s successfully deleted (took %d seconds)\", memory_id, elapsed)\n                    return response\n                else:\n                    logger.error(\"Error checking memory status: %s\", e)\n                    raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s was not deleted within %d seconds\" % (memory_id, max_wait))\n\n    def add_semantic_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a semantic memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.SEMANTIC.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.SEMANTIC.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.SEMANTIC.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_semantic_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a semantic strategy and wait for memory to return to ACTIVE state.\n\n        This addresses the issue where adding a strategy puts the memory into\n        CREATING state temporarily, preventing subsequent operations.\n        \"\"\"\n        # Add the strategy\n        self.add_semantic_strategy(memory_id, name, description, namespaces)\n\n        # Wait for memory to return to ACTIVE\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_summary_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a summary memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.SUMMARY.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.SUMMARY.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.SUMMARY.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_summary_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a summary strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_summary_strategy(memory_id, name, description, namespaces)\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_user_preference_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a user preference memory strategy.\n\n        Note: Configuration is no longer provided for built-in strategies as per API changes.\n        \"\"\"\n        strategy: Dict = {\n            StrategyType.USER_PREFERENCE.value: {\n                \"name\": name,\n            }\n        }\n\n        if description:\n            strategy[StrategyType.USER_PREFERENCE.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.USER_PREFERENCE.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_user_preference_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a user preference strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_user_preference_strategy(memory_id, name, description, namespaces)\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def add_custom_semantic_strategy(\n        self,\n        memory_id: str,\n        name: str,\n        extraction_config: Dict[str, Any],\n        consolidation_config: Dict[str, Any],\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a custom semantic strategy with prompts.\n\n        Args:\n            memory_id: Memory resource ID\n            name: Strategy name\n            extraction_config: Extraction configuration with prompt and model:\n                {\"prompt\": \"...\", \"modelId\": \"...\"}\n            consolidation_config: Consolidation configuration with prompt and model:\n                {\"prompt\": \"...\", \"modelId\": \"...\"}\n            description: Optional description\n            namespaces: Optional namespaces list\n        \"\"\"\n        strategy = {\n            StrategyType.CUSTOM.value: {\n                \"name\": name,\n                \"configuration\": {\n                    \"semanticOverride\": {\n                        \"extraction\": {\n                            \"appendToPrompt\": extraction_config[\"prompt\"],\n                            \"modelId\": extraction_config[\"modelId\"],\n                        },\n                        \"consolidation\": {\n                            \"appendToPrompt\": consolidation_config[\"prompt\"],\n                            \"modelId\": consolidation_config[\"modelId\"],\n                        },\n                    }\n                },\n            }\n        }\n\n        if description:\n            strategy[StrategyType.CUSTOM.value][\"description\"] = description\n        if namespaces:\n            strategy[StrategyType.CUSTOM.value][\"namespaces\"] = namespaces\n\n        return self._add_strategy(memory_id, strategy)\n\n    def add_custom_semantic_strategy_and_wait(\n        self,\n        memory_id: str,\n        name: str,\n        extraction_config: Dict[str, Any],\n        consolidation_config: Dict[str, Any],\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a custom semantic strategy and wait for memory to return to ACTIVE state.\"\"\"\n        self.add_custom_semantic_strategy(\n            memory_id, name, extraction_config, consolidation_config, description, namespaces\n        )\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def modify_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        configuration: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Modify a strategy with full control over configuration.\"\"\"\n        modify_config: Dict = {\"memoryStrategyId\": strategy_id}  # Using old field name for input\n\n        if description is not None:\n            modify_config[\"description\"] = description\n        if namespaces is not None:\n            modify_config[\"namespaces\"] = namespaces\n        if configuration is not None:\n            modify_config[\"configuration\"] = configuration\n\n        return self.update_memory_strategies(memory_id=memory_id, modify_strategies=[modify_config])\n\n    def delete_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Delete a strategy from a memory.\"\"\"\n        return self.update_memory_strategies(memory_id=memory_id, delete_strategy_ids=[strategy_id])\n\n    def update_memory_strategies(\n        self,\n        memory_id: str,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update memory strategies - add, modify, or delete.\"\"\"\n        try:\n            memory_strategies = {}\n\n            if add_strategies:\n                processed_add = self._add_default_namespaces(add_strategies)\n                memory_strategies[\"addMemoryStrategies\"] = processed_add  # Using old field name for input\n\n            if modify_strategies:\n                current_strategies = self.get_memory_strategies(memory_id)\n                strategy_map = {s[\"memoryStrategyId\"]: s for s in current_strategies}  # Using normalized field\n\n                modify_list = []\n                for strategy in modify_strategies:\n                    if \"memoryStrategyId\" not in strategy:  # Using old field name\n                        raise ValueError(\"Each modify strategy must include memoryStrategyId\")\n\n                    strategy_id = strategy[\"memoryStrategyId\"]  # Using old field name\n                    strategy_info = strategy_map.get(strategy_id)\n\n                    if not strategy_info:\n                        raise ValueError(\"Strategy %s not found in memory %s\" % (strategy_id, memory_id))\n\n                    strategy_type = strategy_info[\"memoryStrategyType\"]  # Using normalized field\n                    override_type = strategy_info.get(\"configuration\", {}).get(\"type\")\n\n                    strategy_copy = copy.deepcopy(strategy)\n\n                    if \"configuration\" in strategy_copy:\n                        wrapped_config = self._wrap_configuration(\n                            strategy_copy[\"configuration\"], strategy_type, override_type\n                        )\n                        strategy_copy[\"configuration\"] = wrapped_config\n\n                    modify_list.append(strategy_copy)\n\n                memory_strategies[\"modifyMemoryStrategies\"] = modify_list  # Using old field name for input\n\n            if delete_strategy_ids:\n                delete_list = [{\"memoryStrategyId\": sid} for sid in delete_strategy_ids]  # Using old field name\n                memory_strategies[\"deleteMemoryStrategies\"] = delete_list  # Using old field name for input\n\n            if not memory_strategies:\n                raise ValueError(\"No strategy operations provided\")\n\n            response = self.gmcp_client.update_memory(\n                memoryId=memory_id,\n                memoryStrategies=memory_strategies,\n                clientToken=str(uuid.uuid4()),  # Using old field names for input\n            )\n\n            logger.info(\"Updated memory strategies for: %s\", memory_id)\n            memory = self._normalize_memory_response(response[\"memory\"])\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to update memory strategies: %s\", e)\n            raise\n\n    def update_memory_strategies_and_wait(\n        self,\n        memory_id: str,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update memory strategies and wait for memory to return to ACTIVE state.\n\n        This method handles the temporary CREATING state that occurs when\n        updating strategies, preventing subsequent update errors.\n        \"\"\"\n        # Update strategies\n        self.update_memory_strategies(memory_id, add_strategies, modify_strategies, delete_strategy_ids)\n\n        # Wait for memory to return to ACTIVE\n        return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n    def wait_for_memories(\n        self, memory_id: str, namespace: str, test_query: str = \"test\", max_wait: int = 180, poll_interval: int = 15\n    ) -&gt; bool:\n        \"\"\"Wait for memory extraction to complete by polling.\n\n        IMPORTANT LIMITATIONS:\n        1. This method only works reliably on empty namespaces. If there are already\n           existing memories in the namespace, this method may return True immediately\n           even if new extractions haven't completed.\n        2. Wildcards (*) are NOT supported in namespaces. You must provide the exact\n           namespace path with all variables resolved (e.g., \"support/facts/session-123\"\n           not \"support/facts/*\").\n\n        For subsequent extractions in populated namespaces, use a fixed wait time:\n            time.sleep(150)  # Wait 2.5 minutes for extraction\n\n        Args:\n            memory_id: Memory resource ID\n            namespace: Exact namespace to check (no wildcards)\n            test_query: Query to test with (default: \"test\")\n            max_wait: Maximum seconds to wait (default: 180)\n            poll_interval: Seconds between checks (default: 15)\n\n        Returns:\n            True if memories found, False if timeout\n\n        Note:\n            This method will be deprecated in future versions once the API\n            provides extraction status or timestamps.\n        \"\"\"\n        if \"*\" in namespace:\n            logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n            return False\n\n        logger.warning(\n            \"wait_for_memories() only works reliably on empty namespaces. \"\n            \"For populated namespaces, consider using a fixed wait time instead.\"\n        )\n\n        logger.info(\"Waiting for memory extraction in namespace: %s\", namespace)\n        start_time = time.time()\n        service_errors = 0\n\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                memories = self.retrieve_memories(memory_id=memory_id, namespace=namespace, query=test_query, top_k=1)\n\n                if memories:\n                    logger.info(\"Memory extraction complete after %d seconds\", elapsed)\n                    return True\n\n                # Reset service error count on successful call\n                service_errors = 0\n\n            except Exception as e:\n                if \"ServiceException\" in str(e):\n                    service_errors += 1\n                    if service_errors &gt;= 3:\n                        logger.warning(\"Multiple service errors - the service may be experiencing issues\")\n                logger.debug(\"Retrieval attempt failed: %s\", e)\n\n            if time.time() - start_time &lt; max_wait:\n                time.sleep(poll_interval)\n\n        logger.warning(\"No memories found after %d seconds\", max_wait)\n        if service_errors &gt; 0:\n            logger.info(\"Note: Encountered %d service errors during polling\", service_errors)\n        return False\n\n    def add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Add a strategy to a memory (without waiting).\n\n        WARNING: After adding a strategy, the memory enters CREATING state temporarily.\n        Use add_*_strategy_and_wait() methods instead to avoid errors.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy: Strategy configuration dictionary\n\n        Returns:\n            Updated memory response\n        \"\"\"\n        warnings.warn(\n            \"add_strategy() may leave memory in CREATING state. \"\n            \"Use add_*_strategy_and_wait() methods to avoid subsequent errors.\",\n            UserWarning,\n            stacklevel=2,\n        )\n        return self._add_strategy(memory_id, strategy)\n\n    # Private methods\n\n    def _normalize_memory_response(self, memory: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Normalize memory response to include both old and new field names.\n\n        The API returns new field names but SDK users might expect old ones.\n        This ensures compatibility by providing both.\n        \"\"\"\n        # Ensure both versions of memory ID exist\n        if \"id\" in memory and \"memoryId\" not in memory:\n            memory[\"memoryId\"] = memory[\"id\"]\n        elif \"memoryId\" in memory and \"id\" not in memory:\n            memory[\"id\"] = memory[\"memoryId\"]\n\n        # Ensure both versions of strategies exist\n        if \"strategies\" in memory and \"memoryStrategies\" not in memory:\n            memory[\"memoryStrategies\"] = memory[\"strategies\"]\n        elif \"memoryStrategies\" in memory and \"strategies\" not in memory:\n            memory[\"strategies\"] = memory[\"memoryStrategies\"]\n\n        # Normalize strategies within memory\n        if \"strategies\" in memory:\n            normalized_strategies = []\n            for strategy in memory[\"strategies\"]:\n                normalized = strategy.copy()\n\n                # Ensure both field name versions exist for strategies\n                if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                    normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n                elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                    normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n                if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                    normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n                elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                    normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n                normalized_strategies.append(normalized)\n\n            memory[\"strategies\"] = normalized_strategies\n            memory[\"memoryStrategies\"] = normalized_strategies\n\n        return memory\n\n    def _add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Internal method to add a single strategy.\"\"\"\n        return self.update_memory_strategies(memory_id=memory_id, add_strategies=[strategy])\n\n    def _wait_for_memory_active(self, memory_id: str, max_wait: int, poll_interval: int) -&gt; Dict[str, Any]:\n        \"\"\"Wait for memory to return to ACTIVE state after strategy update.\"\"\"\n        logger.info(\"Waiting for memory %s to return to ACTIVE state...\", memory_id)\n\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            elapsed = int(time.time() - start_time)\n\n            try:\n                status = self.get_memory_status(memory_id)\n\n                if status == MemoryStatus.ACTIVE.value:\n                    logger.info(\"Memory %s is ACTIVE again (took %d seconds)\", memory_id, elapsed)\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    memory = self._normalize_memory_response(response[\"memory\"])\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                    failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(\"Memory update failed: %s\" % failure_reason)\n                else:\n                    logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n            time.sleep(poll_interval)\n\n        raise TimeoutError(\"Memory %s did not return to ACTIVE state within %d seconds\" % (memory_id, max_wait))\n\n    def _add_default_namespaces(self, strategies: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Add default namespaces to strategies that don't have them.\"\"\"\n        processed = []\n\n        for strategy in strategies:\n            strategy_copy = copy.deepcopy(strategy)\n\n            strategy_type_key = list(strategy.keys())[0]\n            strategy_config = strategy_copy[strategy_type_key]\n\n            if \"namespaces\" not in strategy_config:\n                strategy_type = StrategyType(strategy_type_key)\n                strategy_config[\"namespaces\"] = DEFAULT_NAMESPACES.get(strategy_type, [\"custom/{actorId}/{sessionId}\"])\n\n            self._validate_strategy_config(strategy_copy, strategy_type_key)\n\n            processed.append(strategy_copy)\n\n        return processed\n\n    def _validate_namespace(self, namespace: str) -&gt; bool:\n        \"\"\"Validate namespace format - basic check only.\"\"\"\n        # Only check for template variables in namespace definition\n        # Note: Using memoryStrategyId (old name) as it's still used in input parameters\n        if \"{\" in namespace and not (\n            \"{actorId}\" in namespace or \"{sessionId}\" in namespace or \"{memoryStrategyId}\" in namespace\n        ):\n            logger.warning(\"Namespace with templates should contain valid variables: %s\", namespace)\n\n        return True\n\n    def _validate_strategy_config(self, strategy: Dict[str, Any], strategy_type: str) -&gt; None:\n        \"\"\"Validate strategy configuration parameters.\"\"\"\n        strategy_config = strategy[strategy_type]\n\n        namespaces = strategy_config.get(\"namespaces\", [])\n        for namespace in namespaces:\n            self._validate_namespace(namespace)\n\n    def _wrap_configuration(\n        self, config: Dict[str, Any], strategy_type: str, override_type: Optional[str] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Wrap configuration based on strategy type.\"\"\"\n        wrapped_config = {}\n\n        if \"extraction\" in config:\n            extraction = config[\"extraction\"]\n\n            if any(key in extraction for key in [\"triggerEveryNMessages\", \"historicalContextWindowSize\"]):\n                strategy_type_enum = MemoryStrategyTypeEnum(strategy_type)\n\n                if strategy_type == \"SEMANTIC\":\n                    wrapped_config[\"extraction\"] = {EXTRACTION_WRAPPER_KEYS[strategy_type_enum]: extraction}\n                elif strategy_type == \"USER_PREFERENCE\":\n                    wrapped_config[\"extraction\"] = {EXTRACTION_WRAPPER_KEYS[strategy_type_enum]: extraction}\n                elif strategy_type == \"CUSTOM\" and override_type:\n                    override_enum = OverrideType(override_type)\n                    if override_type in [\"SEMANTIC_OVERRIDE\", \"USER_PREFERENCE_OVERRIDE\"]:\n                        wrapped_config[\"extraction\"] = {\n                            \"customExtractionConfiguration\": {CUSTOM_EXTRACTION_WRAPPER_KEYS[override_enum]: extraction}\n                        }\n            else:\n                wrapped_config[\"extraction\"] = extraction\n\n        if \"consolidation\" in config:\n            consolidation = config[\"consolidation\"]\n\n            raw_keys = [\"triggerEveryNMessages\", \"appendToPrompt\", \"modelId\"]\n            if any(key in consolidation for key in raw_keys):\n                if strategy_type == \"SUMMARIZATION\":\n                    if \"triggerEveryNMessages\" in consolidation:\n                        wrapped_config[\"consolidation\"] = {\n                            \"summaryConsolidationConfiguration\": {\n                                \"triggerEveryNMessages\": consolidation[\"triggerEveryNMessages\"]\n                            }\n                        }\n                elif strategy_type == \"CUSTOM\" and override_type:\n                    override_enum = OverrideType(override_type)\n                    if override_enum in CUSTOM_CONSOLIDATION_WRAPPER_KEYS:\n                        wrapped_config[\"consolidation\"] = {\n                            \"customConsolidationConfiguration\": {\n                                CUSTOM_CONSOLIDATION_WRAPPER_KEYS[override_enum]: consolidation\n                            }\n                        }\n            else:\n                wrapped_config[\"consolidation\"] = consolidation\n\n        return wrapped_config\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Dynamically forward method calls to the appropriate boto3 client.</p> <p>This method enables access to all boto3 client methods without explicitly defining them. Methods are looked up in the following order: 1. gmdp_client (bedrock-agentcore) - for data plane operations 2. gmcp_client (bedrock-agentcore-control) - for control plane operations</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The method name being accessed</p> required <p>Returns:</p> Type Description <p>A callable method from the appropriate boto3 client</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the method doesn't exist on either client</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def __getattr__(self, name: str):\n    \"\"\"Dynamically forward method calls to the appropriate boto3 client.\n\n    This method enables access to all boto3 client methods without explicitly\n    defining them. Methods are looked up in the following order:\n    1. gmdp_client (bedrock-agentcore) - for data plane operations\n    2. gmcp_client (bedrock-agentcore-control) - for control plane operations\n\n    Args:\n        name: The method name being accessed\n\n    Returns:\n        A callable method from the appropriate boto3 client\n\n    Raises:\n        AttributeError: If the method doesn't exist on either client\n\n    Example:\n        # Access any boto3 method directly\n        client = MemoryClient()\n\n        # These calls are forwarded to the appropriate boto3 client\n        response = client.list_memory_records(memoryId=\"mem-123\", namespace=\"test\")\n        metadata = client.get_memory_metadata(memoryId=\"mem-123\")\n    \"\"\"\n    if name in self._ALLOWED_GMDP_METHODS and hasattr(self.gmdp_client, name):\n        method = getattr(self.gmdp_client, name)\n        logger.debug(\"Forwarding method '%s' to gmdp_client\", name)\n        return method\n\n    if name in self._ALLOWED_GMCP_METHODS and hasattr(self.gmcp_client, name):\n        method = getattr(self.gmcp_client, name)\n        logger.debug(\"Forwarding method '%s' to gmcp_client\", name)\n        return method\n\n    # Method not found on either client\n    raise AttributeError(\n        f\"'{self.__class__.__name__}' object has no attribute '{name}'. \"\n        f\"Method not found on gmdp_client or gmcp_client. \"\n        f\"Available methods can be found in the boto3 documentation for \"\n        f\"'bedrock-agentcore' and 'bedrock-agentcore-control' services.\"\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.__getattr__--access-any-boto3-method-directly","title":"Access any boto3 method directly","text":"<p>client = MemoryClient()</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.__getattr__--these-calls-are-forwarded-to-the-appropriate-boto3-client","title":"These calls are forwarded to the appropriate boto3 client","text":"<p>response = client.list_memory_records(memoryId=\"mem-123\", namespace=\"test\") metadata = client.get_memory_metadata(memoryId=\"mem-123\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.__init__","title":"<code>__init__(region_name=None)</code>","text":"<p>Initialize the Memory client.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def __init__(self, region_name: Optional[str] = None):\n    \"\"\"Initialize the Memory client.\"\"\"\n    self.region_name = region_name or boto3.Session().region_name or \"us-west-2\"\n\n    self.gmcp_client = boto3.client(\"bedrock-agentcore-control\", region_name=self.region_name)\n    self.gmdp_client = boto3.client(\"bedrock-agentcore\", region_name=self.region_name)\n\n    logger.info(\n        \"Initialized MemoryClient for control plane: %s, data plane: %s\",\n        self.gmcp_client.meta.region_name,\n        self.gmdp_client.meta.region_name,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_custom_semantic_strategy","title":"<code>add_custom_semantic_strategy(memory_id, name, extraction_config, consolidation_config, description=None, namespaces=None)</code>","text":"<p>Add a custom semantic strategy with prompts.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>name</code> <code>str</code> <p>Strategy name</p> required <code>extraction_config</code> <code>Dict[str, Any]</code> <p>Extraction configuration with prompt and model:</p> required <code>consolidation_config</code> <code>Dict[str, Any]</code> <p>Consolidation configuration with prompt and model:</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>namespaces</code> <code>Optional[List[str]]</code> <p>Optional namespaces list</p> <code>None</code> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_custom_semantic_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    extraction_config: Dict[str, Any],\n    consolidation_config: Dict[str, Any],\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a custom semantic strategy with prompts.\n\n    Args:\n        memory_id: Memory resource ID\n        name: Strategy name\n        extraction_config: Extraction configuration with prompt and model:\n            {\"prompt\": \"...\", \"modelId\": \"...\"}\n        consolidation_config: Consolidation configuration with prompt and model:\n            {\"prompt\": \"...\", \"modelId\": \"...\"}\n        description: Optional description\n        namespaces: Optional namespaces list\n    \"\"\"\n    strategy = {\n        StrategyType.CUSTOM.value: {\n            \"name\": name,\n            \"configuration\": {\n                \"semanticOverride\": {\n                    \"extraction\": {\n                        \"appendToPrompt\": extraction_config[\"prompt\"],\n                        \"modelId\": extraction_config[\"modelId\"],\n                    },\n                    \"consolidation\": {\n                        \"appendToPrompt\": consolidation_config[\"prompt\"],\n                        \"modelId\": consolidation_config[\"modelId\"],\n                    },\n                }\n            },\n        }\n    }\n\n    if description:\n        strategy[StrategyType.CUSTOM.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.CUSTOM.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_custom_semantic_strategy_and_wait","title":"<code>add_custom_semantic_strategy_and_wait(memory_id, name, extraction_config, consolidation_config, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a custom semantic strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_custom_semantic_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    extraction_config: Dict[str, Any],\n    consolidation_config: Dict[str, Any],\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a custom semantic strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_custom_semantic_strategy(\n        memory_id, name, extraction_config, consolidation_config, description, namespaces\n    )\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_semantic_strategy","title":"<code>add_semantic_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a semantic memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_semantic_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a semantic memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.SEMANTIC.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.SEMANTIC.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.SEMANTIC.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_semantic_strategy_and_wait","title":"<code>add_semantic_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a semantic strategy and wait for memory to return to ACTIVE state.</p> <p>This addresses the issue where adding a strategy puts the memory into CREATING state temporarily, preventing subsequent operations.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_semantic_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a semantic strategy and wait for memory to return to ACTIVE state.\n\n    This addresses the issue where adding a strategy puts the memory into\n    CREATING state temporarily, preventing subsequent operations.\n    \"\"\"\n    # Add the strategy\n    self.add_semantic_strategy(memory_id, name, description, namespaces)\n\n    # Wait for memory to return to ACTIVE\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_strategy","title":"<code>add_strategy(memory_id, strategy)</code>","text":"<p>Add a strategy to a memory (without waiting).</p> <p>WARNING: After adding a strategy, the memory enters CREATING state temporarily. Use add_*_strategy_and_wait() methods instead to avoid errors.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy</code> <code>Dict[str, Any]</code> <p>Strategy configuration dictionary</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory response</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_strategy(self, memory_id: str, strategy: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Add a strategy to a memory (without waiting).\n\n    WARNING: After adding a strategy, the memory enters CREATING state temporarily.\n    Use add_*_strategy_and_wait() methods instead to avoid errors.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy: Strategy configuration dictionary\n\n    Returns:\n        Updated memory response\n    \"\"\"\n    warnings.warn(\n        \"add_strategy() may leave memory in CREATING state. \"\n        \"Use add_*_strategy_and_wait() methods to avoid subsequent errors.\",\n        UserWarning,\n        stacklevel=2,\n    )\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_summary_strategy","title":"<code>add_summary_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a summary memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_summary_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a summary memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.SUMMARY.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.SUMMARY.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.SUMMARY.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_summary_strategy_and_wait","title":"<code>add_summary_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a summary strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_summary_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a summary strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_summary_strategy(memory_id, name, description, namespaces)\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_user_preference_strategy","title":"<code>add_user_preference_strategy(memory_id, name, description=None, namespaces=None)</code>","text":"<p>Add a user preference memory strategy.</p> <p>Note: Configuration is no longer provided for built-in strategies as per API changes.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_user_preference_strategy(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a user preference memory strategy.\n\n    Note: Configuration is no longer provided for built-in strategies as per API changes.\n    \"\"\"\n    strategy: Dict = {\n        StrategyType.USER_PREFERENCE.value: {\n            \"name\": name,\n        }\n    }\n\n    if description:\n        strategy[StrategyType.USER_PREFERENCE.value][\"description\"] = description\n    if namespaces:\n        strategy[StrategyType.USER_PREFERENCE.value][\"namespaces\"] = namespaces\n\n    return self._add_strategy(memory_id, strategy)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.add_user_preference_strategy_and_wait","title":"<code>add_user_preference_strategy_and_wait(memory_id, name, description=None, namespaces=None, max_wait=300, poll_interval=10)</code>","text":"<p>Add a user preference strategy and wait for memory to return to ACTIVE state.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def add_user_preference_strategy_and_wait(\n    self,\n    memory_id: str,\n    name: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a user preference strategy and wait for memory to return to ACTIVE state.\"\"\"\n    self.add_user_preference_strategy(memory_id, name, description, namespaces)\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_blob_event","title":"<code>create_blob_event(memory_id, actor_id, session_id, blob_data, event_timestamp=None, branch=None)</code>","text":"<p>Save a blob event to AgentCore Memory.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>blob_data</code> <code>Any</code> <p>Binary or structured data to store</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the event</p> <code>None</code> <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created event</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_blob_event(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    blob_data: Any,\n    event_timestamp: Optional[datetime] = None,\n    branch: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Save a blob event to AgentCore Memory.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        blob_data: Binary or structured data to store\n        event_timestamp: Optional timestamp for the event\n        branch: Optional branch info\n\n    Returns:\n        Created event\n\n    Example:\n        # Store binary data\n        event = client.create_blob_event(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            blob_data={\"file_content\": \"base64_encoded_data\", \"metadata\": {\"type\": \"image\"}}\n        )\n    \"\"\"\n    try:\n        payload = [{\"blob\": blob_data}]\n\n        if event_timestamp is None:\n            event_timestamp = datetime.utcnow()\n\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n\n        response = self.gmdp_client.create_event(**params)\n\n        event = response[\"event\"]\n        logger.info(\"Created blob event: %s\", event[\"eventId\"])\n\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to create blob event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_blob_event--store-binary-data","title":"Store binary data","text":"<p>event = client.create_blob_event(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     blob_data={\"file_content\": \"base64_encoded_data\", \"metadata\": {\"type\": \"image\"}} )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event","title":"<code>create_event(memory_id, actor_id, session_id, messages, event_timestamp=None, branch=None)</code>","text":"<p>Save an event of an agent interaction or conversation with a user.</p> <p>This is the basis of short-term memory. If you configured your Memory resource to have MemoryStrategies, then events that are saved in short-term memory via create_event will be used to extract long-term memory records.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier (could be id of your user or an agent)</p> required <code>session_id</code> <code>str</code> <p>Session identifier (meant to logically group a series of events)</p> required <code>messages</code> <code>List[Tuple[str, str]]</code> <p>List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>timestamp for the entire event (not per message)</p> <code>None</code> <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}    For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}    A branch is used when you want to have a different history of events.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created event</p> Example <p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     messages=[         (\"What's the weather?\", \"USER\"),         (\"Today is sunny\", \"ASSISTANT\")     ] ) root_event_id = event.get(\"eventId\") print(event)</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_event(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n    branch: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Save an event of an agent interaction or conversation with a user.\n\n    This is the basis of short-term memory. If you configured your Memory resource\n    to have MemoryStrategies, then events that are saved in short-term memory via\n    create_event will be used to extract long-term memory records.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier (could be id of your user or an agent)\n        session_id: Session identifier (meant to logically group a series of events)\n        messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n        event_timestamp: timestamp for the entire event (not per message)\n        branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n               For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n               A branch is used when you want to have a different history of events.\n\n    Returns:\n        Created event\n\n    Example:\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            messages=[\n                (\"What's the weather?\", \"USER\"),\n                (\"Today is sunny\", \"ASSISTANT\")\n            ]\n        )\n        root_event_id = event.get(\"eventId\")\n        print(event)\n\n        # Continue the conversation\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            messages=[\n                (\"How about the weather tomorrow\", \"USER\"),\n                (\"Tomorrow is cold!\", \"ASSISTANT\")\n            ]\n        )\n        print(event)\n\n        # branch the conversation so that the previous message is not part of the history\n        # (suppose you did not mean to ask about the weather tomorrow and want to undo\n        # that, and replace with a new message)\n        event = client.create_event(\n            memory_id=memory.get(\"id\"),\n            actor_id=\"weatherWorrier\",\n            session_id=\"WeatherSession\",\n            branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},\n            messages=[\n                (\"How about the weather a year from now\", \"USER\"),\n                (\"I can't predict that far into the future!\", \"ASSISTANT\")\n            ]\n        )\n        print(event)\n    \"\"\"\n    try:\n        if not messages:\n            raise ValueError(\"At least one message is required\")\n\n        payload = []\n        for msg in messages:\n            if len(msg) != 2:\n                raise ValueError(\"Each message must be (text, role)\")\n\n            text, role = msg\n\n            try:\n                role_enum = MessageRole(role.upper())\n            except ValueError as err:\n                raise ValueError(\n                    \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                ) from err\n\n            payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n        # Use provided timestamp or current time\n        if event_timestamp is None:\n            event_timestamp = datetime.utcnow()\n\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n\n        response = self.gmdp_client.create_event(**params)\n\n        event = response[\"event\"]\n        logger.info(\"Created event: %s\", event[\"eventId\"])\n\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to create event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--continue-the-conversation","title":"Continue the conversation","text":"<p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     messages=[         (\"How about the weather tomorrow\", \"USER\"),         (\"Tomorrow is cold!\", \"ASSISTANT\")     ] ) print(event)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--branch-the-conversation-so-that-the-previous-message-is-not-part-of-the-history","title":"branch the conversation so that the previous message is not part of the history","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--suppose-you-did-not-mean-to-ask-about-the-weather-tomorrow-and-want-to-undo","title":"(suppose you did not mean to ask about the weather tomorrow and want to undo","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_event--that-and-replace-with-a-new-message","title":"that, and replace with a new message)","text":"<p>event = client.create_event(     memory_id=memory.get(\"id\"),     actor_id=\"weatherWorrier\",     session_id=\"WeatherSession\",     branch={\"name\": \"differentWeatherQuestion\", \"rootEventId\": root_event_id},     messages=[         (\"How about the weather a year from now\", \"USER\"),         (\"I can't predict that far into the future!\", \"ASSISTANT\")     ] ) print(event)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_memory","title":"<code>create_memory(name, strategies=None, description=None, event_expiry_days=90, memory_execution_role_arn=None)</code>","text":"<p>Create a memory with simplified configuration.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_memory(\n    self,\n    name: str,\n    strategies: Optional[List[Dict[str, Any]]] = None,\n    description: Optional[str] = None,\n    event_expiry_days: int = 90,\n    memory_execution_role_arn: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory with simplified configuration.\"\"\"\n    if strategies is None:\n        strategies = []\n\n    try:\n        processed_strategies = self._add_default_namespaces(strategies)\n\n        params = {\n            \"name\": name,\n            \"eventExpiryDuration\": event_expiry_days,\n            \"memoryStrategies\": processed_strategies,  # Using old field name for input\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if description is not None:\n            params[\"description\"] = description\n\n        if memory_execution_role_arn is not None:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        response = self.gmcp_client.create_memory(**params)\n\n        memory = response[\"memory\"]\n        # Normalize response to handle new field names\n        memory = self._normalize_memory_response(memory)\n\n        logger.info(\"Created memory: %s\", memory[\"memoryId\"])\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to create memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_memory_and_wait","title":"<code>create_memory_and_wait(name, strategies, description=None, event_expiry_days=90, memory_execution_role_arn=None, max_wait=300, poll_interval=10)</code>","text":"<p>Create a memory and wait for it to become ACTIVE.</p> <p>This method creates a memory and polls until it reaches ACTIVE status, providing a convenient way to ensure the memory is ready for use.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the memory resource</p> required <code>strategies</code> <code>List[Dict[str, Any]]</code> <p>List of strategy configurations</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>event_expiry_days</code> <code>int</code> <p>How long to retain events (default: 90 days)</p> <code>90</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>IAM role ARN for memory execution</p> <code>None</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 300)</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks (default: 10)</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created memory object in ACTIVE status</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If memory doesn't become ACTIVE within max_wait</p> <code>RuntimeError</code> <p>If memory creation fails</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_memory_and_wait(\n    self,\n    name: str,\n    strategies: List[Dict[str, Any]],\n    description: Optional[str] = None,\n    event_expiry_days: int = 90,\n    memory_execution_role_arn: Optional[str] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory and wait for it to become ACTIVE.\n\n    This method creates a memory and polls until it reaches ACTIVE status,\n    providing a convenient way to ensure the memory is ready for use.\n\n    Args:\n        name: Name for the memory resource\n        strategies: List of strategy configurations\n        description: Optional description\n        event_expiry_days: How long to retain events (default: 90 days)\n        memory_execution_role_arn: IAM role ARN for memory execution\n        max_wait: Maximum seconds to wait (default: 300)\n        poll_interval: Seconds between status checks (default: 10)\n\n    Returns:\n        Created memory object in ACTIVE status\n\n    Raises:\n        TimeoutError: If memory doesn't become ACTIVE within max_wait\n        RuntimeError: If memory creation fails\n    \"\"\"\n    # Create the memory\n    memory = self.create_memory(\n        name=name,\n        strategies=strategies,\n        description=description,\n        event_expiry_days=event_expiry_days,\n        memory_execution_role_arn=memory_execution_role_arn,\n    )\n\n    memory_id = memory.get(\"memoryId\", memory.get(\"id\"))  # Handle both field names\n    if memory_id is None:\n        memory_id = \"\"\n    logger.info(\"Created memory %s, waiting for ACTIVE status...\", memory_id)\n\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            status = self.get_memory_status(memory_id)\n\n            if status == MemoryStatus.ACTIVE.value:\n                logger.info(\"Memory %s is now ACTIVE (took %d seconds)\", memory_id, elapsed)\n                # Get fresh memory details\n                response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                memory = self._normalize_memory_response(response[\"memory\"])\n                return memory\n            elif status == MemoryStatus.FAILED.value:\n                # Get failure reason if available\n                response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n                failure_reason = response[\"memory\"].get(\"failureReason\", \"Unknown\")\n                raise RuntimeError(\"Memory creation failed: %s\" % failure_reason)\n            else:\n                logger.debug(\"Memory status: %s (%d seconds elapsed)\", status, elapsed)\n\n        except ClientError as e:\n            logger.error(\"Error checking memory status: %s\", e)\n            raise\n\n        time.sleep(poll_interval)\n\n    raise TimeoutError(\"Memory %s did not become ACTIVE within %d seconds\" % (memory_id, max_wait))\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.create_or_get_memory","title":"<code>create_or_get_memory(name, strategies=None, description=None, event_expiry_days=90, memory_execution_role_arn=None)</code>","text":"<p>Create a memory resource or fetch the existing memory details if it already exists.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Memory object, either newly created or existing</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def create_or_get_memory(\n    self,\n    name: str,\n    strategies: Optional[List[Dict[str, Any]]] = None,\n    description: Optional[str] = None,\n    event_expiry_days: int = 90,\n    memory_execution_role_arn: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory resource or fetch the existing memory details if it already exists.\n\n    Returns:\n        Memory object, either newly created or existing\n    \"\"\"\n    try:\n        memory = self.create_memory_and_wait(\n            name=name,\n            strategies=strategies,\n            description=description,\n            event_expiry_days=event_expiry_days,\n            memory_execution_role_arn=memory_execution_role_arn,\n        )\n        return memory\n    except ClientError as e:\n        if e.response[\"Error\"][\"Code\"] == \"ValidationException\" and \"already exists\" in str(e):\n            memories = self.list_memories()\n            memory = next((m for m in memories if m[\"id\"].startswith(name)), None)\n            logger.info(\"Memory already exists. Using existing memory ID: %s\", memory[\"id\"])\n            return memory\n        else:\n            logger.error(\"ClientError: Failed to create or get memory: %s\", e)\n            raise\n    except Exception:\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_memory","title":"<code>delete_memory(memory_id)</code>","text":"<p>Delete a memory resource.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_memory(self, memory_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory resource.\"\"\"\n    try:\n        response = self.gmcp_client.delete_memory(\n            memoryId=memory_id, clientToken=str(uuid.uuid4())\n        )  # Input uses old field name\n        logger.info(\"Deleted memory: %s\", memory_id)\n        return response\n    except ClientError as e:\n        logger.error(\"Failed to delete memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_memory_and_wait","title":"<code>delete_memory_and_wait(memory_id, max_wait=300, poll_interval=10)</code>","text":"<p>Delete a memory and wait for deletion to complete.</p> <p>This method deletes a memory and polls until it's fully deleted, ensuring clean resource cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID to delete</p> required <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 300)</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks (default: 10)</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Final deletion response</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If deletion doesn't complete within max_wait</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_memory_and_wait(self, memory_id: str, max_wait: int = 300, poll_interval: int = 10) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory and wait for deletion to complete.\n\n    This method deletes a memory and polls until it's fully deleted,\n    ensuring clean resource cleanup.\n\n    Args:\n        memory_id: Memory resource ID to delete\n        max_wait: Maximum seconds to wait (default: 300)\n        poll_interval: Seconds between checks (default: 10)\n\n    Returns:\n        Final deletion response\n\n    Raises:\n        TimeoutError: If deletion doesn't complete within max_wait\n    \"\"\"\n    # Initiate deletion\n    response = self.delete_memory(memory_id)\n    logger.info(\"Initiated deletion of memory %s\", memory_id)\n\n    start_time = time.time()\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            # Try to get the memory - if it doesn't exist, deletion is complete\n            self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n            logger.debug(\"Memory still exists, waiting... (%d seconds elapsed)\", elapsed)\n\n        except ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                logger.info(\"Memory %s successfully deleted (took %d seconds)\", memory_id, elapsed)\n                return response\n            else:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n        time.sleep(poll_interval)\n\n    raise TimeoutError(\"Memory %s was not deleted within %d seconds\" % (memory_id, max_wait))\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.delete_strategy","title":"<code>delete_strategy(memory_id, strategy_id)</code>","text":"<p>Delete a strategy from a memory.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def delete_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Delete a strategy from a memory.\"\"\"\n    return self.update_memory_strategies(memory_id=memory_id, delete_strategy_ids=[strategy_id])\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.fork_conversation","title":"<code>fork_conversation(memory_id, actor_id, session_id, root_event_id, branch_name, new_messages, event_timestamp=None)</code>","text":"<p>Fork a conversation from a specific event to create a new branch.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def fork_conversation(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    root_event_id: str,\n    branch_name: str,\n    new_messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n    try:\n        branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n        event = self.create_event(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=new_messages,\n            branch=branch,\n            event_timestamp=event_timestamp,\n        )\n\n        logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to fork conversation: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_conversation_tree","title":"<code>get_conversation_tree(memory_id, actor_id, session_id)</code>","text":"<p>Get a tree structure of the conversation with all branches.</p> <p>This method transforms a flat list of events into a hierarchical tree structure, providing visualization-ready data that would be complex to build from raw events. It handles: - Full pagination to get all events - Grouping by branches - Message summarization - Tree structure building</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representing the conversation tree structure</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_conversation_tree(self, memory_id: str, actor_id: str, session_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Get a tree structure of the conversation with all branches.\n\n    This method transforms a flat list of events into a hierarchical tree structure,\n    providing visualization-ready data that would be complex to build from raw events.\n    It handles:\n    - Full pagination to get all events\n    - Grouping by branches\n    - Message summarization\n    - Tree structure building\n\n    Returns:\n        Dictionary representing the conversation tree structure\n    \"\"\"\n    try:\n        # Get all events - need to handle pagination for complete list\n        all_events = []\n        next_token = None\n\n        while True:\n            params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.gmdp_client.list_events(**params)\n            all_events.extend(response.get(\"events\", []))\n\n            next_token = response.get(\"nextToken\")\n            if not next_token:\n                break\n\n        # Build tree structure\n        tree = {\"session_id\": session_id, \"actor_id\": actor_id, \"main_branch\": {\"events\": [], \"branches\": {}}}\n\n        # Group events by branch\n        for event in all_events:\n            event_summary = {\"eventId\": event[\"eventId\"], \"timestamp\": event[\"eventTimestamp\"], \"messages\": []}\n\n            # Extract message summaries\n            if \"payload\" in event:\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        conv = payload_item[\"conversational\"]\n                        event_summary[\"messages\"].append(\n                            {\"role\": conv.get(\"role\"), \"text\": conv.get(\"content\", {}).get(\"text\", \"\")[:50] + \"...\"}\n                        )\n\n            branch_info = event.get(\"branch\")\n            if branch_info:\n                branch_name = branch_info[\"name\"]\n                root_event = branch_info.get(\"rootEventId\")  # Use .get() to handle missing field\n\n                if branch_name not in tree[\"main_branch\"][\"branches\"]:\n                    tree[\"main_branch\"][\"branches\"][branch_name] = {\"root_event_id\": root_event, \"events\": []}\n\n                tree[\"main_branch\"][\"branches\"][branch_name][\"events\"].append(event_summary)\n            else:\n                tree[\"main_branch\"][\"events\"].append(event_summary)\n\n        logger.info(\"Built conversation tree with %d branches\", len(tree[\"main_branch\"][\"branches\"]))\n        return tree\n\n    except ClientError as e:\n        logger.error(\"Failed to build conversation tree: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_last_k_turns","title":"<code>get_last_k_turns(memory_id, actor_id, session_id, k=5, branch_name=None, include_branches=False, max_results=100)</code>","text":"<p>Get the last K conversation turns.</p> <p>A \"turn\" typically consists of a user message followed by assistant response(s). This method groups messages into logical turns for easier processing.</p> <p>Returns:</p> Type Description <code>List[List[Dict[str, Any]]]</code> <p>List of turns, where each turn is a list of message dictionaries</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_last_k_turns(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    k: int = 5,\n    branch_name: Optional[str] = None,\n    include_branches: bool = False,\n    max_results: int = 100,\n) -&gt; List[List[Dict[str, Any]]]:\n    \"\"\"Get the last K conversation turns.\n\n    A \"turn\" typically consists of a user message followed by assistant response(s).\n    This method groups messages into logical turns for easier processing.\n\n    Returns:\n        List of turns, where each turn is a list of message dictionaries\n    \"\"\"\n    try:\n        # Use the new list_events method\n        events = self.list_events(\n            memory_id=memory_id,\n            actor_id=actor_id,\n            session_id=session_id,\n            branch_name=branch_name,\n            include_parent_branches=False,\n            max_results=max_results,\n        )\n\n        if not events:\n            return []\n\n        # Process events to group into turns\n        turns = []\n        current_turn = []\n\n        for event in events:\n            if len(turns) &gt;= k:\n                break  # Only need last K turns\n            for payload_item in event.get(\"payload\", []):\n                if \"conversational\" in payload_item:\n                    role = payload_item[\"conversational\"].get(\"role\")\n\n                    # Start new turn on USER message\n                    if role == Role.USER.value and current_turn:\n                        turns.append(current_turn)\n                        current_turn = []\n\n                    current_turn.append(payload_item[\"conversational\"])\n\n        # Don't forget the last turn\n        if current_turn:\n            turns.append(current_turn)\n\n        # Return the last k turns\n        return turns[:k] if len(turns) &gt; k else turns\n\n    except ClientError as e:\n        logger.error(\"Failed to get last K turns: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_memory_status","title":"<code>get_memory_status(memory_id)</code>","text":"<p>Get current memory status.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_memory_status(self, memory_id: str) -&gt; str:\n    \"\"\"Get current memory status.\"\"\"\n    try:\n        response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n        return response[\"memory\"][\"status\"]\n    except ClientError as e:\n        logger.error(\"Failed to get memory status: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.get_memory_strategies","title":"<code>get_memory_strategies(memory_id)</code>","text":"<p>Get all strategies for a memory.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def get_memory_strategies(self, memory_id: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all strategies for a memory.\"\"\"\n    try:\n        response = self.gmcp_client.get_memory(memoryId=memory_id)  # Input uses old field name\n        memory = response[\"memory\"]\n\n        # Handle both old and new field names in response\n        strategies = memory.get(\"strategies\", memory.get(\"memoryStrategies\", []))\n\n        # Normalize strategy fields\n        normalized_strategies = []\n        for strategy in strategies:\n            # Create normalized version with both old and new field names\n            normalized = strategy.copy()\n\n            # Ensure both field name versions exist\n            if \"strategyId\" in strategy and \"memoryStrategyId\" not in normalized:\n                normalized[\"memoryStrategyId\"] = strategy[\"strategyId\"]\n            elif \"memoryStrategyId\" in strategy and \"strategyId\" not in normalized:\n                normalized[\"strategyId\"] = strategy[\"memoryStrategyId\"]\n\n            if \"type\" in strategy and \"memoryStrategyType\" not in normalized:\n                normalized[\"memoryStrategyType\"] = strategy[\"type\"]\n            elif \"memoryStrategyType\" in strategy and \"type\" not in normalized:\n                normalized[\"type\"] = strategy[\"memoryStrategyType\"]\n\n            normalized_strategies.append(normalized)\n\n        return normalized_strategies\n    except ClientError as e:\n        logger.error(\"Failed to get memory strategies: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_branch_events","title":"<code>list_branch_events(memory_id, actor_id, session_id, branch_name=None, include_parent_branches=False, max_results=100)</code>","text":"<p>List events in a specific branch.</p> <p>This method provides complex filtering and pagination that would require significant boilerplate code with raw boto3. It handles: - Automatic pagination across multiple API calls - Branch filtering with parent event inclusion logic - Main branch isolation (events without branch info)</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>Optional[str]</code> <p>Branch name (None for main branch)</p> <code>None</code> <code>include_parent_branches</code> <code>bool</code> <p>Whether to include events from parent branches</p> <code>False</code> <code>max_results</code> <code>int</code> <p>Maximum events to return</p> <code>100</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of events in the branch</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_branch_events(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    branch_name: Optional[str] = None,\n    include_parent_branches: bool = False,\n    max_results: int = 100,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List events in a specific branch.\n\n    This method provides complex filtering and pagination that would require\n    significant boilerplate code with raw boto3. It handles:\n    - Automatic pagination across multiple API calls\n    - Branch filtering with parent event inclusion logic\n    - Main branch isolation (events without branch info)\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Branch name (None for main branch)\n        include_parent_branches: Whether to include events from parent branches\n        max_results: Maximum events to return\n\n    Returns:\n        List of events in the branch\n    \"\"\"\n    try:\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"maxResults\": min(100, max_results),\n        }\n\n        # Only add filter when we have a specific branch name\n        if branch_name:\n            params[\"filter\"] = {\"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_branches}}\n\n        response = self.gmdp_client.list_events(**params)\n        events = response.get(\"events\", [])\n\n        # Handle pagination\n        next_token = response.get(\"nextToken\")\n        while next_token and len(events) &lt; max_results:\n            params[\"nextToken\"] = next_token\n            params[\"maxResults\"] = min(100, max_results - len(events))\n            response = self.gmdp_client.list_events(**params)\n            events.extend(response.get(\"events\", []))\n            next_token = response.get(\"nextToken\")\n\n        # Filter for main branch if no branch specified\n        if not branch_name:\n            events = [e for e in events if not e.get(\"branch\")]\n\n        logger.info(\"Retrieved %d events from branch '%s'\", len(events), branch_name or \"main\")\n        return events\n\n    except ClientError as e:\n        logger.error(\"Failed to list branch events: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_branches","title":"<code>list_branches(memory_id, actor_id, session_id)</code>","text":"<p>List all branches in a session.</p> <p>This method handles pagination automatically and provides a structured view of all conversation branches, which would require complex pagination and grouping logic if done with raw boto3 calls.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of branch information including name and root event</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_branches(self, memory_id: str, actor_id: str, session_id: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all branches in a session.\n\n    This method handles pagination automatically and provides a structured view\n    of all conversation branches, which would require complex pagination and\n    grouping logic if done with raw boto3 calls.\n\n    Returns:\n        List of branch information including name and root event\n    \"\"\"\n    try:\n        # Get all events - need to handle pagination for complete list\n        all_events = []\n        next_token = None\n\n        while True:\n            params = {\"memoryId\": memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.gmdp_client.list_events(**params)\n            all_events.extend(response.get(\"events\", []))\n\n            next_token = response.get(\"nextToken\")\n            if not next_token:\n                break\n\n        branches = {}\n        main_branch_events = []\n\n        for event in all_events:\n            branch_info = event.get(\"branch\")\n            if branch_info:\n                branch_name = branch_info[\"name\"]\n                if branch_name not in branches:\n                    branches[branch_name] = {\n                        \"name\": branch_name,\n                        \"rootEventId\": branch_info.get(\"rootEventId\"),\n                        \"firstEventId\": event[\"eventId\"],\n                        \"eventCount\": 1,\n                        \"created\": event[\"eventTimestamp\"],\n                    }\n                else:\n                    branches[branch_name][\"eventCount\"] += 1\n            else:\n                main_branch_events.append(event)\n\n        # Build result list\n        result = []\n\n        # Only add main branch if there are actual events\n        if main_branch_events:\n            result.append(\n                {\n                    \"name\": \"main\",\n                    \"rootEventId\": None,\n                    \"firstEventId\": main_branch_events[0][\"eventId\"],\n                    \"eventCount\": len(main_branch_events),\n                    \"created\": main_branch_events[0][\"eventTimestamp\"],\n                }\n            )\n\n        # Add other branches\n        result.extend(list(branches.values()))\n\n        logger.info(\"Found %d branches in session %s\", len(result), session_id)\n        return result\n\n    except ClientError as e:\n        logger.error(\"Failed to list branches: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events","title":"<code>list_events(memory_id, actor_id, session_id, branch_name=None, include_parent_branches=False, max_results=100, include_payload=True)</code>","text":"<p>List all events in a session with pagination support.</p> <p>This method provides direct access to the raw events API, allowing developers to retrieve all events without the turn grouping logic of get_last_k_turns.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>Optional[str]</code> <p>Optional branch name to filter events (None for all branches)</p> <code>None</code> <code>include_parent_branches</code> <code>bool</code> <p>Whether to include parent branch events (only applies with branch_name)</p> <code>False</code> <code>max_results</code> <code>int</code> <p>Maximum number of events to return</p> <code>100</code> <code>include_payload</code> <code>bool</code> <p>Whether to include event payloads in response</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of event dictionaries in chronological order</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_events(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    branch_name: Optional[str] = None,\n    include_parent_branches: bool = False,\n    max_results: int = 100,\n    include_payload: bool = True,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all events in a session with pagination support.\n\n    This method provides direct access to the raw events API, allowing developers\n    to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Optional branch name to filter events (None for all branches)\n        include_parent_branches: Whether to include parent branch events (only applies with branch_name)\n        max_results: Maximum number of events to return\n        include_payload: Whether to include event payloads in response\n\n    Returns:\n        List of event dictionaries in chronological order\n\n    Example:\n        # Get all events\n        events = client.list_events(memory_id, actor_id, session_id)\n\n        # Get only main branch events\n        main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")\n\n        # Get events from a specific branch\n        branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")\n    \"\"\"\n    try:\n        all_events = []\n        next_token = None\n\n        while len(all_events) &lt; max_results:\n            params = {\n                \"memoryId\": memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"maxResults\": min(100, max_results - len(all_events)),\n                \"includePayloads\": include_payload,\n            }\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            # Add branch filter if specified (but not for \"main\")\n            if branch_name and branch_name != \"main\":\n                params[\"filter\"] = {\n                    \"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_branches}\n                }\n\n            response = self.gmdp_client.list_events(**params)\n\n            events = response.get(\"events\", [])\n            all_events.extend(events)\n\n            next_token = response.get(\"nextToken\")\n            if not next_token or len(all_events) &gt;= max_results:\n                break\n\n        logger.info(\"Retrieved total of %d events\", len(all_events))\n        return all_events[:max_results]\n\n    except ClientError as e:\n        logger.error(\"Failed to list events: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-all-events","title":"Get all events","text":"<p>events = client.list_events(memory_id, actor_id, session_id)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-only-main-branch-events","title":"Get only main branch events","text":"<p>main_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"main\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_events--get-events-from-a-specific-branch","title":"Get events from a specific branch","text":"<p>branch_events = client.list_events(memory_id, actor_id, session_id, branch_name=\"test-branch\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.list_memories","title":"<code>list_memories(max_results=100)</code>","text":"<p>List all memories for the account.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all memories for the account.\"\"\"\n    try:\n        # Ensure max_results doesn't exceed API limit per request\n        results_per_request = min(max_results, 100)\n\n        response = self.gmcp_client.list_memories(maxResults=results_per_request)\n        memories = response.get(\"memories\", [])\n\n        next_token = response.get(\"nextToken\")\n        while next_token and len(memories) &lt; max_results:\n            remaining = max_results - len(memories)\n            results_per_request = min(remaining, 100)\n\n            response = self.gmcp_client.list_memories(maxResults=results_per_request, nextToken=next_token)\n            memories.extend(response.get(\"memories\", []))\n            next_token = response.get(\"nextToken\")\n\n        # Normalize memory summaries if they contain new field names\n        normalized_memories = []\n        for memory in memories[:max_results]:\n            normalized = memory.copy()\n            # Ensure both field name versions exist\n            if \"id\" in memory and \"memoryId\" not in normalized:\n                normalized[\"memoryId\"] = memory[\"id\"]\n            elif \"memoryId\" in memory and \"id\" not in normalized:\n                normalized[\"id\"] = memory[\"memoryId\"]\n            normalized_memories.append(normalized)\n\n        return normalized_memories\n\n    except ClientError as e:\n        logger.error(\"Failed to list memories: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.merge_branch_context","title":"<code>merge_branch_context(memory_id, actor_id, session_id, branch_name, include_parent=True)</code>","text":"<p>Get all messages from a branch for context building.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>str</code> <p>Branch to get context from</p> required <code>include_parent</code> <code>bool</code> <p>Whether to include parent branch events</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of all messages in chronological order</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def merge_branch_context(\n    self, memory_id: str, actor_id: str, session_id: str, branch_name: str, include_parent: bool = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all messages from a branch for context building.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Branch to get context from\n        include_parent: Whether to include parent branch events\n\n    Returns:\n        List of all messages in chronological order\n    \"\"\"\n    events = self.list_branch_events(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        branch_name=branch_name,\n        include_parent_branches=include_parent,\n        max_results=100,\n    )\n\n    messages = []\n    for event in events:\n        if \"payload\" in event:\n            for payload_item in event.get(\"payload\", []):\n                if \"conversational\" in payload_item:\n                    conv = payload_item[\"conversational\"]\n                    messages.append(\n                        {\n                            \"timestamp\": event[\"eventTimestamp\"],\n                            \"eventId\": event[\"eventId\"],\n                            \"branch\": event.get(\"branch\", {}).get(\"name\", \"main\"),\n                            \"role\": conv.get(\"role\"),\n                            \"content\": conv.get(\"content\", {}).get(\"text\", \"\"),\n                        }\n                    )\n\n    # Sort by timestamp\n    messages.sort(key=lambda x: x[\"timestamp\"])\n\n    logger.info(\"Retrieved %d messages from branch '%s'\", len(messages), branch_name)\n    return messages\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.modify_strategy","title":"<code>modify_strategy(memory_id, strategy_id, description=None, namespaces=None, configuration=None)</code>","text":"<p>Modify a strategy with full control over configuration.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def modify_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    configuration: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Modify a strategy with full control over configuration.\"\"\"\n    modify_config: Dict = {\"memoryStrategyId\": strategy_id}  # Using old field name for input\n\n    if description is not None:\n        modify_config[\"description\"] = description\n    if namespaces is not None:\n        modify_config[\"namespaces\"] = namespaces\n    if configuration is not None:\n        modify_config[\"configuration\"] = configuration\n\n    return self.update_memory_strategies(memory_id=memory_id, modify_strategies=[modify_config])\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.process_turn","title":"<code>process_turn(memory_id, actor_id, session_id, user_input, agent_response, event_timestamp=None, retrieval_namespace=None, retrieval_query=None, top_k=3)</code>","text":"<p>DEPRECATED: Use retrieve_memories() and save_conversation() separately.</p> <p>This method will be removed in v1.0.0.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def process_turn(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    agent_response: str,\n    event_timestamp: Optional[datetime] = None,\n    retrieval_namespace: Optional[str] = None,\n    retrieval_query: Optional[str] = None,\n    top_k: int = 3,\n) -&gt; Tuple[List[Dict[str, Any]], Dict[str, Any]]:\n    \"\"\"DEPRECATED: Use retrieve_memories() and save_conversation() separately.\n\n    This method will be removed in v1.0.0.\n    \"\"\"\n    warnings.warn(\n        \"process_turn() is deprecated and will be removed in v1.0.0. \"\n        \"Use retrieve_memories() and save_conversation() separately, or use process_turn_with_llm().\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    retrieved_memories = []\n\n    if retrieval_namespace:\n        search_query = retrieval_query or user_input\n        retrieved_memories = self.retrieve_memories(\n            memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n        )\n\n    event = self.save_turn(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        user_input=user_input,\n        agent_response=agent_response,\n        event_timestamp=event_timestamp,\n    )\n\n    return retrieved_memories, event\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.process_turn_with_llm","title":"<code>process_turn_with_llm(memory_id, actor_id, session_id, user_input, llm_callback, retrieval_namespace=None, retrieval_query=None, top_k=3, event_timestamp=None)</code>","text":"<p>Complete conversation turn with LLM callback integration.</p> <p>This method combines memory retrieval, LLM invocation, and response storage in a single call using a callback pattern.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier (e.g., \"user-123\")</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>user_input</code> <code>str</code> <p>The user's message</p> required <code>llm_callback</code> <code>Callable[[str, List[Dict[str, Any]]], str]</code> <p>Function that takes (user_input, memories) and returns agent_response          The callback receives the user input and retrieved memories,          and should return the agent's response string</p> required <code>retrieval_namespace</code> <code>Optional[str]</code> <p>Namespace to search for memories (optional)</p> <code>None</code> <code>retrieval_query</code> <code>Optional[str]</code> <p>Custom search query (defaults to user_input)</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of memories to retrieve</p> <code>3</code> <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the event</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[Dict[str, Any]], str, Dict[str, Any]]</code> <p>Tuple of (retrieved_memories, agent_response, created_event)</p> Example <p>def my_llm(user_input: str, memories: List[Dict]) -&gt; str:     # Format context from memories     context = \"\\n\".join([m['content']['text'] for m in memories])</p> <pre><code># Call your LLM (Bedrock, OpenAI, etc.)\nresponse = bedrock.invoke_model(\n    messages=[\n        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n        {\"role\": \"user\", \"content\": user_input}\n    ]\n)\nreturn response['content']\n</code></pre> <p>memories, response, event = client.process_turn_with_llm(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     user_input=\"What did we discuss yesterday?\",     llm_callback=my_llm,     retrieval_namespace=\"support/facts/{sessionId}\" )</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def process_turn_with_llm(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n    retrieval_namespace: Optional[str] = None,\n    retrieval_query: Optional[str] = None,\n    top_k: int = 3,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n    r\"\"\"Complete conversation turn with LLM callback integration.\n\n    This method combines memory retrieval, LLM invocation, and response storage\n    in a single call using a callback pattern.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier (e.g., \"user-123\")\n        session_id: Session identifier\n        user_input: The user's message\n        llm_callback: Function that takes (user_input, memories) and returns agent_response\n                     The callback receives the user input and retrieved memories,\n                     and should return the agent's response string\n        retrieval_namespace: Namespace to search for memories (optional)\n        retrieval_query: Custom search query (defaults to user_input)\n        top_k: Number of memories to retrieve\n        event_timestamp: Optional timestamp for the event\n\n    Returns:\n        Tuple of (retrieved_memories, agent_response, created_event)\n\n    Example:\n        def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n            # Format context from memories\n            context = \"\\\\n\".join([m['content']['text'] for m in memories])\n\n            # Call your LLM (Bedrock, OpenAI, etc.)\n            response = bedrock.invoke_model(\n                messages=[\n                    {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                    {\"role\": \"user\", \"content\": user_input}\n                ]\n            )\n            return response['content']\n\n        memories, response, event = client.process_turn_with_llm(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            user_input=\"What did we discuss yesterday?\",\n            llm_callback=my_llm,\n            retrieval_namespace=\"support/facts/{sessionId}\"\n        )\n    \"\"\"\n    # Step 1: Retrieve relevant memories\n    retrieved_memories = []\n    if retrieval_namespace:\n        search_query = retrieval_query or user_input\n        retrieved_memories = self.retrieve_memories(\n            memory_id=memory_id, namespace=retrieval_namespace, query=search_query, top_k=top_k\n        )\n        logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n    # Step 2: Invoke LLM callback\n    try:\n        agent_response = llm_callback(user_input, retrieved_memories)\n        if not isinstance(agent_response, str):\n            raise ValueError(\"LLM callback must return a string response\")\n        logger.info(\"LLM callback generated response\")\n    except Exception as e:\n        logger.error(\"LLM callback failed: %s\", e)\n        raise\n\n    # Step 3: Save the conversation turn\n    event = self.create_event(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        messages=[(user_input, \"USER\"), (agent_response, \"ASSISTANT\")],\n        event_timestamp=event_timestamp,\n    )\n\n    logger.info(\"Completed full conversation turn with LLM\")\n    return retrieved_memories, agent_response, event\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories","title":"<code>retrieve_memories(memory_id, namespace, query, actor_id=None, top_k=3)</code>","text":"<p>Retrieve relevant memories from a namespace.</p> <p>Note: Wildcards (*) are NOT supported in namespaces. You must provide the exact namespace path with all variables resolved.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>namespace</code> <code>str</code> <p>Exact namespace path (no wildcards)</p> required <code>query</code> <code>str</code> <p>Search query</p> required <code>actor_id</code> <code>Optional[str]</code> <p>Optional actor ID (deprecated, use namespace)</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of results to return</p> <code>3</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of memory records</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def retrieve_memories(\n    self, memory_id: str, namespace: str, query: str, actor_id: Optional[str] = None, top_k: int = 3\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Retrieve relevant memories from a namespace.\n\n    Note: Wildcards (*) are NOT supported in namespaces. You must provide the\n    exact namespace path with all variables resolved.\n\n    Args:\n        memory_id: Memory resource ID\n        namespace: Exact namespace path (no wildcards)\n        query: Search query\n        actor_id: Optional actor ID (deprecated, use namespace)\n        top_k: Number of results to return\n\n    Returns:\n        List of memory records\n\n    Example:\n        # Correct - exact namespace\n        memories = client.retrieve_memories(\n            memory_id=\"mem-123\",\n            namespace=\"support/facts/session-456\",\n            query=\"customer preferences\"\n        )\n\n        # Incorrect - wildcards not supported\n        # memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)\n    \"\"\"\n    if \"*\" in namespace:\n        logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n        return []\n\n    try:\n        # Let service handle all namespace validation\n        response = self.gmdp_client.retrieve_memory_records(\n            memoryId=memory_id, namespace=namespace, searchCriteria={\"searchQuery\": query, \"topK\": top_k}\n        )\n\n        memories = response.get(\"memoryRecordSummaries\", [])\n        logger.info(\"Retrieved %d memories from namespace: %s\", len(memories), namespace)\n        return memories\n\n    except ClientError as e:\n        error_code = e.response[\"Error\"][\"Code\"]\n        error_msg = e.response[\"Error\"][\"Message\"]\n\n        if error_code == \"ResourceNotFoundException\":\n            logger.warning(\n                \"Memory or namespace not found. Ensure memory %s exists and namespace '%s' is configured\",\n                memory_id,\n                namespace,\n            )\n        elif error_code == \"ValidationException\":\n            logger.warning(\"Invalid search parameters: %s\", error_msg)\n        elif error_code == \"ServiceException\":\n            logger.warning(\"Service error: %s. This may be temporary - try again later\", error_msg)\n        else:\n            logger.warning(\"Memory retrieval failed (%s): %s\", error_code, error_msg)\n\n        return []\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--correct-exact-namespace","title":"Correct - exact namespace","text":"<p>memories = client.retrieve_memories(     memory_id=\"mem-123\",     namespace=\"support/facts/session-456\",     query=\"customer preferences\" )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--incorrect-wildcards-not-supported","title":"Incorrect - wildcards not supported","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.retrieve_memories--memories-clientretrieve_memories-namespacesupportfacts","title":"memories = client.retrieve_memories(..., namespace=\"support/facts/*\", ...)","text":""},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation","title":"<code>save_conversation(memory_id, actor_id, session_id, messages, event_timestamp=None, branch=None)</code>","text":"<p>DEPRECATED: Use create_event() instead.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>messages</code> <code>List[Tuple[str, str]]</code> <p>List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the entire event (not per message)</p> <code>None</code> <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}    For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created event</p> Example Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def save_conversation(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    messages: List[Tuple[str, str]],\n    event_timestamp: Optional[datetime] = None,\n    branch: Optional[Dict[str, str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"DEPRECATED: Use create_event() instead.\n\n    Args:\n        memory_id: Memory resource ID\n        actor_id: Actor identifier\n        session_id: Session identifier\n        messages: List of (text, role) tuples. Role can be USER, ASSISTANT, TOOL, etc.\n        event_timestamp: Optional timestamp for the entire event (not per message)\n        branch: Optional branch info. For new branches: {\"rootEventId\": \"...\", \"name\": \"...\"}\n               For continuing existing branch: {\"name\": \"...\"} or {\"name\": \"...\", \"rootEventId\": \"...\"}\n\n    Returns:\n        Created event\n\n    Example:\n        # Save multi-turn conversation\n        event = client.save_conversation(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            messages=[\n                (\"What's the weather?\", \"USER\"),\n                (\"And tomorrow?\", \"USER\"),\n                (\"Checking weather...\", \"TOOL\"),\n                (\"Today sunny, tomorrow rain\", \"ASSISTANT\")\n            ]\n        )\n\n        # Continue existing branch (only name required)\n        event = client.save_conversation(\n            memory_id=\"mem-xyz\",\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            messages=[(\"Continue conversation\", \"USER\")],\n            branch={\"name\": \"existing-branch\"}\n        )\n    \"\"\"\n    try:\n        if not messages:\n            raise ValueError(\"At least one message is required\")\n\n        # Build payload\n        payload = []\n\n        for msg in messages:\n            if len(msg) != 2:\n                raise ValueError(\"Each message must be (text, role)\")\n\n            text, role = msg\n\n            # Validate role\n            try:\n                role_enum = MessageRole(role.upper())\n            except ValueError as err:\n                raise ValueError(\n                    \"Invalid role '%s'. Must be one of: %s\" % (role, \", \".join([r.value for r in MessageRole]))\n                ) from err\n\n            payload.append({\"conversational\": {\"content\": {\"text\": text}, \"role\": role_enum.value}})\n\n        # Use provided timestamp or current time\n        if event_timestamp is None:\n            event_timestamp = datetime.utcnow()\n\n        params = {\n            \"memoryId\": memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n\n        response = self.gmdp_client.create_event(**params)\n\n        event = response[\"event\"]\n        logger.info(\"Created event: %s\", event[\"eventId\"])\n\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to create event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation--save-multi-turn-conversation","title":"Save multi-turn conversation","text":"<p>event = client.save_conversation(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     messages=[         (\"What's the weather?\", \"USER\"),         (\"And tomorrow?\", \"USER\"),         (\"Checking weather...\", \"TOOL\"),         (\"Today sunny, tomorrow rain\", \"ASSISTANT\")     ] )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_conversation--continue-existing-branch-only-name-required","title":"Continue existing branch (only name required)","text":"<p>event = client.save_conversation(     memory_id=\"mem-xyz\",     actor_id=\"user-123\",     session_id=\"session-456\",     messages=[(\"Continue conversation\", \"USER\")],     branch={\"name\": \"existing-branch\"} )</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.save_turn","title":"<code>save_turn(memory_id, actor_id, session_id, user_input, agent_response, event_timestamp=None)</code>","text":"<p>DEPRECATED: Use save_conversation() for more flexibility.</p> <p>This method will be removed in v1.0.0.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def save_turn(\n    self,\n    memory_id: str,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    agent_response: str,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"DEPRECATED: Use save_conversation() for more flexibility.\n\n    This method will be removed in v1.0.0.\n    \"\"\"\n    warnings.warn(\n        \"save_turn() is deprecated and will be removed in v1.0.0. \"\n        \"Use save_conversation() for flexible message handling.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    messages = [(user_input, \"USER\"), (agent_response, \"ASSISTANT\")]\n\n    return self.create_event(\n        memory_id=memory_id,\n        actor_id=actor_id,\n        session_id=session_id,\n        messages=messages,\n        event_timestamp=event_timestamp,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.update_memory_strategies","title":"<code>update_memory_strategies(memory_id, add_strategies=None, modify_strategies=None, delete_strategy_ids=None)</code>","text":"<p>Update memory strategies - add, modify, or delete.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def update_memory_strategies(\n    self,\n    memory_id: str,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update memory strategies - add, modify, or delete.\"\"\"\n    try:\n        memory_strategies = {}\n\n        if add_strategies:\n            processed_add = self._add_default_namespaces(add_strategies)\n            memory_strategies[\"addMemoryStrategies\"] = processed_add  # Using old field name for input\n\n        if modify_strategies:\n            current_strategies = self.get_memory_strategies(memory_id)\n            strategy_map = {s[\"memoryStrategyId\"]: s for s in current_strategies}  # Using normalized field\n\n            modify_list = []\n            for strategy in modify_strategies:\n                if \"memoryStrategyId\" not in strategy:  # Using old field name\n                    raise ValueError(\"Each modify strategy must include memoryStrategyId\")\n\n                strategy_id = strategy[\"memoryStrategyId\"]  # Using old field name\n                strategy_info = strategy_map.get(strategy_id)\n\n                if not strategy_info:\n                    raise ValueError(\"Strategy %s not found in memory %s\" % (strategy_id, memory_id))\n\n                strategy_type = strategy_info[\"memoryStrategyType\"]  # Using normalized field\n                override_type = strategy_info.get(\"configuration\", {}).get(\"type\")\n\n                strategy_copy = copy.deepcopy(strategy)\n\n                if \"configuration\" in strategy_copy:\n                    wrapped_config = self._wrap_configuration(\n                        strategy_copy[\"configuration\"], strategy_type, override_type\n                    )\n                    strategy_copy[\"configuration\"] = wrapped_config\n\n                modify_list.append(strategy_copy)\n\n            memory_strategies[\"modifyMemoryStrategies\"] = modify_list  # Using old field name for input\n\n        if delete_strategy_ids:\n            delete_list = [{\"memoryStrategyId\": sid} for sid in delete_strategy_ids]  # Using old field name\n            memory_strategies[\"deleteMemoryStrategies\"] = delete_list  # Using old field name for input\n\n        if not memory_strategies:\n            raise ValueError(\"No strategy operations provided\")\n\n        response = self.gmcp_client.update_memory(\n            memoryId=memory_id,\n            memoryStrategies=memory_strategies,\n            clientToken=str(uuid.uuid4()),  # Using old field names for input\n        )\n\n        logger.info(\"Updated memory strategies for: %s\", memory_id)\n        memory = self._normalize_memory_response(response[\"memory\"])\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to update memory strategies: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.update_memory_strategies_and_wait","title":"<code>update_memory_strategies_and_wait(memory_id, add_strategies=None, modify_strategies=None, delete_strategy_ids=None, max_wait=300, poll_interval=10)</code>","text":"<p>Update memory strategies and wait for memory to return to ACTIVE state.</p> <p>This method handles the temporary CREATING state that occurs when updating strategies, preventing subsequent update errors.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def update_memory_strategies_and_wait(\n    self,\n    memory_id: str,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update memory strategies and wait for memory to return to ACTIVE state.\n\n    This method handles the temporary CREATING state that occurs when\n    updating strategies, preventing subsequent update errors.\n    \"\"\"\n    # Update strategies\n    self.update_memory_strategies(memory_id, add_strategies, modify_strategies, delete_strategy_ids)\n\n    # Wait for memory to return to ACTIVE\n    return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryClient.wait_for_memories","title":"<code>wait_for_memories(memory_id, namespace, test_query='test', max_wait=180, poll_interval=15)</code>","text":"<p>Wait for memory extraction to complete by polling.</p> <p>IMPORTANT LIMITATIONS: 1. This method only works reliably on empty namespaces. If there are already    existing memories in the namespace, this method may return True immediately    even if new extractions haven't completed. 2. Wildcards () are NOT supported in namespaces. You must provide the exact    namespace path with all variables resolved (e.g., \"support/facts/session-123\"    not \"support/facts/\").</p> <p>For subsequent extractions in populated namespaces, use a fixed wait time:     time.sleep(150)  # Wait 2.5 minutes for extraction</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>namespace</code> <code>str</code> <p>Exact namespace to check (no wildcards)</p> required <code>test_query</code> <code>str</code> <p>Query to test with (default: \"test\")</p> <code>'test'</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait (default: 180)</p> <code>180</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks (default: 15)</p> <code>15</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if memories found, False if timeout</p> Note <p>This method will be deprecated in future versions once the API provides extraction status or timestamps.</p> Source code in <code>bedrock_agentcore/memory/client.py</code> <pre><code>def wait_for_memories(\n    self, memory_id: str, namespace: str, test_query: str = \"test\", max_wait: int = 180, poll_interval: int = 15\n) -&gt; bool:\n    \"\"\"Wait for memory extraction to complete by polling.\n\n    IMPORTANT LIMITATIONS:\n    1. This method only works reliably on empty namespaces. If there are already\n       existing memories in the namespace, this method may return True immediately\n       even if new extractions haven't completed.\n    2. Wildcards (*) are NOT supported in namespaces. You must provide the exact\n       namespace path with all variables resolved (e.g., \"support/facts/session-123\"\n       not \"support/facts/*\").\n\n    For subsequent extractions in populated namespaces, use a fixed wait time:\n        time.sleep(150)  # Wait 2.5 minutes for extraction\n\n    Args:\n        memory_id: Memory resource ID\n        namespace: Exact namespace to check (no wildcards)\n        test_query: Query to test with (default: \"test\")\n        max_wait: Maximum seconds to wait (default: 180)\n        poll_interval: Seconds between checks (default: 15)\n\n    Returns:\n        True if memories found, False if timeout\n\n    Note:\n        This method will be deprecated in future versions once the API\n        provides extraction status or timestamps.\n    \"\"\"\n    if \"*\" in namespace:\n        logger.error(\"Wildcards are not supported in namespaces. Please provide exact namespace.\")\n        return False\n\n    logger.warning(\n        \"wait_for_memories() only works reliably on empty namespaces. \"\n        \"For populated namespaces, consider using a fixed wait time instead.\"\n    )\n\n    logger.info(\"Waiting for memory extraction in namespace: %s\", namespace)\n    start_time = time.time()\n    service_errors = 0\n\n    while time.time() - start_time &lt; max_wait:\n        elapsed = int(time.time() - start_time)\n\n        try:\n            memories = self.retrieve_memories(memory_id=memory_id, namespace=namespace, query=test_query, top_k=1)\n\n            if memories:\n                logger.info(\"Memory extraction complete after %d seconds\", elapsed)\n                return True\n\n            # Reset service error count on successful call\n            service_errors = 0\n\n        except Exception as e:\n            if \"ServiceException\" in str(e):\n                service_errors += 1\n                if service_errors &gt;= 3:\n                    logger.warning(\"Multiple service errors - the service may be experiencing issues\")\n            logger.debug(\"Retrieval attempt failed: %s\", e)\n\n        if time.time() - start_time &lt; max_wait:\n            time.sleep(poll_interval)\n\n    logger.warning(\"No memories found after %d seconds\", max_wait)\n    if service_errors &gt; 0:\n        logger.info(\"Note: Encountered %d service errors during polling\", service_errors)\n    return False\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient","title":"<code>MemoryControlPlaneClient</code>","text":"<p>Client for Bedrock AgentCore Memory control plane operations.</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>class MemoryControlPlaneClient:\n    \"\"\"Client for Bedrock AgentCore Memory control plane operations.\"\"\"\n\n    def __init__(self, region_name: str = \"us-west-2\", environment: str = \"prod\"):\n        \"\"\"Initialize the Memory Control Plane client.\n\n        Args:\n            region_name: AWS region name\n            environment: Environment name (prod, gamma, etc.)\n        \"\"\"\n        self.region_name = region_name\n        self.environment = environment\n\n        self.endpoint = os.getenv(\n            \"BEDROCK_AGENTCORE_CONTROL_ENDPOINT\", f\"https://bedrock-agentcore-control.{region_name}.amazonaws.com\"\n        )\n\n        service_name = os.getenv(\"BEDROCK_AGENTCORE_CONTROL_SERVICE\", \"bedrock-agentcore-control\")\n        self.client = boto3.client(service_name, region_name=self.region_name, endpoint_url=self.endpoint)\n\n        logger.info(\"Initialized MemoryControlPlaneClient for %s in %s\", environment, region_name)\n\n    # ==================== MEMORY OPERATIONS ====================\n\n    def create_memory(\n        self,\n        name: str,\n        event_expiry_days: int = 90,\n        description: Optional[str] = None,\n        memory_execution_role_arn: Optional[str] = None,\n        strategies: Optional[List[Dict[str, Any]]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Create a memory resource with optional strategies.\n\n        Args:\n            name: Name for the memory resource\n            event_expiry_days: How long to retain events (default: 90 days)\n            description: Optional description\n            memory_execution_role_arn: IAM role ARN for memory execution\n            strategies: Optional list of strategy configurations\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Created memory object\n        \"\"\"\n        params = {\n            \"name\": name,\n            \"eventExpiryDuration\": event_expiry_days,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        if description:\n            params[\"description\"] = description\n\n        if memory_execution_role_arn:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        if strategies:\n            params[\"memoryStrategies\"] = strategies\n\n        try:\n            response = self.client.create_memory(**params)\n            memory = response[\"memory\"]\n            memory_id = memory[\"id\"]\n\n            logger.info(\"Created memory: %s\", memory_id)\n\n            if wait_for_active:\n                return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to create memory: %s\", e)\n            raise\n\n    def get_memory(self, memory_id: str, include_strategies: bool = True) -&gt; Dict[str, Any]:\n        \"\"\"Get a memory resource by ID.\n\n        Args:\n            memory_id: Memory resource ID\n            include_strategies: Whether to include strategy details in response\n\n        Returns:\n            Memory resource details\n        \"\"\"\n        try:\n            response = self.client.get_memory(memoryId=memory_id)\n            memory = response[\"memory\"]\n\n            # Add strategy count\n            strategies = memory.get(\"strategies\", [])\n            memory[\"strategyCount\"] = len(strategies)\n\n            # Remove strategies if not requested\n            if not include_strategies and \"strategies\" in memory:\n                del memory[\"strategies\"]\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to get memory: %s\", e)\n            raise\n\n    def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all memories for the account with pagination support.\n\n        Args:\n            max_results: Maximum number of memories to return\n\n        Returns:\n            List of memory summaries\n        \"\"\"\n        try:\n            memories = []\n            next_token = None\n\n            while len(memories) &lt; max_results:\n                params = {\"maxResults\": min(100, max_results - len(memories))}\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self.client.list_memories(**params)\n                batch = response.get(\"memories\", [])\n                memories.extend(batch)\n\n                next_token = response.get(\"nextToken\")\n                if not next_token or len(memories) &gt;= max_results:\n                    break\n\n            # Add strategy count to each memory summary\n            for memory in memories:\n                memory[\"strategyCount\"] = 0  # List memories doesn't include strategies\n\n            return memories[:max_results]\n\n        except ClientError as e:\n            logger.error(\"Failed to list memories: %s\", e)\n            raise\n\n    def update_memory(\n        self,\n        memory_id: str,\n        description: Optional[str] = None,\n        event_expiry_days: Optional[int] = None,\n        memory_execution_role_arn: Optional[str] = None,\n        add_strategies: Optional[List[Dict[str, Any]]] = None,\n        modify_strategies: Optional[List[Dict[str, Any]]] = None,\n        delete_strategy_ids: Optional[List[str]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update a memory resource properties and/or strategies.\n\n        Args:\n            memory_id: Memory resource ID\n            description: Optional new description\n            event_expiry_days: Optional new event expiry duration\n            memory_execution_role_arn: Optional new execution role ARN\n            add_strategies: Optional list of strategies to add\n            modify_strategies: Optional list of strategies to modify\n            delete_strategy_ids: Optional list of strategy IDs to delete\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        params: Dict = {\n            \"memoryId\": memory_id,\n            \"clientToken\": str(uuid.uuid4()),\n        }\n\n        # Add memory properties if provided\n        if description is not None:\n            params[\"description\"] = description\n\n        if event_expiry_days is not None:\n            params[\"eventExpiryDuration\"] = event_expiry_days\n\n        if memory_execution_role_arn is not None:\n            params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n        # Add strategy operations if provided\n        memory_strategies = {}\n\n        if add_strategies:\n            memory_strategies[\"addMemoryStrategies\"] = add_strategies\n\n        if modify_strategies:\n            memory_strategies[\"modifyMemoryStrategies\"] = modify_strategies\n\n        if delete_strategy_ids:\n            memory_strategies[\"deleteMemoryStrategies\"] = [\n                {\"memoryStrategyId\": strategy_id} for strategy_id in delete_strategy_ids\n            ]\n\n        if memory_strategies:\n            params[\"memoryStrategies\"] = memory_strategies\n\n        try:\n            response = self.client.update_memory(**params)\n            memory = response[\"memory\"]\n            logger.info(\"Updated memory: %s\", memory_id)\n\n            if wait_for_active:\n                return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n            return memory\n\n        except ClientError as e:\n            logger.error(\"Failed to update memory: %s\", e)\n            raise\n\n    def delete_memory(\n        self,\n        memory_id: str,\n        wait_for_deletion: bool = False,\n        wait_for_strategies: bool = False,  # Changed default to False\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Delete a memory resource.\n\n        Args:\n            memory_id: Memory resource ID to delete\n            wait_for_deletion: Whether to wait for complete deletion\n            wait_for_strategies: Whether to wait for strategies to become ACTIVE before deletion\n            max_wait: Maximum seconds to wait if wait_for_deletion is True\n            poll_interval: Seconds between checks if wait_for_deletion is True\n\n        Returns:\n            Deletion response\n        \"\"\"\n        try:\n            # If requested, wait for all strategies to become ACTIVE before deletion\n            if wait_for_strategies:\n                try:\n                    memory = self.get_memory(memory_id)\n                    strategies = memory.get(\"strategies\", [])\n\n                    # Check if any strategies are in a transitional state\n                    transitional_strategies = [\n                        s\n                        for s in strategies\n                        if s.get(\"status\") not in [MemoryStatus.ACTIVE.value, MemoryStatus.FAILED.value]\n                    ]\n\n                    if transitional_strategies:\n                        logger.info(\n                            \"Waiting for %d strategies to become ACTIVE before deletion\", len(transitional_strategies)\n                        )\n                        self._wait_for_status(\n                            memory_id=memory_id,\n                            target_status=MemoryStatus.ACTIVE.value,\n                            max_wait=max_wait,\n                            poll_interval=poll_interval,\n                            check_strategies=True,\n                        )\n                except Exception as e:\n                    logger.warning(\"Error waiting for strategies to become ACTIVE: %s\", e)\n\n            # Now delete the memory\n            response = self.client.delete_memory(memoryId=memory_id, clientToken=str(uuid.uuid4()))\n\n            logger.info(\"Initiated deletion of memory: %s\", memory_id)\n\n            if not wait_for_deletion:\n                return response\n\n            # Wait for deletion to complete\n            start_time = time.time()\n            while time.time() - start_time &lt; max_wait:\n                try:\n                    self.client.get_memory(memoryId=memory_id)\n                    time.sleep(poll_interval)\n                except ClientError as e:\n                    if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                        logger.info(\"Memory %s successfully deleted\", memory_id)\n                        return response\n                    raise\n\n            raise TimeoutError(f\"Memory {memory_id} was not deleted within {max_wait} seconds\")\n\n        except ClientError as e:\n            logger.error(\"Failed to delete memory: %s\", e)\n            raise\n\n    # ==================== STRATEGY OPERATIONS ====================\n\n    def add_strategy(\n        self,\n        memory_id: str,\n        strategy: Dict[str, Any],\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add a strategy to a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy: Strategy configuration dictionary\n            wait_for_active: Whether to wait for strategy to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object with strategyId field\n        \"\"\"\n        # Get the strategy type and name for identification\n        strategy_type = list(strategy.keys())[0]  # e.g., 'semanticMemoryStrategy'\n        strategy_name = strategy[strategy_type].get(\"name\")\n\n        logger.info(\"Adding strategy %s of type %s to memory %s\", strategy_name, strategy_type, memory_id)\n\n        # Use update_memory with add_strategies parameter but don't wait for memory\n        memory = self.update_memory(\n            memory_id=memory_id,\n            add_strategies=[strategy],\n            wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n        )\n\n        # If we need to wait for the strategy to become active\n        if wait_for_active:\n            # First, get the memory again to ensure we have the latest state\n            memory = self.get_memory(memory_id)\n\n            # Find the newly added strategy by matching name\n            strategies = memory.get(\"strategies\", [])\n            strategy_id = None\n\n            for s in strategies:\n                # Match by name since that's unique within a memory\n                if s.get(\"name\") == strategy_name:\n                    strategy_id = s.get(\"strategyId\")\n                    logger.info(\"Found newly added strategy %s with ID %s\", strategy_name, strategy_id)\n                    break\n\n            if strategy_id:\n                return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n            else:\n                logger.warning(\"Could not identify newly added strategy %s to wait for activation\", strategy_name)\n\n        return memory\n\n    def get_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Get a specific strategy from a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID\n\n        Returns:\n            Strategy details\n        \"\"\"\n        try:\n            memory = self.get_memory(memory_id)\n            strategies = memory.get(\"strategies\", [])\n\n            for strategy in strategies:\n                if strategy.get(\"strategyId\") == strategy_id:\n                    return strategy\n\n            raise ValueError(f\"Strategy {strategy_id} not found in memory {memory_id}\")\n\n        except ClientError as e:\n            logger.error(\"Failed to get strategy: %s\", e)\n            raise\n\n    def update_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        description: Optional[str] = None,\n        namespaces: Optional[List[str]] = None,\n        configuration: Optional[Dict[str, Any]] = None,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Update a strategy in a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID to update\n            description: Optional new description\n            namespaces: Optional new namespaces list\n            configuration: Optional new configuration\n            wait_for_active: Whether to wait for strategy to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        # Note: API expects memoryStrategyId for input but returns strategyId in response\n        modify_config: Dict = {\"memoryStrategyId\": strategy_id}\n\n        if description is not None:\n            modify_config[\"description\"] = description\n\n        if namespaces is not None:\n            modify_config[\"namespaces\"] = namespaces\n\n        if configuration is not None:\n            modify_config[\"configuration\"] = configuration\n\n        # Use update_memory with modify_strategies parameter but don't wait for memory\n        memory = self.update_memory(\n            memory_id=memory_id,\n            modify_strategies=[modify_config],\n            wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n        )\n\n        # If we need to wait for the strategy to become active\n        if wait_for_active:\n            return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n\n        return memory\n\n    def remove_strategy(\n        self,\n        memory_id: str,\n        strategy_id: str,\n        wait_for_active: bool = False,\n        max_wait: int = 300,\n        poll_interval: int = 10,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Remove a strategy from a memory resource.\n\n        Args:\n            memory_id: Memory resource ID\n            strategy_id: Strategy ID to remove\n            wait_for_active: Whether to wait for memory to become ACTIVE\n            max_wait: Maximum seconds to wait if wait_for_active is True\n            poll_interval: Seconds between status checks if wait_for_active is True\n\n        Returns:\n            Updated memory object\n        \"\"\"\n        # For remove_strategy, we only need to wait for memory to be active\n        # since the strategy will be gone\n        return self.update_memory(\n            memory_id=memory_id,\n            delete_strategy_ids=[strategy_id],\n            wait_for_active=wait_for_active,\n            max_wait=max_wait,\n            poll_interval=poll_interval,\n        )\n\n    # ==================== HELPER METHODS ====================\n\n    def _wait_for_memory_active(self, memory_id: str, max_wait: int, poll_interval: int) -&gt; Dict[str, Any]:\n        \"\"\"Wait for memory to return to ACTIVE state.\"\"\"\n        logger.info(\"Waiting for memory %s to become ACTIVE...\", memory_id)\n        return self._wait_for_status(\n            memory_id=memory_id, target_status=MemoryStatus.ACTIVE.value, max_wait=max_wait, poll_interval=poll_interval\n        )\n\n    def _wait_for_strategy_active(\n        self, memory_id: str, strategy_id: str, max_wait: int, poll_interval: int\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Wait for specific memory strategy to become ACTIVE.\"\"\"\n        logger.info(\"Waiting for strategy %s to become ACTIVE (max wait: %d seconds)...\", strategy_id, max_wait)\n\n        start_time = time.time()\n        last_status = None\n\n        while time.time() - start_time &lt; max_wait:\n            try:\n                memory = self.get_memory(memory_id)\n                strategies = memory.get(\"strategies\", [])\n\n                for strategy in strategies:\n                    if strategy.get(\"strategyId\") == strategy_id:\n                        status = strategy[\"status\"]\n\n                        # Log status changes\n                        if status != last_status:\n                            logger.info(\"Strategy %s status: %s\", strategy_id, status)\n                            last_status = status\n\n                        if status == MemoryStatus.ACTIVE.value:\n                            elapsed = time.time() - start_time\n                            logger.info(\"Strategy %s is now ACTIVE (took %.1f seconds)\", strategy_id, elapsed)\n                            return memory\n                        elif status == MemoryStatus.FAILED.value:\n                            failure_reason = strategy.get(\"failureReason\", \"Unknown\")\n                            raise RuntimeError(f\"Strategy {strategy_id} failed to activate: {failure_reason}\")\n\n                        break\n                else:\n                    logger.warning(\"Strategy %s not found in memory %s\", strategy_id, memory_id)\n\n                # Wait before checking again\n                time.sleep(poll_interval)\n\n            except ClientError as e:\n                logger.error(\"Error checking strategy status: %s\", e)\n                raise\n\n        elapsed = time.time() - start_time\n        raise TimeoutError(\n            f\"Strategy {strategy_id} did not become ACTIVE within {max_wait} seconds (last status: {last_status})\"\n        )\n\n    def _wait_for_status(\n        self, memory_id: str, target_status: str, max_wait: int, poll_interval: int, check_strategies: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Generic method to wait for a memory to reach a specific status.\n\n        Args:\n            memory_id: The ID of the memory to check\n            target_status: The status to wait for (e.g., \"ACTIVE\")\n            max_wait: Maximum time to wait in seconds\n            poll_interval: Time between status checks in seconds\n            check_strategies: Whether to also check that all strategies are in the target status\n\n        Returns:\n            The memory object once it reaches the target status\n\n        Raises:\n            TimeoutError: If the memory doesn't reach the target status within max_wait\n            RuntimeError: If the memory or any strategy reaches a FAILED state\n        \"\"\"\n        logger.info(\"Waiting for memory %s to reach status %s...\", memory_id, target_status)\n\n        start_time = time.time()\n        last_memory_status = None\n        strategy_statuses = {}\n\n        while time.time() - start_time &lt; max_wait:\n            try:\n                memory = self.get_memory(memory_id)\n                status = memory.get(\"status\")\n\n                # Log status changes for memory\n                if status != last_memory_status:\n                    logger.info(\"Memory %s status: %s\", memory_id, status)\n                    last_memory_status = status\n\n                if status == target_status:\n                    # Check if all strategies are also in the target status\n                    if check_strategies and target_status == MemoryStatus.ACTIVE.value:\n                        strategies = memory.get(\"strategies\", [])\n                        all_strategies_active = True\n\n                        for strategy in strategies:\n                            strategy_id = strategy.get(\"strategyId\")\n                            strategy_status = strategy.get(\"status\")\n\n                            # Log strategy status changes\n                            if (\n                                strategy_id not in strategy_statuses\n                                or strategy_statuses[strategy_id] != strategy_status\n                            ):\n                                logger.info(\"Strategy %s status: %s\", strategy_id, strategy_status)\n                                strategy_statuses[strategy_id] = strategy_status\n\n                            if strategy_status != target_status:\n                                if strategy_status == MemoryStatus.FAILED.value:\n                                    failure_reason = strategy.get(\"failureReason\", \"Unknown\")\n                                    raise RuntimeError(f\"Strategy {strategy_id} failed: {failure_reason}\")\n\n                                all_strategies_active = False\n\n                        if not all_strategies_active:\n                            logger.info(\n                                \"Memory %s is %s but %d strategies are still processing\",\n                                memory_id,\n                                target_status,\n                                len([s for s in strategies if s.get(\"status\") != target_status]),\n                            )\n                            time.sleep(poll_interval)\n                            continue\n\n                    elapsed = time.time() - start_time\n                    logger.info(\n                        \"Memory %s and all strategies are now %s (took %.1f seconds)\", memory_id, target_status, elapsed\n                    )\n                    return memory\n                elif status == MemoryStatus.FAILED.value:\n                    failure_reason = memory.get(\"failureReason\", \"Unknown\")\n                    raise RuntimeError(f\"Memory operation failed: {failure_reason}\")\n\n                time.sleep(poll_interval)\n\n            except ClientError as e:\n                logger.error(\"Error checking memory status: %s\", e)\n                raise\n\n        elapsed = time.time() - start_time\n        raise TimeoutError(\n            f\"Memory {memory_id} did not reach status {target_status} within {max_wait} seconds \"\n            f\"(elapsed: {elapsed:.1f}s)\"\n        )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.__init__","title":"<code>__init__(region_name='us-west-2', environment='prod')</code>","text":"<p>Initialize the Memory Control Plane client.</p> <p>Parameters:</p> Name Type Description Default <code>region_name</code> <code>str</code> <p>AWS region name</p> <code>'us-west-2'</code> <code>environment</code> <code>str</code> <p>Environment name (prod, gamma, etc.)</p> <code>'prod'</code> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def __init__(self, region_name: str = \"us-west-2\", environment: str = \"prod\"):\n    \"\"\"Initialize the Memory Control Plane client.\n\n    Args:\n        region_name: AWS region name\n        environment: Environment name (prod, gamma, etc.)\n    \"\"\"\n    self.region_name = region_name\n    self.environment = environment\n\n    self.endpoint = os.getenv(\n        \"BEDROCK_AGENTCORE_CONTROL_ENDPOINT\", f\"https://bedrock-agentcore-control.{region_name}.amazonaws.com\"\n    )\n\n    service_name = os.getenv(\"BEDROCK_AGENTCORE_CONTROL_SERVICE\", \"bedrock-agentcore-control\")\n    self.client = boto3.client(service_name, region_name=self.region_name, endpoint_url=self.endpoint)\n\n    logger.info(\"Initialized MemoryControlPlaneClient for %s in %s\", environment, region_name)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.add_strategy","title":"<code>add_strategy(memory_id, strategy, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Add a strategy to a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy</code> <code>Dict[str, Any]</code> <p>Strategy configuration dictionary</p> required <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for strategy to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object with strategyId field</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def add_strategy(\n    self,\n    memory_id: str,\n    strategy: Dict[str, Any],\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add a strategy to a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy: Strategy configuration dictionary\n        wait_for_active: Whether to wait for strategy to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object with strategyId field\n    \"\"\"\n    # Get the strategy type and name for identification\n    strategy_type = list(strategy.keys())[0]  # e.g., 'semanticMemoryStrategy'\n    strategy_name = strategy[strategy_type].get(\"name\")\n\n    logger.info(\"Adding strategy %s of type %s to memory %s\", strategy_name, strategy_type, memory_id)\n\n    # Use update_memory with add_strategies parameter but don't wait for memory\n    memory = self.update_memory(\n        memory_id=memory_id,\n        add_strategies=[strategy],\n        wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n    )\n\n    # If we need to wait for the strategy to become active\n    if wait_for_active:\n        # First, get the memory again to ensure we have the latest state\n        memory = self.get_memory(memory_id)\n\n        # Find the newly added strategy by matching name\n        strategies = memory.get(\"strategies\", [])\n        strategy_id = None\n\n        for s in strategies:\n            # Match by name since that's unique within a memory\n            if s.get(\"name\") == strategy_name:\n                strategy_id = s.get(\"strategyId\")\n                logger.info(\"Found newly added strategy %s with ID %s\", strategy_name, strategy_id)\n                break\n\n        if strategy_id:\n            return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n        else:\n            logger.warning(\"Could not identify newly added strategy %s to wait for activation\", strategy_name)\n\n    return memory\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.create_memory","title":"<code>create_memory(name, event_expiry_days=90, description=None, memory_execution_role_arn=None, strategies=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Create a memory resource with optional strategies.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the memory resource</p> required <code>event_expiry_days</code> <code>int</code> <p>How long to retain events (default: 90 days)</p> <code>90</code> <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>IAM role ARN for memory execution</p> <code>None</code> <code>strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategy configurations</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Created memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def create_memory(\n    self,\n    name: str,\n    event_expiry_days: int = 90,\n    description: Optional[str] = None,\n    memory_execution_role_arn: Optional[str] = None,\n    strategies: Optional[List[Dict[str, Any]]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Create a memory resource with optional strategies.\n\n    Args:\n        name: Name for the memory resource\n        event_expiry_days: How long to retain events (default: 90 days)\n        description: Optional description\n        memory_execution_role_arn: IAM role ARN for memory execution\n        strategies: Optional list of strategy configurations\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Created memory object\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"eventExpiryDuration\": event_expiry_days,\n        \"clientToken\": str(uuid.uuid4()),\n    }\n\n    if description:\n        params[\"description\"] = description\n\n    if memory_execution_role_arn:\n        params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n    if strategies:\n        params[\"memoryStrategies\"] = strategies\n\n    try:\n        response = self.client.create_memory(**params)\n        memory = response[\"memory\"]\n        memory_id = memory[\"id\"]\n\n        logger.info(\"Created memory: %s\", memory_id)\n\n        if wait_for_active:\n            return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to create memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.delete_memory","title":"<code>delete_memory(memory_id, wait_for_deletion=False, wait_for_strategies=False, max_wait=300, poll_interval=10)</code>","text":"<p>Delete a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID to delete</p> required <code>wait_for_deletion</code> <code>bool</code> <p>Whether to wait for complete deletion</p> <code>False</code> <code>wait_for_strategies</code> <code>bool</code> <p>Whether to wait for strategies to become ACTIVE before deletion</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_deletion is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between checks if wait_for_deletion is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Deletion response</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def delete_memory(\n    self,\n    memory_id: str,\n    wait_for_deletion: bool = False,\n    wait_for_strategies: bool = False,  # Changed default to False\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Delete a memory resource.\n\n    Args:\n        memory_id: Memory resource ID to delete\n        wait_for_deletion: Whether to wait for complete deletion\n        wait_for_strategies: Whether to wait for strategies to become ACTIVE before deletion\n        max_wait: Maximum seconds to wait if wait_for_deletion is True\n        poll_interval: Seconds between checks if wait_for_deletion is True\n\n    Returns:\n        Deletion response\n    \"\"\"\n    try:\n        # If requested, wait for all strategies to become ACTIVE before deletion\n        if wait_for_strategies:\n            try:\n                memory = self.get_memory(memory_id)\n                strategies = memory.get(\"strategies\", [])\n\n                # Check if any strategies are in a transitional state\n                transitional_strategies = [\n                    s\n                    for s in strategies\n                    if s.get(\"status\") not in [MemoryStatus.ACTIVE.value, MemoryStatus.FAILED.value]\n                ]\n\n                if transitional_strategies:\n                    logger.info(\n                        \"Waiting for %d strategies to become ACTIVE before deletion\", len(transitional_strategies)\n                    )\n                    self._wait_for_status(\n                        memory_id=memory_id,\n                        target_status=MemoryStatus.ACTIVE.value,\n                        max_wait=max_wait,\n                        poll_interval=poll_interval,\n                        check_strategies=True,\n                    )\n            except Exception as e:\n                logger.warning(\"Error waiting for strategies to become ACTIVE: %s\", e)\n\n        # Now delete the memory\n        response = self.client.delete_memory(memoryId=memory_id, clientToken=str(uuid.uuid4()))\n\n        logger.info(\"Initiated deletion of memory: %s\", memory_id)\n\n        if not wait_for_deletion:\n            return response\n\n        # Wait for deletion to complete\n        start_time = time.time()\n        while time.time() - start_time &lt; max_wait:\n            try:\n                self.client.get_memory(memoryId=memory_id)\n                time.sleep(poll_interval)\n            except ClientError as e:\n                if e.response[\"Error\"][\"Code\"] == \"ResourceNotFoundException\":\n                    logger.info(\"Memory %s successfully deleted\", memory_id)\n                    return response\n                raise\n\n        raise TimeoutError(f\"Memory {memory_id} was not deleted within {max_wait} seconds\")\n\n    except ClientError as e:\n        logger.error(\"Failed to delete memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.get_memory","title":"<code>get_memory(memory_id, include_strategies=True)</code>","text":"<p>Get a memory resource by ID.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>include_strategies</code> <code>bool</code> <p>Whether to include strategy details in response</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Memory resource details</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def get_memory(self, memory_id: str, include_strategies: bool = True) -&gt; Dict[str, Any]:\n    \"\"\"Get a memory resource by ID.\n\n    Args:\n        memory_id: Memory resource ID\n        include_strategies: Whether to include strategy details in response\n\n    Returns:\n        Memory resource details\n    \"\"\"\n    try:\n        response = self.client.get_memory(memoryId=memory_id)\n        memory = response[\"memory\"]\n\n        # Add strategy count\n        strategies = memory.get(\"strategies\", [])\n        memory[\"strategyCount\"] = len(strategies)\n\n        # Remove strategies if not requested\n        if not include_strategies and \"strategies\" in memory:\n            del memory[\"strategies\"]\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to get memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.get_strategy","title":"<code>get_strategy(memory_id, strategy_id)</code>","text":"<p>Get a specific strategy from a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Strategy details</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def get_strategy(self, memory_id: str, strategy_id: str) -&gt; Dict[str, Any]:\n    \"\"\"Get a specific strategy from a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID\n\n    Returns:\n        Strategy details\n    \"\"\"\n    try:\n        memory = self.get_memory(memory_id)\n        strategies = memory.get(\"strategies\", [])\n\n        for strategy in strategies:\n            if strategy.get(\"strategyId\") == strategy_id:\n                return strategy\n\n        raise ValueError(f\"Strategy {strategy_id} not found in memory {memory_id}\")\n\n    except ClientError as e:\n        logger.error(\"Failed to get strategy: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.list_memories","title":"<code>list_memories(max_results=100)</code>","text":"<p>List all memories for the account with pagination support.</p> <p>Parameters:</p> Name Type Description Default <code>max_results</code> <code>int</code> <p>Maximum number of memories to return</p> <code>100</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of memory summaries</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def list_memories(self, max_results: int = 100) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all memories for the account with pagination support.\n\n    Args:\n        max_results: Maximum number of memories to return\n\n    Returns:\n        List of memory summaries\n    \"\"\"\n    try:\n        memories = []\n        next_token = None\n\n        while len(memories) &lt; max_results:\n            params = {\"maxResults\": min(100, max_results - len(memories))}\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self.client.list_memories(**params)\n            batch = response.get(\"memories\", [])\n            memories.extend(batch)\n\n            next_token = response.get(\"nextToken\")\n            if not next_token or len(memories) &gt;= max_results:\n                break\n\n        # Add strategy count to each memory summary\n        for memory in memories:\n            memory[\"strategyCount\"] = 0  # List memories doesn't include strategies\n\n        return memories[:max_results]\n\n    except ClientError as e:\n        logger.error(\"Failed to list memories: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.remove_strategy","title":"<code>remove_strategy(memory_id, strategy_id, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Remove a strategy from a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID to remove</p> required <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def remove_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Remove a strategy from a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID to remove\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    # For remove_strategy, we only need to wait for memory to be active\n    # since the strategy will be gone\n    return self.update_memory(\n        memory_id=memory_id,\n        delete_strategy_ids=[strategy_id],\n        wait_for_active=wait_for_active,\n        max_wait=max_wait,\n        poll_interval=poll_interval,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.update_memory","title":"<code>update_memory(memory_id, description=None, event_expiry_days=None, memory_execution_role_arn=None, add_strategies=None, modify_strategies=None, delete_strategy_ids=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Update a memory resource properties and/or strategies.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>description</code> <code>Optional[str]</code> <p>Optional new description</p> <code>None</code> <code>event_expiry_days</code> <code>Optional[int]</code> <p>Optional new event expiry duration</p> <code>None</code> <code>memory_execution_role_arn</code> <code>Optional[str]</code> <p>Optional new execution role ARN</p> <code>None</code> <code>add_strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategies to add</p> <code>None</code> <code>modify_strategies</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional list of strategies to modify</p> <code>None</code> <code>delete_strategy_ids</code> <code>Optional[List[str]]</code> <p>Optional list of strategy IDs to delete</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for memory to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def update_memory(\n    self,\n    memory_id: str,\n    description: Optional[str] = None,\n    event_expiry_days: Optional[int] = None,\n    memory_execution_role_arn: Optional[str] = None,\n    add_strategies: Optional[List[Dict[str, Any]]] = None,\n    modify_strategies: Optional[List[Dict[str, Any]]] = None,\n    delete_strategy_ids: Optional[List[str]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update a memory resource properties and/or strategies.\n\n    Args:\n        memory_id: Memory resource ID\n        description: Optional new description\n        event_expiry_days: Optional new event expiry duration\n        memory_execution_role_arn: Optional new execution role ARN\n        add_strategies: Optional list of strategies to add\n        modify_strategies: Optional list of strategies to modify\n        delete_strategy_ids: Optional list of strategy IDs to delete\n        wait_for_active: Whether to wait for memory to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    params: Dict = {\n        \"memoryId\": memory_id,\n        \"clientToken\": str(uuid.uuid4()),\n    }\n\n    # Add memory properties if provided\n    if description is not None:\n        params[\"description\"] = description\n\n    if event_expiry_days is not None:\n        params[\"eventExpiryDuration\"] = event_expiry_days\n\n    if memory_execution_role_arn is not None:\n        params[\"memoryExecutionRoleArn\"] = memory_execution_role_arn\n\n    # Add strategy operations if provided\n    memory_strategies = {}\n\n    if add_strategies:\n        memory_strategies[\"addMemoryStrategies\"] = add_strategies\n\n    if modify_strategies:\n        memory_strategies[\"modifyMemoryStrategies\"] = modify_strategies\n\n    if delete_strategy_ids:\n        memory_strategies[\"deleteMemoryStrategies\"] = [\n            {\"memoryStrategyId\": strategy_id} for strategy_id in delete_strategy_ids\n        ]\n\n    if memory_strategies:\n        params[\"memoryStrategies\"] = memory_strategies\n\n    try:\n        response = self.client.update_memory(**params)\n        memory = response[\"memory\"]\n        logger.info(\"Updated memory: %s\", memory_id)\n\n        if wait_for_active:\n            return self._wait_for_memory_active(memory_id, max_wait, poll_interval)\n\n        return memory\n\n    except ClientError as e:\n        logger.error(\"Failed to update memory: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemoryControlPlaneClient.update_strategy","title":"<code>update_strategy(memory_id, strategy_id, description=None, namespaces=None, configuration=None, wait_for_active=False, max_wait=300, poll_interval=10)</code>","text":"<p>Update a strategy in a memory resource.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory resource ID</p> required <code>strategy_id</code> <code>str</code> <p>Strategy ID to update</p> required <code>description</code> <code>Optional[str]</code> <p>Optional new description</p> <code>None</code> <code>namespaces</code> <code>Optional[List[str]]</code> <p>Optional new namespaces list</p> <code>None</code> <code>configuration</code> <code>Optional[Dict[str, Any]]</code> <p>Optional new configuration</p> <code>None</code> <code>wait_for_active</code> <code>bool</code> <p>Whether to wait for strategy to become ACTIVE</p> <code>False</code> <code>max_wait</code> <code>int</code> <p>Maximum seconds to wait if wait_for_active is True</p> <code>300</code> <code>poll_interval</code> <code>int</code> <p>Seconds between status checks if wait_for_active is True</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Updated memory object</p> Source code in <code>bedrock_agentcore/memory/controlplane.py</code> <pre><code>def update_strategy(\n    self,\n    memory_id: str,\n    strategy_id: str,\n    description: Optional[str] = None,\n    namespaces: Optional[List[str]] = None,\n    configuration: Optional[Dict[str, Any]] = None,\n    wait_for_active: bool = False,\n    max_wait: int = 300,\n    poll_interval: int = 10,\n) -&gt; Dict[str, Any]:\n    \"\"\"Update a strategy in a memory resource.\n\n    Args:\n        memory_id: Memory resource ID\n        strategy_id: Strategy ID to update\n        description: Optional new description\n        namespaces: Optional new namespaces list\n        configuration: Optional new configuration\n        wait_for_active: Whether to wait for strategy to become ACTIVE\n        max_wait: Maximum seconds to wait if wait_for_active is True\n        poll_interval: Seconds between status checks if wait_for_active is True\n\n    Returns:\n        Updated memory object\n    \"\"\"\n    # Note: API expects memoryStrategyId for input but returns strategyId in response\n    modify_config: Dict = {\"memoryStrategyId\": strategy_id}\n\n    if description is not None:\n        modify_config[\"description\"] = description\n\n    if namespaces is not None:\n        modify_config[\"namespaces\"] = namespaces\n\n    if configuration is not None:\n        modify_config[\"configuration\"] = configuration\n\n    # Use update_memory with modify_strategies parameter but don't wait for memory\n    memory = self.update_memory(\n        memory_id=memory_id,\n        modify_strategies=[modify_config],\n        wait_for_active=False,  # Don't wait for memory, we'll check strategy specifically\n    )\n\n    # If we need to wait for the strategy to become active\n    if wait_for_active:\n        return self._wait_for_strategy_active(memory_id, strategy_id, max_wait, poll_interval)\n\n    return memory\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession","title":"<code>MemorySession</code>","text":"<p>               Bases: <code>DictWrapper</code></p> <p>Represents a single, AgentCore MemorySession resource.</p> <p>This class provides convenient delegation to MemorySessionManager operations.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>class MemorySession(DictWrapper):\n    \"\"\"Represents a single, AgentCore MemorySession resource.\n\n    This class provides convenient delegation to MemorySessionManager operations.\n    \"\"\"\n\n    def __init__(self, memory_id: str, actor_id: str, session_id: str, manager: MemorySessionManager):\n        \"\"\"Initialize a MemorySession instance.\n\n        Args:\n            memory_id: The memory identifier for this session.\n            actor_id: The actor identifier for this session.\n            session_id: The session identifier.\n            manager: The MemorySessionManager instance to delegate operations to.\n        \"\"\"\n        self._memory_id = memory_id\n        self._actor_id = actor_id\n        self._session_id = session_id\n        self._manager = manager\n        super().__init__(self._construct_session_dict())\n\n    def _construct_session_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Constructs a dictionary representing the session.\"\"\"\n        return {\"memoryId\": self._memory_id, \"actorId\": self._actor_id, \"sessionId\": self._session_id}\n\n    def add_turns(\n        self,\n        messages: List[Union[ConversationalMessage, BlobMessage]],\n        branch: Optional[Dict[str, str]] = None,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Event:\n        \"\"\"Delegates to manager.add_turns.\"\"\"\n        return self._manager.add_turns(self._actor_id, self._session_id, messages, branch, event_timestamp)\n\n    def fork_conversation(\n        self,\n        messages: List[Union[ConversationalMessage, BlobMessage]],\n        root_event_id: str,\n        branch_name: str,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Event:\n        \"\"\"Delegates to manager.fork_conversation.\"\"\"\n        return self._manager.fork_conversation(\n            self._actor_id, self._session_id, root_event_id, branch_name, messages, event_timestamp\n        )\n\n    def process_turn_with_llm(\n        self,\n        user_input: str,\n        llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n        retrieval_config: Optional[Dict[str, RetrievalConfig]],\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n        \"\"\"Delegates to manager.process_turn_with_llm.\"\"\"\n        return self._manager.process_turn_with_llm(\n            self._actor_id,\n            self._session_id,\n            user_input,\n            llm_callback,\n            retrieval_config,\n            event_timestamp,\n        )\n\n    def get_last_k_turns(\n        self,\n        k: int = 5,\n        branch_name: Optional[str] = None,\n        include_parent_branches: Optional[bool] = None,\n        max_results: int = 100,\n    ) -&gt; List[List[EventMessage]]:\n        \"\"\"Delegates to manager.get_last_k_turns.\"\"\"\n        return self._manager.get_last_k_turns(\n            self._actor_id, self._session_id, k, branch_name, include_parent_branches, max_results\n        )\n\n    def get_event(self, event_id: str) -&gt; Event:\n        \"\"\"Delegates to manager.get_event.\"\"\"\n        return self._manager.get_event(self._actor_id, self._session_id, event_id)\n\n    def delete_event(self, event_id: str):\n        \"\"\"Delegates to manager.delete_event.\"\"\"\n        return self._manager.delete_event(self._actor_id, self._session_id, event_id)\n\n    def get_memory_record(self, record_id: str) -&gt; MemoryRecord:\n        \"\"\"Delegates to manager.get_memory_record.\"\"\"\n        return self._manager.get_memory_record(record_id)\n\n    def delete_memory_record(self, record_id: str):\n        \"\"\"Delegates to manager.delete_memory_record.\"\"\"\n        return self._manager.delete_memory_record(record_id)\n\n    def search_long_term_memories(\n        self,\n        query: str,\n        namespace_prefix: str,\n        top_k: int = 3,\n        strategy_id: Optional[str] = None,\n        max_results: int = 20,\n    ) -&gt; List[MemoryRecord]:\n        \"\"\"Delegates to manager.search_long_term_memories.\"\"\"\n        return self._manager.search_long_term_memories(query, namespace_prefix, top_k, strategy_id, max_results)\n\n    def list_long_term_memory_records(\n        self, namespace_prefix: str, strategy_id: Optional[str] = None, max_results: int = 10\n    ) -&gt; List[MemoryRecord]:\n        \"\"\"Delegates to manager.list_long_term_memory_records.\"\"\"\n        return self._manager.list_long_term_memory_records(namespace_prefix, strategy_id, max_results)\n\n    def list_actors(self) -&gt; List[ActorSummary]:\n        \"\"\"Delegates to manager.list_actors.\"\"\"\n        return self._manager.list_actors()\n\n    def list_events(\n        self,\n        branch_name: Optional[str] = None,\n        include_parent_branches: bool = False,\n        max_results: int = 100,\n        include_payload: bool = True,\n    ) -&gt; List[Event]:\n        \"\"\"Delegates to manager.list_events.\"\"\"\n        return self._manager.list_events(\n            actor_id=self._actor_id,\n            session_id=self._session_id,\n            branch_name=branch_name,\n            include_parent_branches=include_parent_branches,\n            include_payload=include_payload,\n            max_results=max_results,\n        )\n\n    def list_branches(self) -&gt; List[Branch]:\n        \"\"\"Delegates to manager.list_branches.\"\"\"\n        return self._manager.list_branches(self._actor_id, self._session_id)\n\n    def get_actor(self) -&gt; \"Actor\":\n        \"\"\"Returns an Actor instance for this conversation's actor.\"\"\"\n        return Actor(self._actor_id, self._manager)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.__init__","title":"<code>__init__(memory_id, actor_id, session_id, manager)</code>","text":"<p>Initialize a MemorySession instance.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>The memory identifier for this session.</p> required <code>actor_id</code> <code>str</code> <p>The actor identifier for this session.</p> required <code>session_id</code> <code>str</code> <p>The session identifier.</p> required <code>manager</code> <code>MemorySessionManager</code> <p>The MemorySessionManager instance to delegate operations to.</p> required Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def __init__(self, memory_id: str, actor_id: str, session_id: str, manager: MemorySessionManager):\n    \"\"\"Initialize a MemorySession instance.\n\n    Args:\n        memory_id: The memory identifier for this session.\n        actor_id: The actor identifier for this session.\n        session_id: The session identifier.\n        manager: The MemorySessionManager instance to delegate operations to.\n    \"\"\"\n    self._memory_id = memory_id\n    self._actor_id = actor_id\n    self._session_id = session_id\n    self._manager = manager\n    super().__init__(self._construct_session_dict())\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.add_turns","title":"<code>add_turns(messages, branch=None, event_timestamp=None)</code>","text":"<p>Delegates to manager.add_turns.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def add_turns(\n    self,\n    messages: List[Union[ConversationalMessage, BlobMessage]],\n    branch: Optional[Dict[str, str]] = None,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Event:\n    \"\"\"Delegates to manager.add_turns.\"\"\"\n    return self._manager.add_turns(self._actor_id, self._session_id, messages, branch, event_timestamp)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.delete_event","title":"<code>delete_event(event_id)</code>","text":"<p>Delegates to manager.delete_event.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def delete_event(self, event_id: str):\n    \"\"\"Delegates to manager.delete_event.\"\"\"\n    return self._manager.delete_event(self._actor_id, self._session_id, event_id)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.delete_memory_record","title":"<code>delete_memory_record(record_id)</code>","text":"<p>Delegates to manager.delete_memory_record.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def delete_memory_record(self, record_id: str):\n    \"\"\"Delegates to manager.delete_memory_record.\"\"\"\n    return self._manager.delete_memory_record(record_id)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.fork_conversation","title":"<code>fork_conversation(messages, root_event_id, branch_name, event_timestamp=None)</code>","text":"<p>Delegates to manager.fork_conversation.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def fork_conversation(\n    self,\n    messages: List[Union[ConversationalMessage, BlobMessage]],\n    root_event_id: str,\n    branch_name: str,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Event:\n    \"\"\"Delegates to manager.fork_conversation.\"\"\"\n    return self._manager.fork_conversation(\n        self._actor_id, self._session_id, root_event_id, branch_name, messages, event_timestamp\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.get_actor","title":"<code>get_actor()</code>","text":"<p>Returns an Actor instance for this conversation's actor.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def get_actor(self) -&gt; \"Actor\":\n    \"\"\"Returns an Actor instance for this conversation's actor.\"\"\"\n    return Actor(self._actor_id, self._manager)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.get_event","title":"<code>get_event(event_id)</code>","text":"<p>Delegates to manager.get_event.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def get_event(self, event_id: str) -&gt; Event:\n    \"\"\"Delegates to manager.get_event.\"\"\"\n    return self._manager.get_event(self._actor_id, self._session_id, event_id)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.get_last_k_turns","title":"<code>get_last_k_turns(k=5, branch_name=None, include_parent_branches=None, max_results=100)</code>","text":"<p>Delegates to manager.get_last_k_turns.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def get_last_k_turns(\n    self,\n    k: int = 5,\n    branch_name: Optional[str] = None,\n    include_parent_branches: Optional[bool] = None,\n    max_results: int = 100,\n) -&gt; List[List[EventMessage]]:\n    \"\"\"Delegates to manager.get_last_k_turns.\"\"\"\n    return self._manager.get_last_k_turns(\n        self._actor_id, self._session_id, k, branch_name, include_parent_branches, max_results\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.get_memory_record","title":"<code>get_memory_record(record_id)</code>","text":"<p>Delegates to manager.get_memory_record.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def get_memory_record(self, record_id: str) -&gt; MemoryRecord:\n    \"\"\"Delegates to manager.get_memory_record.\"\"\"\n    return self._manager.get_memory_record(record_id)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.list_actors","title":"<code>list_actors()</code>","text":"<p>Delegates to manager.list_actors.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_actors(self) -&gt; List[ActorSummary]:\n    \"\"\"Delegates to manager.list_actors.\"\"\"\n    return self._manager.list_actors()\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.list_branches","title":"<code>list_branches()</code>","text":"<p>Delegates to manager.list_branches.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_branches(self) -&gt; List[Branch]:\n    \"\"\"Delegates to manager.list_branches.\"\"\"\n    return self._manager.list_branches(self._actor_id, self._session_id)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.list_events","title":"<code>list_events(branch_name=None, include_parent_branches=False, max_results=100, include_payload=True)</code>","text":"<p>Delegates to manager.list_events.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_events(\n    self,\n    branch_name: Optional[str] = None,\n    include_parent_branches: bool = False,\n    max_results: int = 100,\n    include_payload: bool = True,\n) -&gt; List[Event]:\n    \"\"\"Delegates to manager.list_events.\"\"\"\n    return self._manager.list_events(\n        actor_id=self._actor_id,\n        session_id=self._session_id,\n        branch_name=branch_name,\n        include_parent_branches=include_parent_branches,\n        include_payload=include_payload,\n        max_results=max_results,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.list_long_term_memory_records","title":"<code>list_long_term_memory_records(namespace_prefix, strategy_id=None, max_results=10)</code>","text":"<p>Delegates to manager.list_long_term_memory_records.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_long_term_memory_records(\n    self, namespace_prefix: str, strategy_id: Optional[str] = None, max_results: int = 10\n) -&gt; List[MemoryRecord]:\n    \"\"\"Delegates to manager.list_long_term_memory_records.\"\"\"\n    return self._manager.list_long_term_memory_records(namespace_prefix, strategy_id, max_results)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.process_turn_with_llm","title":"<code>process_turn_with_llm(user_input, llm_callback, retrieval_config, event_timestamp=None)</code>","text":"<p>Delegates to manager.process_turn_with_llm.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def process_turn_with_llm(\n    self,\n    user_input: str,\n    llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n    retrieval_config: Optional[Dict[str, RetrievalConfig]],\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n    \"\"\"Delegates to manager.process_turn_with_llm.\"\"\"\n    return self._manager.process_turn_with_llm(\n        self._actor_id,\n        self._session_id,\n        user_input,\n        llm_callback,\n        retrieval_config,\n        event_timestamp,\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySession.search_long_term_memories","title":"<code>search_long_term_memories(query, namespace_prefix, top_k=3, strategy_id=None, max_results=20)</code>","text":"<p>Delegates to manager.search_long_term_memories.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def search_long_term_memories(\n    self,\n    query: str,\n    namespace_prefix: str,\n    top_k: int = 3,\n    strategy_id: Optional[str] = None,\n    max_results: int = 20,\n) -&gt; List[MemoryRecord]:\n    \"\"\"Delegates to manager.search_long_term_memories.\"\"\"\n    return self._manager.search_long_term_memories(query, namespace_prefix, top_k, strategy_id, max_results)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager","title":"<code>MemorySessionManager</code>","text":"<p>Manages conversational sessions and memory operations for AWS Bedrock AgentCore.</p> <p>The MemorySessionManager provides a high-level interface for managing conversational AI sessions, handling both short-term (conversational events) and long-term (semantic memory) storage. It serves as the primary entry point for data plane operations with AWS Bedrock AgentCore Memory services.</p> Key Capabilities <ul> <li>Conversation Management: Store, retrieve, and organize conversational turns</li> <li>Memory Operations: Search and manage long-term semantic memory records</li> <li>Branch Support: Create and manage conversation branches for alternative flows</li> <li>LLM Integration: Built-in callback pattern for LLM processing with memory context</li> <li>Actor &amp; Session Tracking: Multi-user, multi-session conversation management</li> </ul> Usage Patterns <ol> <li>Simple Conversation: Store user/assistant message pairs</li> <li>Memory-Enhanced Chat: Retrieve relevant context before LLM processing</li> <li>Branched Conversations: Fork conversations for alternative responses</li> <li>Multi-Modal: Handle both text and binary data (images, files, etc.)</li> </ol> Example <pre><code># Initialize manager\nmanager = MemorySessionManager(memory_id=\"my-memory-123\", region_name=\"us-east-1\")\n\n# Store a conversation turn\nmanager.add_turns(\n    actor_id=\"user-456\",\n    session_id=\"session-789\",\n    messages=[\n        ConversationalMessage(\"Hello!\", MessageRole.USER),\n        ConversationalMessage(\"Hi there!\", MessageRole.ASSISTANT)\n    ]\n)\n\n# Search long-term memory and process with LLM\ndef my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n    # Your LLM processing logic here\n    return \"Response based on context\"\n\nmemories, response, event = manager.process_turn_with_llm(\n    actor_id=\"user-456\",\n    session_id=\"session-789\",\n    user_input=\"What did we discuss?\",\n    llm_callback=my_llm,\n    retrieval_namespace=\"support/facts/{sessionId}\"\n)\n</code></pre> Thread Safety <p>This class is not thread-safe. Create separate instances for concurrent operations.</p> AWS Permissions Required <ul> <li>bedrock-agentcore:CreateEvent</li> <li>bedrock-agentcore:GetEvent</li> <li>bedrock-agentcore:ListEvents</li> <li>bedrock-agentcore:DeleteEvent</li> <li>bedrock-agentcore:RetrieveMemoryRecords</li> <li>bedrock-agentcore:ListMemoryRecords</li> <li>bedrock-agentcore:GetMemoryRecord</li> <li>bedrock-agentcore:DeleteMemoryRecord</li> <li>bedrock-agentcore:ListActors</li> <li>bedrock-agentcore:ListSessions</li> </ul> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>class MemorySessionManager:\n    \"\"\"Manages conversational sessions and memory operations for AWS Bedrock AgentCore.\n\n    The MemorySessionManager provides a high-level interface for managing conversational AI sessions,\n    handling both short-term (conversational events) and long-term (semantic memory) storage.\n    It serves as the primary entry point for data plane operations with AWS Bedrock AgentCore\n    Memory services.\n\n    Key Capabilities:\n        - **Conversation Management**: Store, retrieve, and organize conversational turns\n        - **Memory Operations**: Search and manage long-term semantic memory records\n        - **Branch Support**: Create and manage conversation branches for alternative flows\n        - **LLM Integration**: Built-in callback pattern for LLM processing with memory context\n        - **Actor &amp; Session Tracking**: Multi-user, multi-session conversation management\n\n    Usage Patterns:\n        1. **Simple Conversation**: Store user/assistant message pairs\n        2. **Memory-Enhanced Chat**: Retrieve relevant context before LLM processing\n        3. **Branched Conversations**: Fork conversations for alternative responses\n        4. **Multi-Modal**: Handle both text and binary data (images, files, etc.)\n\n    Example:\n        ```python\n        # Initialize manager\n        manager = MemorySessionManager(memory_id=\"my-memory-123\", region_name=\"us-east-1\")\n\n        # Store a conversation turn\n        manager.add_turns(\n            actor_id=\"user-456\",\n            session_id=\"session-789\",\n            messages=[\n                ConversationalMessage(\"Hello!\", MessageRole.USER),\n                ConversationalMessage(\"Hi there!\", MessageRole.ASSISTANT)\n            ]\n        )\n\n        # Search long-term memory and process with LLM\n        def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n            # Your LLM processing logic here\n            return \"Response based on context\"\n\n        memories, response, event = manager.process_turn_with_llm(\n            actor_id=\"user-456\",\n            session_id=\"session-789\",\n            user_input=\"What did we discuss?\",\n            llm_callback=my_llm,\n            retrieval_namespace=\"support/facts/{sessionId}\"\n        )\n        ```\n\n    Thread Safety:\n        This class is not thread-safe. Create separate instances for concurrent operations.\n\n    AWS Permissions Required:\n        - bedrock-agentcore:CreateEvent\n        - bedrock-agentcore:GetEvent\n        - bedrock-agentcore:ListEvents\n        - bedrock-agentcore:DeleteEvent\n        - bedrock-agentcore:RetrieveMemoryRecords\n        - bedrock-agentcore:ListMemoryRecords\n        - bedrock-agentcore:GetMemoryRecord\n        - bedrock-agentcore:DeleteMemoryRecord\n        - bedrock-agentcore:ListActors\n        - bedrock-agentcore:ListSessions\n    \"\"\"\n\n    def __init__(\n        self,\n        memory_id: str,\n        region_name: Optional[str] = None,\n        boto3_session: Optional[boto3.Session] = None,\n        boto_client_config: Optional[BotocoreConfig] = None,\n    ):\n        \"\"\"Initialize a MemorySessionManager instance.\n\n        Args:\n            memory_id: The memory identifier for this session manager.\n            region_name: AWS region for the bedrock-agentcore client. If not provided,\n                   will use the region from boto3_session or default session.\n            boto3_session: Optional boto3 Session to use. If provided and region_name\n                          parameter is also specified, validation will ensure they match.\n            boto_client_config: Optional boto3 client configuration. If provided, will be\n                              merged with default configuration including user agent.\n\n        Raises:\n            ValueError: If region_name parameter conflicts with boto3_session region.\n        \"\"\"\n        # Initialize core attributes\n        self._memory_id = memory_id\n\n        # Setup session and validate region consistency\n        self.region_name = self._validate_and_resolve_region(region_name, boto3_session)\n        session = boto3_session if boto3_session else boto3.Session()\n\n        # Configure and create boto3 client\n        client_config = self._build_client_config(boto_client_config)\n        self._data_plane_client = session.client(\n            \"bedrock-agentcore\", region_name=self.region_name, config=client_config\n        )\n\n        # Configure timestamp serialization to use float representation\n        self._configure_timestamp_serialization()\n\n        # Define allowed data plane methods\n        self._ALLOWED_DATA_PLANE_METHODS = {\n            \"retrieve_memory_records\",\n            \"get_memory_record\",\n            \"delete_memory_record\",\n            \"list_memory_records\",\n            \"create_event\",\n            \"get_event\",\n            \"delete_event\",\n            \"list_events\",\n        }\n\n    def _validate_and_resolve_region(self, region_name: Optional[str], session: Optional[boto3.Session]) -&gt; str:\n        \"\"\"Validate region consistency and resolve the final region to use.\n\n        Args:\n            region_name: Explicitly provided region name\n            session: Optional Boto3 session instance\n\n        Returns:\n            The resolved region name to use\n\n        Raises:\n            ValueError: If region_name conflicts with session region\n        \"\"\"\n        session_region = session.region_name if session else None\n\n        # Validate region consistency if both are provided\n        if region_name and session and session_region and (region_name != session_region):\n            raise ValueError(\n                f\"Region mismatch: provided region_name '{region_name}' does not match \"\n                f\"boto3_session region '{session_region}'. Please ensure both \"\n                f\"parameters specify the same region or omit the region_name parameter \"\n                f\"to use the session's region.\"\n            )\n\n        return region_name or session_region\n\n    def _build_client_config(self, boto_client_config: Optional[BotocoreConfig]) -&gt; BotocoreConfig:\n        \"\"\"Build the final boto3 client configuration with SDK user agent.\n\n        Args:\n            boto_client_config: Optional user-provided client configuration\n\n        Returns:\n            Final client configuration with SDK user agent\n        \"\"\"\n        sdk_user_agent = \"bedrock-agentcore-sdk\"\n\n        if boto_client_config:\n            existing_user_agent = getattr(boto_client_config, \"user_agent_extra\", None)\n            if existing_user_agent:\n                new_user_agent = f\"{existing_user_agent} {sdk_user_agent}\"\n            else:\n                new_user_agent = sdk_user_agent\n            return boto_client_config.merge(BotocoreConfig(user_agent_extra=new_user_agent))\n        else:\n            return BotocoreConfig(user_agent_extra=sdk_user_agent)\n\n    def _configure_timestamp_serialization(self) -&gt; None:\n        \"\"\"Configure the boto3 client to serialize timestamps as float values.\n\n        This method overrides the default timestamp serialization to convert datetime objects\n        to float timestamps (seconds since Unix epoch) which preserves millisecond precision\n        when sending datetime objects to the AgentCore Memory service.\n        \"\"\"\n        original_serialize_timestamp = self._data_plane_client._serializer._serializer._serialize_type_timestamp\n\n        def serialize_timestamp_as_float(serialized, value, shape, name):\n            if isinstance(value, datetime):\n                serialized[name] = value.timestamp()  # Convert to float (seconds since epoch with fractional seconds)\n            else:\n                original_serialize_timestamp(serialized, value, shape, name)\n\n        self._data_plane_client._serializer._serializer._serialize_type_timestamp = serialize_timestamp_as_float\n\n    def __getattr__(self, name: str):\n        \"\"\"Dynamically forward method calls to the appropriate boto3 client.\n\n        This method enables access to all data_plane boto3 client methods without explicitly\n        defining them. Methods are looked up in the following order:\n        _data_plane_client (bedrock-agentcore) - for data plane operations\n\n        Args:\n            name: The method name being accessed\n\n        Returns:\n            A callable method from the boto3 client\n\n        Raises:\n            AttributeError: If the method doesn't exist on _data_plane_client\n\n        Example:\n            # Access any boto3 method directly\n            manager = MemorySessionManager(region_name=\"us-east-1\")\n\n            # These calls are forwarded to the appropriate boto3 functions\n            memory_records = manager.retrieve_memory_records()\n            events = manager.list_events(...)\n        \"\"\"\n        if name in self._ALLOWED_DATA_PLANE_METHODS and hasattr(self._data_plane_client, name):\n            method = getattr(self._data_plane_client, name)\n            logger.debug(\"Forwarding method '%s' to _data_plane_client\", name)\n            return method\n\n        # Method not found on client\n        raise AttributeError(\n            f\"'{self.__class__.__name__}' object has no attribute '{name}'. \"\n            f\"Method not found on _data_plane_client. \"\n            f\"Available methods can be found in the boto3 documentation for \"\n            f\"'bedrock-agentcore' services.\"\n        )\n\n    def process_turn_with_llm(\n        self,\n        actor_id: str,\n        session_id: str,\n        user_input: str,\n        llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n        retrieval_config: Optional[Dict[str, RetrievalConfig]],\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n        r\"\"\"Complete conversation turn with LLM callback integration.\n\n        This method combines memory retrieval, LLM invocation, and response storage\n        in a single call using a callback pattern.\n\n        Args:\n            actor_id: Actor identifier (e.g., \"user-123\")\n            session_id: Session identifier\n            user_input: The user's message\n            llm_callback: Function that takes (user_input, memories) and returns agent_response\n                         The callback receives the user input and retrieved memories,\n                         and should return the agent's response string\n            retrieval_config: Optional dictionary mapping namespaces to RetrievalConfig objects.\n                            Each namespace can contain template variables like {actorId}, {sessionId},\n                            {memoryStrategyId} that will be resolved at runtime.\n            event_timestamp: Optional timestamp for the event\n\n        Returns:\n            Tuple of (retrieved_memories, agent_response, created_event)\n\n        Example:\n            from bedrock_agentcore.memory.constants import RetrievalConfig\n\n            def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n                # Format context from memories\n                context = \"\\\\n\".join([m.get('content', {}).get('text', '') for m in memories])\n\n                # Call your LLM (Bedrock, OpenAI, etc.)\n                response = bedrock.invoke_model(\n                    messages=[\n                        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                        {\"role\": \"user\", \"content\": user_input}\n                    ]\n                )\n                return response['content']\n\n            retrieval_config = {\n                \"support/facts/{sessionId}\": RetrievalConfig(top_k=5, relevance_score=0.3),\n                \"user/preferences/{actorId}\": RetrievalConfig(top_k=3, relevance_score=0.5)\n            }\n\n            memories, response, event = manager.process_turn_with_llm(\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                user_input=\"What did we discuss yesterday?\",\n                llm_callback=my_llm,\n                retrieval_config=retrieval_config\n            )\n        \"\"\"\n        # Step 1: Retrieve relevant memories\n        retrieved_memories = []\n        if retrieval_config:\n            for namespace, config in retrieval_config.items():\n                resolved_namespace = namespace.format(\n                    actorId=actor_id,\n                    sessionId=session_id,\n                    strategyId=config.strategy_id or \"\",\n                )\n                search_query = f\"{config.retrieval_query} {user_input}\" if config.retrieval_query else user_input\n                memory_records = self.search_long_term_memories(\n                    query=search_query, namespace_prefix=resolved_namespace, top_k=config.top_k\n                )\n                # Filter memory records with a relevance score which is lower than config.relevance_score\n                if config.relevance_score:\n                    memory_records = [\n                        record\n                        for record in memory_records\n                        if record.get(\"relevanceScore\", config.relevance_score) &gt;= config.relevance_score\n                    ]\n\n                retrieved_memories.extend(memory_records)\n\n        logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n        # Step 2: Invoke LLM callback\n        try:\n            agent_response = llm_callback(user_input, retrieved_memories)\n            if not isinstance(agent_response, str):\n                raise ValueError(\"LLM callback must return a string response\")\n            logger.info(\"LLM callback generated response\")\n        except Exception as e:\n            logger.error(\"LLM callback failed: %s\", e)\n            raise\n\n        # Step 3: Save the conversation turn\n        event = self.add_turns(\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=[\n                ConversationalMessage(user_input, MessageRole.USER),\n                ConversationalMessage(agent_response, MessageRole.ASSISTANT),\n            ],\n            event_timestamp=event_timestamp,\n        )\n\n        logger.info(\"Completed full conversation turn with LLM\")\n        return retrieved_memories, agent_response, event\n\n    def add_turns(\n        self,\n        actor_id: str,\n        session_id: str,\n        messages: List[Union[ConversationalMessage, BlobMessage]],\n        branch: Optional[Dict[str, str]] = None,\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Event:\n        \"\"\"Adds conversational turns or blob objects to short-term memory.\n\n        Maps to: bedrock-agentcore.create_event\n\n        Args:\n            actor_id: Actor identifier\n            session_id: Session identifier\n            messages: List of either:\n                - ConversationalMessage objects for conversational messages\n                - BlobMessage objects for blob data\n            branch: Optional branch info\n            event_timestamp: Optional timestamp for the event\n\n        Returns:\n            Created event\n\n        Example:\n            manager.add_turns(\n                actor_id=\"user-123\",\n                session_id=\"session-456\",\n                messages=[\n                    ConversationalMessage(\"Hello\", USER),\n                    BlobMessage({\"file_data\": \"base64_content\"}),\n                    ConversationalMessage(\"How can I help?\", ASSISTANT)\n                ]\n            )\n        \"\"\"\n        logger.info(\"  -&gt; Storing %d messages in short-term memory...\", len(messages))\n\n        if not messages:\n            raise ValueError(\"At least one message is required\")\n\n        payload = []\n        for message in messages:\n            if isinstance(message, ConversationalMessage):\n                # Handle ConversationalMessage data class\n                payload.append({\"conversational\": {\"content\": {\"text\": message.text}, \"role\": message.role.value}})\n\n            elif isinstance(message, BlobMessage):\n                # Handle BlobMessage data class\n                payload.append({\"blob\": message.data})\n            else:\n                raise ValueError(\"Invalid message format. Must be ConversationalMessage or BlobMessage\")\n\n        # Use provided timestamp or current time\n        if event_timestamp is None:\n            event_timestamp = datetime.now(timezone.utc)\n\n        params = {\n            \"memoryId\": self._memory_id,\n            \"actorId\": actor_id,\n            \"sessionId\": session_id,\n            \"eventTimestamp\": event_timestamp,\n            \"payload\": payload,\n        }\n\n        if branch:\n            params[\"branch\"] = branch\n        try:\n            response = self._data_plane_client.create_event(**params)\n            logger.info(\"     \u2705 Turn stored successfully with Event ID: %s\", response.get(\"eventId\"))\n            return Event(response[\"event\"])\n        except ClientError as e:\n            logger.error(\"     \u274c Error storing turn: %s\", e)\n            raise\n\n    def fork_conversation(\n        self,\n        actor_id: str,\n        session_id: str,\n        root_event_id: str,\n        branch_name: str,\n        messages: List[Union[ConversationalMessage, BlobMessage]],\n        event_timestamp: Optional[datetime] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n        try:\n            branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n            event = self.add_turns(\n                actor_id=actor_id,\n                session_id=session_id,\n                messages=messages,\n                event_timestamp=event_timestamp,\n                branch=branch,\n            )\n\n            logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n            return event\n\n        except ClientError as e:\n            logger.error(\"Failed to fork conversation: %s\", e)\n            raise\n\n    def list_events(\n        self,\n        actor_id: str,\n        session_id: str,\n        branch_name: Optional[str] = None,\n        include_parent_branches: bool = False,\n        max_results: int = 100,\n        include_payload: bool = True,\n    ) -&gt; List[Event]:\n        \"\"\"List all events in a session with pagination support.\n\n        This method provides direct access to the raw events API, allowing developers\n        to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n        Args:\n            actor_id: Actor identifier\n            session_id: Session identifier\n            branch_name: Optional branch name to filter events (None for all branches)\n            include_parent_branches: Whether to include parent branch events (only applies with branch_name)\n            max_results: Maximum number of events to return\n            include_payload: Whether to include event payloads in response\n\n        Returns:\n            List of event dictionaries in chronological order\n\n        Example:\n            # Get all events\n            events = client.list_events(actor_id, session_id)\n\n            # Get only main branch events\n            main_events = client.list_events(actor_id, session_id, branch_name=\"main\")\n\n            # Get events from a specific branch\n            branch_events = client.list_events(actor_id, session_id, branch_name=\"test-branch\")\n        \"\"\"\n        try:\n            all_events: List[Event] = []\n            next_token = None\n            max_iterations = 1000  # Safety limit to prevent infinite loops\n\n            iteration_count = 0\n            while len(all_events) &lt; max_results and iteration_count &lt; max_iterations:\n                iteration_count += 1\n\n                params = {\n                    \"memoryId\": self._memory_id,\n                    \"actorId\": actor_id,\n                    \"sessionId\": session_id,\n                    \"maxResults\": min(100, max_results - len(all_events)),\n                    \"includePayloads\": include_payload,\n                }\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                # Add branch filter if specified (but not for \"main\")\n                if branch_name and branch_name != \"main\":\n                    params[\"filter\"] = {\n                        \"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_branches}\n                    }\n\n                response = self._data_plane_client.list_events(**params)\n\n                events = response.get(\"events\", [])\n\n                # If no events returned, break to prevent infinite loop\n                if not events:\n                    logger.debug(\"No more events returned, ending pagination\")\n                    break\n\n                all_events.extend([Event(event) for event in events])\n\n                next_token = response.get(\"nextToken\")\n                if not next_token or len(all_events) &gt;= max_results:\n                    break\n\n            if iteration_count &gt;= max_iterations:\n                logger.warning(\"Reached maximum iteration limit (%d) in list_events pagination\", max_iterations)\n\n            logger.info(\"Retrieved total of %d events\", len(all_events))\n            return all_events[:max_results]\n\n        except ClientError as e:\n            logger.error(\"Failed to list events: %s\", e)\n            raise\n\n    def list_branches(self, actor_id: str, session_id: str) -&gt; List[Branch]:\n        \"\"\"List all branches in a session.\n\n        This method handles pagination automatically and provides a structured view\n        of all conversation branches, which would require complex pagination and\n        grouping logic if done with raw boto3 calls.\n\n        Returns:\n            List of branch information including name and root event\n        \"\"\"\n        try:\n            # Get all events - need to handle pagination for complete list\n            all_events = []\n            next_token = None\n            max_iterations = 1000  # Safety limit to prevent infinite loops\n\n            iteration_count = 0\n            while iteration_count &lt; max_iterations:\n                iteration_count += 1\n\n                params = {\"memoryId\": self._memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n                if next_token:\n                    params[\"nextToken\"] = next_token\n\n                response = self._data_plane_client.list_events(**params)\n                events = response.get(\"events\", [])\n\n                # If no events returned, break to prevent infinite loop\n                if not events:\n                    logger.debug(\"No more events returned, ending pagination in list_branches\")\n                    break\n\n                all_events.extend(events)\n\n                next_token = response.get(\"nextToken\")\n                if not next_token:\n                    break\n\n            if iteration_count &gt;= max_iterations:\n                logger.warning(\"Reached maximum iteration limit (%d) in list_branches pagination\", max_iterations)\n\n            branches = {}\n            main_branch_events = []\n\n            for event in all_events:\n                branch_info = event.get(\"branch\")\n                if branch_info:\n                    branch_name = branch_info[\"name\"]\n                    if branch_name not in branches:\n                        branches[branch_name] = {\n                            \"name\": branch_name,\n                            \"rootEventId\": branch_info.get(\"rootEventId\"),\n                            \"firstEventId\": event[\"eventId\"],\n                            \"eventCount\": 1,\n                            \"created\": event[\"eventTimestamp\"],\n                        }\n                    else:\n                        branches[branch_name][\"eventCount\"] += 1\n                else:\n                    main_branch_events.append(event)\n\n            # Build result list\n            result: List[Branch] = []\n\n            # Only add main branch if there are actual events\n            if main_branch_events:\n                result.append(\n                    {\n                        \"name\": \"main\",\n                        \"rootEventId\": None,\n                        \"firstEventId\": main_branch_events[0][\"eventId\"],\n                        \"eventCount\": len(main_branch_events),\n                        \"created\": main_branch_events[0][\"eventTimestamp\"],\n                    }\n                )\n\n            # Add other branches\n            result.extend(list(branches.values()))\n\n            logger.info(\"Found %d branches in session %s\", len(result), session_id)\n            return [Branch(branch) for branch in result]\n\n        except ClientError as e:\n            logger.error(\"Failed to list branches: %s\", e)\n            raise\n\n    def get_last_k_turns(\n        self,\n        actor_id: str,\n        session_id: str,\n        k: int = 5,\n        branch_name: Optional[str] = None,\n        include_parent_branches: bool = False,\n        max_results: int = 100,\n    ) -&gt; List[List[EventMessage]]:\n        \"\"\"Get the last K conversation turns.\n\n        A \"turn\" typically consists of a user message followed by assistant response(s).\n        This method groups messages into logical turns for easier processing.\n\n        Returns:\n            List of turns, where each turn is a list of message dictionaries\n        \"\"\"\n        try:\n            events = self.list_events(\n                actor_id=actor_id,\n                session_id=session_id,\n                branch_name=branch_name,\n                include_parent_branches=include_parent_branches,\n                max_results=max_results,\n            )\n\n            if not events:\n                return []\n\n            # Process events to group into turns\n            turns = []\n            current_turn = []\n\n            for event in events:\n                if len(turns) &gt;= k:\n                    break  # Only need last K turns\n                for payload_item in event.get(\"payload\", []):\n                    if \"conversational\" in payload_item:\n                        role = payload_item[\"conversational\"].get(\"role\")\n\n                        # Start new turn on USER message\n                        if role == MessageRole.USER.value and current_turn:\n                            turns.append(current_turn)\n                            current_turn = []\n\n                        current_turn.append(EventMessage(payload_item[\"conversational\"]))\n\n            # Don't forget the last turn\n            if current_turn:\n                turns.append(current_turn)\n\n            # Return the last k turns\n            return turns[:k] if len(turns) &gt; k else turns\n\n        except ClientError as e:\n            logger.error(\"Failed to get last K turns: %s\", e)\n            raise\n\n    def get_event(self, actor_id: str, session_id: str, event_id: str) -&gt; Event:\n        \"\"\"Retrieves a specific event from short-term memory by its ID.\n\n        Maps to: bedrock-agentcore.get_event.\n        \"\"\"\n        logger.info(\"  -&gt; Retrieving event by ID: %s...\", event_id)\n        try:\n            response = self._data_plane_client.get_event(\n                memoryId=self._memory_id, actorId=actor_id, sessionId=session_id, eventId=event_id\n            )\n            logger.info(\"     \u2705 Event retrieved.\")\n            return Event(response.get(\"event\", {}))\n        except ClientError as e:\n            logger.error(\"     \u274c Error retrieving event: %s\", e)\n            raise\n\n    def delete_event(self, actor_id: str, session_id: str, event_id: str):\n        \"\"\"Deletes a specific event from short-term memory by its ID.\n\n        Maps to: bedrock-agentcore.delete_event.\n        \"\"\"\n        logger.info(\"  -&gt; Deleting event by ID: %s...\", event_id)\n        try:\n            self._data_plane_client.delete_event(\n                memoryId=self._memory_id, actorId=actor_id, sessionId=session_id, eventId=event_id\n            )\n            logger.info(\"     \u2705 Event deleted successfully.\")\n        except ClientError as e:\n            logger.error(\"     \u274c Error deleting event: %s\", e)\n            raise\n\n    def search_long_term_memories(\n        self,\n        query: str,\n        namespace_prefix: str,\n        top_k: int = 3,\n        strategy_id: str = None,\n        max_results: int = 20,\n    ) -&gt; List[MemoryRecord]:\n        \"\"\"Performs a semantic search against the long-term memory for this actor.\n\n        Maps to: bedrock-agentcore.retrieve_memory_records.\n        \"\"\"\n        logger.info(\"  -&gt; Querying long-term memory in namespace '%s' with query: '%s'...\", namespace_prefix, query)\n        search_criteria = {\"searchQuery\": query, \"topK\": top_k}\n        if strategy_id:\n            search_criteria[\"strategyId\"] = strategy_id\n\n        namespace = namespace_prefix\n        params = {\n            \"memoryId\": self._memory_id,\n            \"searchCriteria\": search_criteria,\n            \"namespace\": namespace,\n            \"maxResults\": max_results,\n        }\n\n        try:\n            response = self._data_plane_client.retrieve_memory_records(**params)\n            records = response.get(\"memoryRecordSummaries\", [])\n            logger.info(\"     \u2705 Found %d relevant long-term records.\", len(records))\n            return [MemoryRecord(record) for record in records]\n        except ClientError as e:\n            logger.info(\"     \u274c Error querying long-term memory\", e)\n            raise\n\n    def list_long_term_memory_records(\n        self, namespace_prefix: str, strategy_id: Optional[str] = None, max_results: int = 10\n    ) -&gt; List[MemoryRecord]:\n        \"\"\"Lists all long-term memory records for this actor without a semantic query.\n\n        Maps to: bedrock-agentcore.list_memory_records.\n        \"\"\"\n        logger.info(\"  -&gt; Listing all long-term records in namespace '%s'...\", namespace_prefix)\n\n        try:\n            paginator = self._data_plane_client.get_paginator(\"list_memory_records\")\n\n            params = {\n                \"memoryId\": self._memory_id,\n                \"namespace\": namespace_prefix,\n            }\n\n            if strategy_id:\n                params[\"memoryStrategyId\"] = strategy_id\n\n            pages = paginator.paginate(**params)\n            all_records: List[MemoryRecord] = []\n\n            for page in pages:\n                memory_records = page.get(\"memoryRecords\", [])\n                # Also check for memoryRecordSummaries (which is what the API actually returns)\n                if not memory_records:\n                    memory_records = page.get(\"memoryRecordSummaries\", [])\n\n                all_records.extend([MemoryRecord(record) for record in memory_records])\n\n                # Stop if we've reached max_results\n                if len(all_records) &gt;= max_results:\n                    break\n\n            logger.info(\"     \u2705 Found a total of %d long-term records.\", len(all_records))\n            return all_records[:max_results]\n\n        except ClientError as e:\n            logger.error(\"     \u274c Error listing long-term records: %s\", e)\n            raise\n\n    def list_actors(self) -&gt; List[ActorSummary]:\n        \"\"\"Lists all actors who have events in a specific memory.\n\n        Maps to: bedrock-agentcore.list_actors.\n        \"\"\"\n        logger.info(\"\ud83d\udc65 Listing all actors for memory %s...\", self._memory_id)\n        try:\n            paginator = self._data_plane_client.get_paginator(\"list_actors\")\n            pages = paginator.paginate(memoryId=self._memory_id)\n            all_actors = []\n            for page in pages:\n                actor_summaries = page.get(\"actorSummaries\", [])\n                all_actors.extend([ActorSummary(actor) for actor in actor_summaries])\n            logger.info(\"  \u2705 Found %d actors.\", len(all_actors))\n            return all_actors\n        except ClientError as e:\n            logger.error(\"  \u274c Error listing actors: %s\", e)\n            raise\n\n    def get_memory_record(self, record_id: str) -&gt; MemoryRecord:\n        \"\"\"Retrieves a specific long-term memory record by its ID.\n\n        Maps to: bedrock-agentcore.get_memory_record.\n        \"\"\"\n        logger.info(\"\ud83d\udcc4 Retrieving long-term record by ID: %s from memory %s...\", record_id, self._memory_id)\n        try:\n            response = self._data_plane_client.get_memory_record(memoryId=self._memory_id, memoryRecordId=record_id)\n            logger.info(\"  \u2705 Record retrieved.\")\n            memory_record = response.get(\"memoryRecord\", {})\n            return MemoryRecord(memory_record)\n        except ClientError as e:\n            logger.error(\"  \u274c Error retrieving record: %s\", e)\n            raise\n\n    def delete_memory_record(self, record_id: str):\n        \"\"\"Deletes a specific long-term memory record by its ID.\n\n        Maps to: bedrock-agentcore.delete_memory_record.\n        \"\"\"\n        logger.info(\"\ud83d\uddd1\ufe0f Deleting long-term record by ID: %s from memory %s...\", record_id, self._memory_id)\n        try:\n            self._data_plane_client.delete_memory_record(memoryId=self._memory_id, memoryRecordId=record_id)\n            logger.info(\"  \u2705 Record deleted successfully.\")\n        except ClientError as e:\n            logger.error(\"  \u274c Error deleting record: %s\", e)\n            raise\n\n    def list_actor_sessions(self, actor_id: str) -&gt; List[SessionSummary]:\n        \"\"\"Lists all sessions for a specific actor in a specific memory.\n\n        Maps to: bedrock-agentcore.list_sessions.\n        \"\"\"\n        logger.info(\"\ud83d\uddc2\ufe0f Listing all sessions for actor '%s' in memory %s...\", actor_id, self._memory_id)\n        try:\n            paginator = self._data_plane_client.get_paginator(\"list_sessions\")\n            pages = paginator.paginate(memoryId=self._memory_id, actorId=actor_id)\n            all_sessions: List[SessionSummary] = []\n            for page in pages:\n                response = page.get(\"sessionSummaries\", [])\n                all_sessions.extend([SessionSummary(session) for session in response])\n            logger.info(\"  \u2705 Found %d sessions.\", len(all_sessions))\n            return all_sessions\n        except ClientError as e:\n            logger.error(\"  \u274c Error listing sessions: %s\", e)\n            raise\n\n    def create_memory_session(self, actor_id: str, session_id: str = None) -&gt; \"MemorySession\":\n        \"\"\"Creates a new MemorySession instance.\"\"\"\n        session_id = session_id or str(uuid.uuid4())\n        logger.info(\"\ud83d\udcac Creating new conversation for actor '%s' in session '%s'...\", actor_id, session_id)\n        return MemorySession(memory_id=self._memory_id, actor_id=actor_id, session_id=session_id, manager=self)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Dynamically forward method calls to the appropriate boto3 client.</p> <p>This method enables access to all data_plane boto3 client methods without explicitly defining them. Methods are looked up in the following order: _data_plane_client (bedrock-agentcore) - for data plane operations</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The method name being accessed</p> required <p>Returns:</p> Type Description <p>A callable method from the boto3 client</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the method doesn't exist on _data_plane_client</p> Example Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def __getattr__(self, name: str):\n    \"\"\"Dynamically forward method calls to the appropriate boto3 client.\n\n    This method enables access to all data_plane boto3 client methods without explicitly\n    defining them. Methods are looked up in the following order:\n    _data_plane_client (bedrock-agentcore) - for data plane operations\n\n    Args:\n        name: The method name being accessed\n\n    Returns:\n        A callable method from the boto3 client\n\n    Raises:\n        AttributeError: If the method doesn't exist on _data_plane_client\n\n    Example:\n        # Access any boto3 method directly\n        manager = MemorySessionManager(region_name=\"us-east-1\")\n\n        # These calls are forwarded to the appropriate boto3 functions\n        memory_records = manager.retrieve_memory_records()\n        events = manager.list_events(...)\n    \"\"\"\n    if name in self._ALLOWED_DATA_PLANE_METHODS and hasattr(self._data_plane_client, name):\n        method = getattr(self._data_plane_client, name)\n        logger.debug(\"Forwarding method '%s' to _data_plane_client\", name)\n        return method\n\n    # Method not found on client\n    raise AttributeError(\n        f\"'{self.__class__.__name__}' object has no attribute '{name}'. \"\n        f\"Method not found on _data_plane_client. \"\n        f\"Available methods can be found in the boto3 documentation for \"\n        f\"'bedrock-agentcore' services.\"\n    )\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.__getattr__--access-any-boto3-method-directly","title":"Access any boto3 method directly","text":"<p>manager = MemorySessionManager(region_name=\"us-east-1\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.__getattr__--these-calls-are-forwarded-to-the-appropriate-boto3-functions","title":"These calls are forwarded to the appropriate boto3 functions","text":"<p>memory_records = manager.retrieve_memory_records() events = manager.list_events(...)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.__init__","title":"<code>__init__(memory_id, region_name=None, boto3_session=None, boto_client_config=None)</code>","text":"<p>Initialize a MemorySessionManager instance.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>The memory identifier for this session manager.</p> required <code>region_name</code> <code>Optional[str]</code> <p>AWS region for the bedrock-agentcore client. If not provided,    will use the region from boto3_session or default session.</p> <code>None</code> <code>boto3_session</code> <code>Optional[Session]</code> <p>Optional boto3 Session to use. If provided and region_name           parameter is also specified, validation will ensure they match.</p> <code>None</code> <code>boto_client_config</code> <code>Optional[Config]</code> <p>Optional boto3 client configuration. If provided, will be               merged with default configuration including user agent.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If region_name parameter conflicts with boto3_session region.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def __init__(\n    self,\n    memory_id: str,\n    region_name: Optional[str] = None,\n    boto3_session: Optional[boto3.Session] = None,\n    boto_client_config: Optional[BotocoreConfig] = None,\n):\n    \"\"\"Initialize a MemorySessionManager instance.\n\n    Args:\n        memory_id: The memory identifier for this session manager.\n        region_name: AWS region for the bedrock-agentcore client. If not provided,\n               will use the region from boto3_session or default session.\n        boto3_session: Optional boto3 Session to use. If provided and region_name\n                      parameter is also specified, validation will ensure they match.\n        boto_client_config: Optional boto3 client configuration. If provided, will be\n                          merged with default configuration including user agent.\n\n    Raises:\n        ValueError: If region_name parameter conflicts with boto3_session region.\n    \"\"\"\n    # Initialize core attributes\n    self._memory_id = memory_id\n\n    # Setup session and validate region consistency\n    self.region_name = self._validate_and_resolve_region(region_name, boto3_session)\n    session = boto3_session if boto3_session else boto3.Session()\n\n    # Configure and create boto3 client\n    client_config = self._build_client_config(boto_client_config)\n    self._data_plane_client = session.client(\n        \"bedrock-agentcore\", region_name=self.region_name, config=client_config\n    )\n\n    # Configure timestamp serialization to use float representation\n    self._configure_timestamp_serialization()\n\n    # Define allowed data plane methods\n    self._ALLOWED_DATA_PLANE_METHODS = {\n        \"retrieve_memory_records\",\n        \"get_memory_record\",\n        \"delete_memory_record\",\n        \"list_memory_records\",\n        \"create_event\",\n        \"get_event\",\n        \"delete_event\",\n        \"list_events\",\n    }\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.add_turns","title":"<code>add_turns(actor_id, session_id, messages, branch=None, event_timestamp=None)</code>","text":"<p>Adds conversational turns or blob objects to short-term memory.</p> <p>Maps to: bedrock-agentcore.create_event</p> <p>Parameters:</p> Name Type Description Default <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>messages</code> <code>List[Union[ConversationalMessage, BlobMessage]]</code> <p>List of either: - ConversationalMessage objects for conversational messages - BlobMessage objects for blob data</p> required <code>branch</code> <code>Optional[Dict[str, str]]</code> <p>Optional branch info</p> <code>None</code> <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the event</p> <code>None</code> <p>Returns:</p> Type Description <code>Event</code> <p>Created event</p> Example <p>manager.add_turns(     actor_id=\"user-123\",     session_id=\"session-456\",     messages=[         ConversationalMessage(\"Hello\", USER),         BlobMessage({\"file_data\": \"base64_content\"}),         ConversationalMessage(\"How can I help?\", ASSISTANT)     ] )</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def add_turns(\n    self,\n    actor_id: str,\n    session_id: str,\n    messages: List[Union[ConversationalMessage, BlobMessage]],\n    branch: Optional[Dict[str, str]] = None,\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Event:\n    \"\"\"Adds conversational turns or blob objects to short-term memory.\n\n    Maps to: bedrock-agentcore.create_event\n\n    Args:\n        actor_id: Actor identifier\n        session_id: Session identifier\n        messages: List of either:\n            - ConversationalMessage objects for conversational messages\n            - BlobMessage objects for blob data\n        branch: Optional branch info\n        event_timestamp: Optional timestamp for the event\n\n    Returns:\n        Created event\n\n    Example:\n        manager.add_turns(\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            messages=[\n                ConversationalMessage(\"Hello\", USER),\n                BlobMessage({\"file_data\": \"base64_content\"}),\n                ConversationalMessage(\"How can I help?\", ASSISTANT)\n            ]\n        )\n    \"\"\"\n    logger.info(\"  -&gt; Storing %d messages in short-term memory...\", len(messages))\n\n    if not messages:\n        raise ValueError(\"At least one message is required\")\n\n    payload = []\n    for message in messages:\n        if isinstance(message, ConversationalMessage):\n            # Handle ConversationalMessage data class\n            payload.append({\"conversational\": {\"content\": {\"text\": message.text}, \"role\": message.role.value}})\n\n        elif isinstance(message, BlobMessage):\n            # Handle BlobMessage data class\n            payload.append({\"blob\": message.data})\n        else:\n            raise ValueError(\"Invalid message format. Must be ConversationalMessage or BlobMessage\")\n\n    # Use provided timestamp or current time\n    if event_timestamp is None:\n        event_timestamp = datetime.now(timezone.utc)\n\n    params = {\n        \"memoryId\": self._memory_id,\n        \"actorId\": actor_id,\n        \"sessionId\": session_id,\n        \"eventTimestamp\": event_timestamp,\n        \"payload\": payload,\n    }\n\n    if branch:\n        params[\"branch\"] = branch\n    try:\n        response = self._data_plane_client.create_event(**params)\n        logger.info(\"     \u2705 Turn stored successfully with Event ID: %s\", response.get(\"eventId\"))\n        return Event(response[\"event\"])\n    except ClientError as e:\n        logger.error(\"     \u274c Error storing turn: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.create_memory_session","title":"<code>create_memory_session(actor_id, session_id=None)</code>","text":"<p>Creates a new MemorySession instance.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def create_memory_session(self, actor_id: str, session_id: str = None) -&gt; \"MemorySession\":\n    \"\"\"Creates a new MemorySession instance.\"\"\"\n    session_id = session_id or str(uuid.uuid4())\n    logger.info(\"\ud83d\udcac Creating new conversation for actor '%s' in session '%s'...\", actor_id, session_id)\n    return MemorySession(memory_id=self._memory_id, actor_id=actor_id, session_id=session_id, manager=self)\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.delete_event","title":"<code>delete_event(actor_id, session_id, event_id)</code>","text":"<p>Deletes a specific event from short-term memory by its ID.</p> <p>Maps to: bedrock-agentcore.delete_event.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def delete_event(self, actor_id: str, session_id: str, event_id: str):\n    \"\"\"Deletes a specific event from short-term memory by its ID.\n\n    Maps to: bedrock-agentcore.delete_event.\n    \"\"\"\n    logger.info(\"  -&gt; Deleting event by ID: %s...\", event_id)\n    try:\n        self._data_plane_client.delete_event(\n            memoryId=self._memory_id, actorId=actor_id, sessionId=session_id, eventId=event_id\n        )\n        logger.info(\"     \u2705 Event deleted successfully.\")\n    except ClientError as e:\n        logger.error(\"     \u274c Error deleting event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.delete_memory_record","title":"<code>delete_memory_record(record_id)</code>","text":"<p>Deletes a specific long-term memory record by its ID.</p> <p>Maps to: bedrock-agentcore.delete_memory_record.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def delete_memory_record(self, record_id: str):\n    \"\"\"Deletes a specific long-term memory record by its ID.\n\n    Maps to: bedrock-agentcore.delete_memory_record.\n    \"\"\"\n    logger.info(\"\ud83d\uddd1\ufe0f Deleting long-term record by ID: %s from memory %s...\", record_id, self._memory_id)\n    try:\n        self._data_plane_client.delete_memory_record(memoryId=self._memory_id, memoryRecordId=record_id)\n        logger.info(\"  \u2705 Record deleted successfully.\")\n    except ClientError as e:\n        logger.error(\"  \u274c Error deleting record: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.fork_conversation","title":"<code>fork_conversation(actor_id, session_id, root_event_id, branch_name, messages, event_timestamp=None)</code>","text":"<p>Fork a conversation from a specific event to create a new branch.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def fork_conversation(\n    self,\n    actor_id: str,\n    session_id: str,\n    root_event_id: str,\n    branch_name: str,\n    messages: List[Union[ConversationalMessage, BlobMessage]],\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Fork a conversation from a specific event to create a new branch.\"\"\"\n    try:\n        branch = {\"rootEventId\": root_event_id, \"name\": branch_name}\n\n        event = self.add_turns(\n            actor_id=actor_id,\n            session_id=session_id,\n            messages=messages,\n            event_timestamp=event_timestamp,\n            branch=branch,\n        )\n\n        logger.info(\"Created branch '%s' from event %s\", branch_name, root_event_id)\n        return event\n\n    except ClientError as e:\n        logger.error(\"Failed to fork conversation: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.get_event","title":"<code>get_event(actor_id, session_id, event_id)</code>","text":"<p>Retrieves a specific event from short-term memory by its ID.</p> <p>Maps to: bedrock-agentcore.get_event.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def get_event(self, actor_id: str, session_id: str, event_id: str) -&gt; Event:\n    \"\"\"Retrieves a specific event from short-term memory by its ID.\n\n    Maps to: bedrock-agentcore.get_event.\n    \"\"\"\n    logger.info(\"  -&gt; Retrieving event by ID: %s...\", event_id)\n    try:\n        response = self._data_plane_client.get_event(\n            memoryId=self._memory_id, actorId=actor_id, sessionId=session_id, eventId=event_id\n        )\n        logger.info(\"     \u2705 Event retrieved.\")\n        return Event(response.get(\"event\", {}))\n    except ClientError as e:\n        logger.error(\"     \u274c Error retrieving event: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.get_last_k_turns","title":"<code>get_last_k_turns(actor_id, session_id, k=5, branch_name=None, include_parent_branches=False, max_results=100)</code>","text":"<p>Get the last K conversation turns.</p> <p>A \"turn\" typically consists of a user message followed by assistant response(s). This method groups messages into logical turns for easier processing.</p> <p>Returns:</p> Type Description <code>List[List[EventMessage]]</code> <p>List of turns, where each turn is a list of message dictionaries</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def get_last_k_turns(\n    self,\n    actor_id: str,\n    session_id: str,\n    k: int = 5,\n    branch_name: Optional[str] = None,\n    include_parent_branches: bool = False,\n    max_results: int = 100,\n) -&gt; List[List[EventMessage]]:\n    \"\"\"Get the last K conversation turns.\n\n    A \"turn\" typically consists of a user message followed by assistant response(s).\n    This method groups messages into logical turns for easier processing.\n\n    Returns:\n        List of turns, where each turn is a list of message dictionaries\n    \"\"\"\n    try:\n        events = self.list_events(\n            actor_id=actor_id,\n            session_id=session_id,\n            branch_name=branch_name,\n            include_parent_branches=include_parent_branches,\n            max_results=max_results,\n        )\n\n        if not events:\n            return []\n\n        # Process events to group into turns\n        turns = []\n        current_turn = []\n\n        for event in events:\n            if len(turns) &gt;= k:\n                break  # Only need last K turns\n            for payload_item in event.get(\"payload\", []):\n                if \"conversational\" in payload_item:\n                    role = payload_item[\"conversational\"].get(\"role\")\n\n                    # Start new turn on USER message\n                    if role == MessageRole.USER.value and current_turn:\n                        turns.append(current_turn)\n                        current_turn = []\n\n                    current_turn.append(EventMessage(payload_item[\"conversational\"]))\n\n        # Don't forget the last turn\n        if current_turn:\n            turns.append(current_turn)\n\n        # Return the last k turns\n        return turns[:k] if len(turns) &gt; k else turns\n\n    except ClientError as e:\n        logger.error(\"Failed to get last K turns: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.get_memory_record","title":"<code>get_memory_record(record_id)</code>","text":"<p>Retrieves a specific long-term memory record by its ID.</p> <p>Maps to: bedrock-agentcore.get_memory_record.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def get_memory_record(self, record_id: str) -&gt; MemoryRecord:\n    \"\"\"Retrieves a specific long-term memory record by its ID.\n\n    Maps to: bedrock-agentcore.get_memory_record.\n    \"\"\"\n    logger.info(\"\ud83d\udcc4 Retrieving long-term record by ID: %s from memory %s...\", record_id, self._memory_id)\n    try:\n        response = self._data_plane_client.get_memory_record(memoryId=self._memory_id, memoryRecordId=record_id)\n        logger.info(\"  \u2705 Record retrieved.\")\n        memory_record = response.get(\"memoryRecord\", {})\n        return MemoryRecord(memory_record)\n    except ClientError as e:\n        logger.error(\"  \u274c Error retrieving record: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_actor_sessions","title":"<code>list_actor_sessions(actor_id)</code>","text":"<p>Lists all sessions for a specific actor in a specific memory.</p> <p>Maps to: bedrock-agentcore.list_sessions.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_actor_sessions(self, actor_id: str) -&gt; List[SessionSummary]:\n    \"\"\"Lists all sessions for a specific actor in a specific memory.\n\n    Maps to: bedrock-agentcore.list_sessions.\n    \"\"\"\n    logger.info(\"\ud83d\uddc2\ufe0f Listing all sessions for actor '%s' in memory %s...\", actor_id, self._memory_id)\n    try:\n        paginator = self._data_plane_client.get_paginator(\"list_sessions\")\n        pages = paginator.paginate(memoryId=self._memory_id, actorId=actor_id)\n        all_sessions: List[SessionSummary] = []\n        for page in pages:\n            response = page.get(\"sessionSummaries\", [])\n            all_sessions.extend([SessionSummary(session) for session in response])\n        logger.info(\"  \u2705 Found %d sessions.\", len(all_sessions))\n        return all_sessions\n    except ClientError as e:\n        logger.error(\"  \u274c Error listing sessions: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_actors","title":"<code>list_actors()</code>","text":"<p>Lists all actors who have events in a specific memory.</p> <p>Maps to: bedrock-agentcore.list_actors.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_actors(self) -&gt; List[ActorSummary]:\n    \"\"\"Lists all actors who have events in a specific memory.\n\n    Maps to: bedrock-agentcore.list_actors.\n    \"\"\"\n    logger.info(\"\ud83d\udc65 Listing all actors for memory %s...\", self._memory_id)\n    try:\n        paginator = self._data_plane_client.get_paginator(\"list_actors\")\n        pages = paginator.paginate(memoryId=self._memory_id)\n        all_actors = []\n        for page in pages:\n            actor_summaries = page.get(\"actorSummaries\", [])\n            all_actors.extend([ActorSummary(actor) for actor in actor_summaries])\n        logger.info(\"  \u2705 Found %d actors.\", len(all_actors))\n        return all_actors\n    except ClientError as e:\n        logger.error(\"  \u274c Error listing actors: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_branches","title":"<code>list_branches(actor_id, session_id)</code>","text":"<p>List all branches in a session.</p> <p>This method handles pagination automatically and provides a structured view of all conversation branches, which would require complex pagination and grouping logic if done with raw boto3 calls.</p> <p>Returns:</p> Type Description <code>List[Branch]</code> <p>List of branch information including name and root event</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_branches(self, actor_id: str, session_id: str) -&gt; List[Branch]:\n    \"\"\"List all branches in a session.\n\n    This method handles pagination automatically and provides a structured view\n    of all conversation branches, which would require complex pagination and\n    grouping logic if done with raw boto3 calls.\n\n    Returns:\n        List of branch information including name and root event\n    \"\"\"\n    try:\n        # Get all events - need to handle pagination for complete list\n        all_events = []\n        next_token = None\n        max_iterations = 1000  # Safety limit to prevent infinite loops\n\n        iteration_count = 0\n        while iteration_count &lt; max_iterations:\n            iteration_count += 1\n\n            params = {\"memoryId\": self._memory_id, \"actorId\": actor_id, \"sessionId\": session_id, \"maxResults\": 100}\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            response = self._data_plane_client.list_events(**params)\n            events = response.get(\"events\", [])\n\n            # If no events returned, break to prevent infinite loop\n            if not events:\n                logger.debug(\"No more events returned, ending pagination in list_branches\")\n                break\n\n            all_events.extend(events)\n\n            next_token = response.get(\"nextToken\")\n            if not next_token:\n                break\n\n        if iteration_count &gt;= max_iterations:\n            logger.warning(\"Reached maximum iteration limit (%d) in list_branches pagination\", max_iterations)\n\n        branches = {}\n        main_branch_events = []\n\n        for event in all_events:\n            branch_info = event.get(\"branch\")\n            if branch_info:\n                branch_name = branch_info[\"name\"]\n                if branch_name not in branches:\n                    branches[branch_name] = {\n                        \"name\": branch_name,\n                        \"rootEventId\": branch_info.get(\"rootEventId\"),\n                        \"firstEventId\": event[\"eventId\"],\n                        \"eventCount\": 1,\n                        \"created\": event[\"eventTimestamp\"],\n                    }\n                else:\n                    branches[branch_name][\"eventCount\"] += 1\n            else:\n                main_branch_events.append(event)\n\n        # Build result list\n        result: List[Branch] = []\n\n        # Only add main branch if there are actual events\n        if main_branch_events:\n            result.append(\n                {\n                    \"name\": \"main\",\n                    \"rootEventId\": None,\n                    \"firstEventId\": main_branch_events[0][\"eventId\"],\n                    \"eventCount\": len(main_branch_events),\n                    \"created\": main_branch_events[0][\"eventTimestamp\"],\n                }\n            )\n\n        # Add other branches\n        result.extend(list(branches.values()))\n\n        logger.info(\"Found %d branches in session %s\", len(result), session_id)\n        return [Branch(branch) for branch in result]\n\n    except ClientError as e:\n        logger.error(\"Failed to list branches: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_events","title":"<code>list_events(actor_id, session_id, branch_name=None, include_parent_branches=False, max_results=100, include_payload=True)</code>","text":"<p>List all events in a session with pagination support.</p> <p>This method provides direct access to the raw events API, allowing developers to retrieve all events without the turn grouping logic of get_last_k_turns.</p> <p>Parameters:</p> Name Type Description Default <code>actor_id</code> <code>str</code> <p>Actor identifier</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>branch_name</code> <code>Optional[str]</code> <p>Optional branch name to filter events (None for all branches)</p> <code>None</code> <code>include_parent_branches</code> <code>bool</code> <p>Whether to include parent branch events (only applies with branch_name)</p> <code>False</code> <code>max_results</code> <code>int</code> <p>Maximum number of events to return</p> <code>100</code> <code>include_payload</code> <code>bool</code> <p>Whether to include event payloads in response</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Event]</code> <p>List of event dictionaries in chronological order</p> Example Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_events(\n    self,\n    actor_id: str,\n    session_id: str,\n    branch_name: Optional[str] = None,\n    include_parent_branches: bool = False,\n    max_results: int = 100,\n    include_payload: bool = True,\n) -&gt; List[Event]:\n    \"\"\"List all events in a session with pagination support.\n\n    This method provides direct access to the raw events API, allowing developers\n    to retrieve all events without the turn grouping logic of get_last_k_turns.\n\n    Args:\n        actor_id: Actor identifier\n        session_id: Session identifier\n        branch_name: Optional branch name to filter events (None for all branches)\n        include_parent_branches: Whether to include parent branch events (only applies with branch_name)\n        max_results: Maximum number of events to return\n        include_payload: Whether to include event payloads in response\n\n    Returns:\n        List of event dictionaries in chronological order\n\n    Example:\n        # Get all events\n        events = client.list_events(actor_id, session_id)\n\n        # Get only main branch events\n        main_events = client.list_events(actor_id, session_id, branch_name=\"main\")\n\n        # Get events from a specific branch\n        branch_events = client.list_events(actor_id, session_id, branch_name=\"test-branch\")\n    \"\"\"\n    try:\n        all_events: List[Event] = []\n        next_token = None\n        max_iterations = 1000  # Safety limit to prevent infinite loops\n\n        iteration_count = 0\n        while len(all_events) &lt; max_results and iteration_count &lt; max_iterations:\n            iteration_count += 1\n\n            params = {\n                \"memoryId\": self._memory_id,\n                \"actorId\": actor_id,\n                \"sessionId\": session_id,\n                \"maxResults\": min(100, max_results - len(all_events)),\n                \"includePayloads\": include_payload,\n            }\n\n            if next_token:\n                params[\"nextToken\"] = next_token\n\n            # Add branch filter if specified (but not for \"main\")\n            if branch_name and branch_name != \"main\":\n                params[\"filter\"] = {\n                    \"branch\": {\"name\": branch_name, \"includeParentBranches\": include_parent_branches}\n                }\n\n            response = self._data_plane_client.list_events(**params)\n\n            events = response.get(\"events\", [])\n\n            # If no events returned, break to prevent infinite loop\n            if not events:\n                logger.debug(\"No more events returned, ending pagination\")\n                break\n\n            all_events.extend([Event(event) for event in events])\n\n            next_token = response.get(\"nextToken\")\n            if not next_token or len(all_events) &gt;= max_results:\n                break\n\n        if iteration_count &gt;= max_iterations:\n            logger.warning(\"Reached maximum iteration limit (%d) in list_events pagination\", max_iterations)\n\n        logger.info(\"Retrieved total of %d events\", len(all_events))\n        return all_events[:max_results]\n\n    except ClientError as e:\n        logger.error(\"Failed to list events: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_events--get-all-events","title":"Get all events","text":"<p>events = client.list_events(actor_id, session_id)</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_events--get-only-main-branch-events","title":"Get only main branch events","text":"<p>main_events = client.list_events(actor_id, session_id, branch_name=\"main\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_events--get-events-from-a-specific-branch","title":"Get events from a specific branch","text":"<p>branch_events = client.list_events(actor_id, session_id, branch_name=\"test-branch\")</p>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.list_long_term_memory_records","title":"<code>list_long_term_memory_records(namespace_prefix, strategy_id=None, max_results=10)</code>","text":"<p>Lists all long-term memory records for this actor without a semantic query.</p> <p>Maps to: bedrock-agentcore.list_memory_records.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def list_long_term_memory_records(\n    self, namespace_prefix: str, strategy_id: Optional[str] = None, max_results: int = 10\n) -&gt; List[MemoryRecord]:\n    \"\"\"Lists all long-term memory records for this actor without a semantic query.\n\n    Maps to: bedrock-agentcore.list_memory_records.\n    \"\"\"\n    logger.info(\"  -&gt; Listing all long-term records in namespace '%s'...\", namespace_prefix)\n\n    try:\n        paginator = self._data_plane_client.get_paginator(\"list_memory_records\")\n\n        params = {\n            \"memoryId\": self._memory_id,\n            \"namespace\": namespace_prefix,\n        }\n\n        if strategy_id:\n            params[\"memoryStrategyId\"] = strategy_id\n\n        pages = paginator.paginate(**params)\n        all_records: List[MemoryRecord] = []\n\n        for page in pages:\n            memory_records = page.get(\"memoryRecords\", [])\n            # Also check for memoryRecordSummaries (which is what the API actually returns)\n            if not memory_records:\n                memory_records = page.get(\"memoryRecordSummaries\", [])\n\n            all_records.extend([MemoryRecord(record) for record in memory_records])\n\n            # Stop if we've reached max_results\n            if len(all_records) &gt;= max_results:\n                break\n\n        logger.info(\"     \u2705 Found a total of %d long-term records.\", len(all_records))\n        return all_records[:max_results]\n\n    except ClientError as e:\n        logger.error(\"     \u274c Error listing long-term records: %s\", e)\n        raise\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.process_turn_with_llm","title":"<code>process_turn_with_llm(actor_id, session_id, user_input, llm_callback, retrieval_config, event_timestamp=None)</code>","text":"<p>Complete conversation turn with LLM callback integration.</p> <p>This method combines memory retrieval, LLM invocation, and response storage in a single call using a callback pattern.</p> <p>Parameters:</p> Name Type Description Default <code>actor_id</code> <code>str</code> <p>Actor identifier (e.g., \"user-123\")</p> required <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>user_input</code> <code>str</code> <p>The user's message</p> required <code>llm_callback</code> <code>Callable[[str, List[Dict[str, Any]]], str]</code> <p>Function that takes (user_input, memories) and returns agent_response          The callback receives the user input and retrieved memories,          and should return the agent's response string</p> required <code>retrieval_config</code> <code>Optional[Dict[str, RetrievalConfig]]</code> <p>Optional dictionary mapping namespaces to RetrievalConfig objects.             Each namespace can contain template variables like {actorId}, {sessionId},             {memoryStrategyId} that will be resolved at runtime.</p> required <code>event_timestamp</code> <code>Optional[datetime]</code> <p>Optional timestamp for the event</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[Dict[str, Any]], str, Dict[str, Any]]</code> <p>Tuple of (retrieved_memories, agent_response, created_event)</p> Example <p>from bedrock_agentcore.memory.constants import RetrievalConfig</p> <p>def my_llm(user_input: str, memories: List[Dict]) -&gt; str:     # Format context from memories     context = \"\\n\".join([m.get('content', {}).get('text', '') for m in memories])</p> <pre><code># Call your LLM (Bedrock, OpenAI, etc.)\nresponse = bedrock.invoke_model(\n    messages=[\n        {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n        {\"role\": \"user\", \"content\": user_input}\n    ]\n)\nreturn response['content']\n</code></pre> <p>retrieval_config = {     \"support/facts/{sessionId}\": RetrievalConfig(top_k=5, relevance_score=0.3),     \"user/preferences/{actorId}\": RetrievalConfig(top_k=3, relevance_score=0.5) }</p> <p>memories, response, event = manager.process_turn_with_llm(     actor_id=\"user-123\",     session_id=\"session-456\",     user_input=\"What did we discuss yesterday?\",     llm_callback=my_llm,     retrieval_config=retrieval_config )</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def process_turn_with_llm(\n    self,\n    actor_id: str,\n    session_id: str,\n    user_input: str,\n    llm_callback: Callable[[str, List[Dict[str, Any]]], str],\n    retrieval_config: Optional[Dict[str, RetrievalConfig]],\n    event_timestamp: Optional[datetime] = None,\n) -&gt; Tuple[List[Dict[str, Any]], str, Dict[str, Any]]:\n    r\"\"\"Complete conversation turn with LLM callback integration.\n\n    This method combines memory retrieval, LLM invocation, and response storage\n    in a single call using a callback pattern.\n\n    Args:\n        actor_id: Actor identifier (e.g., \"user-123\")\n        session_id: Session identifier\n        user_input: The user's message\n        llm_callback: Function that takes (user_input, memories) and returns agent_response\n                     The callback receives the user input and retrieved memories,\n                     and should return the agent's response string\n        retrieval_config: Optional dictionary mapping namespaces to RetrievalConfig objects.\n                        Each namespace can contain template variables like {actorId}, {sessionId},\n                        {memoryStrategyId} that will be resolved at runtime.\n        event_timestamp: Optional timestamp for the event\n\n    Returns:\n        Tuple of (retrieved_memories, agent_response, created_event)\n\n    Example:\n        from bedrock_agentcore.memory.constants import RetrievalConfig\n\n        def my_llm(user_input: str, memories: List[Dict]) -&gt; str:\n            # Format context from memories\n            context = \"\\\\n\".join([m.get('content', {}).get('text', '') for m in memories])\n\n            # Call your LLM (Bedrock, OpenAI, etc.)\n            response = bedrock.invoke_model(\n                messages=[\n                    {\"role\": \"system\", \"content\": f\"Context: {context}\"},\n                    {\"role\": \"user\", \"content\": user_input}\n                ]\n            )\n            return response['content']\n\n        retrieval_config = {\n            \"support/facts/{sessionId}\": RetrievalConfig(top_k=5, relevance_score=0.3),\n            \"user/preferences/{actorId}\": RetrievalConfig(top_k=3, relevance_score=0.5)\n        }\n\n        memories, response, event = manager.process_turn_with_llm(\n            actor_id=\"user-123\",\n            session_id=\"session-456\",\n            user_input=\"What did we discuss yesterday?\",\n            llm_callback=my_llm,\n            retrieval_config=retrieval_config\n        )\n    \"\"\"\n    # Step 1: Retrieve relevant memories\n    retrieved_memories = []\n    if retrieval_config:\n        for namespace, config in retrieval_config.items():\n            resolved_namespace = namespace.format(\n                actorId=actor_id,\n                sessionId=session_id,\n                strategyId=config.strategy_id or \"\",\n            )\n            search_query = f\"{config.retrieval_query} {user_input}\" if config.retrieval_query else user_input\n            memory_records = self.search_long_term_memories(\n                query=search_query, namespace_prefix=resolved_namespace, top_k=config.top_k\n            )\n            # Filter memory records with a relevance score which is lower than config.relevance_score\n            if config.relevance_score:\n                memory_records = [\n                    record\n                    for record in memory_records\n                    if record.get(\"relevanceScore\", config.relevance_score) &gt;= config.relevance_score\n                ]\n\n            retrieved_memories.extend(memory_records)\n\n    logger.info(\"Retrieved %d memories for LLM context\", len(retrieved_memories))\n\n    # Step 2: Invoke LLM callback\n    try:\n        agent_response = llm_callback(user_input, retrieved_memories)\n        if not isinstance(agent_response, str):\n            raise ValueError(\"LLM callback must return a string response\")\n        logger.info(\"LLM callback generated response\")\n    except Exception as e:\n        logger.error(\"LLM callback failed: %s\", e)\n        raise\n\n    # Step 3: Save the conversation turn\n    event = self.add_turns(\n        actor_id=actor_id,\n        session_id=session_id,\n        messages=[\n            ConversationalMessage(user_input, MessageRole.USER),\n            ConversationalMessage(agent_response, MessageRole.ASSISTANT),\n        ],\n        event_timestamp=event_timestamp,\n    )\n\n    logger.info(\"Completed full conversation turn with LLM\")\n    return retrieved_memories, agent_response, event\n</code></pre>"},{"location":"api-reference/memory.html#bedrock_agentcore.memory.MemorySessionManager.search_long_term_memories","title":"<code>search_long_term_memories(query, namespace_prefix, top_k=3, strategy_id=None, max_results=20)</code>","text":"<p>Performs a semantic search against the long-term memory for this actor.</p> <p>Maps to: bedrock-agentcore.retrieve_memory_records.</p> Source code in <code>bedrock_agentcore/memory/session.py</code> <pre><code>def search_long_term_memories(\n    self,\n    query: str,\n    namespace_prefix: str,\n    top_k: int = 3,\n    strategy_id: str = None,\n    max_results: int = 20,\n) -&gt; List[MemoryRecord]:\n    \"\"\"Performs a semantic search against the long-term memory for this actor.\n\n    Maps to: bedrock-agentcore.retrieve_memory_records.\n    \"\"\"\n    logger.info(\"  -&gt; Querying long-term memory in namespace '%s' with query: '%s'...\", namespace_prefix, query)\n    search_criteria = {\"searchQuery\": query, \"topK\": top_k}\n    if strategy_id:\n        search_criteria[\"strategyId\"] = strategy_id\n\n    namespace = namespace_prefix\n    params = {\n        \"memoryId\": self._memory_id,\n        \"searchCriteria\": search_criteria,\n        \"namespace\": namespace,\n        \"maxResults\": max_results,\n    }\n\n    try:\n        response = self._data_plane_client.retrieve_memory_records(**params)\n        records = response.get(\"memoryRecordSummaries\", [])\n        logger.info(\"     \u2705 Found %d relevant long-term records.\", len(records))\n        return [MemoryRecord(record) for record in records]\n    except ClientError as e:\n        logger.info(\"     \u274c Error querying long-term memory\", e)\n        raise\n</code></pre>"},{"location":"api-reference/runtime.html","title":"Runtime","text":"<p>Runtime management and application context for Bedrock AgentCore.</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime","title":"<code>bedrock_agentcore.runtime</code>","text":"<p>BedrockAgentCore Runtime Package.</p> <p>This package contains the core runtime components for Bedrock AgentCore applications: - BedrockAgentCoreApp: Main application class - RequestContext: HTTP request context - BedrockAgentCoreContext: Agent identity context</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp","title":"<code>BedrockAgentCoreApp</code>","text":"<p>               Bases: <code>Starlette</code></p> <p>Bedrock AgentCore application class that extends Starlette for AI agent deployment.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>class BedrockAgentCoreApp(Starlette):\n    \"\"\"Bedrock AgentCore application class that extends Starlette for AI agent deployment.\"\"\"\n\n    def __init__(self, debug: bool = False, lifespan: Optional[Lifespan] = None):\n        \"\"\"Initialize Bedrock AgentCore application.\n\n        Args:\n            debug: Enable debug actions for task management (default: False)\n            lifespan: Optional lifespan context manager for startup/shutdown\n        \"\"\"\n        self.handlers: Dict[str, Callable] = {}\n        self._ping_handler: Optional[Callable] = None\n        self._active_tasks: Dict[int, Dict[str, Any]] = {}\n        self._task_counter_lock: threading.Lock = threading.Lock()\n        self._forced_ping_status: Optional[PingStatus] = None\n        self._last_status_update_time: float = time.time()\n\n        routes = [\n            Route(\"/invocations\", self._handle_invocation, methods=[\"POST\"]),\n            Route(\"/ping\", self._handle_ping, methods=[\"GET\"]),\n        ]\n        super().__init__(routes=routes, lifespan=lifespan)\n        self.debug = debug  # Set after super().__init__ to avoid override\n\n        self.logger = logging.getLogger(\"bedrock_agentcore.app\")\n        if not self.logger.handlers:\n            handler = logging.StreamHandler()\n            formatter = RequestContextFormatter()\n            handler.setFormatter(formatter)\n            self.logger.addHandler(handler)\n            self.logger.setLevel(logging.DEBUG if self.debug else logging.INFO)\n\n    def entrypoint(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to register a function as the main entrypoint.\n\n        Args:\n            func: The function to register as entrypoint\n\n        Returns:\n            The decorated function with added serve method\n        \"\"\"\n        self.handlers[\"main\"] = func\n        func.run = lambda port=8080, host=None: self.run(port, host)\n        return func\n\n    def ping(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to register a custom ping status handler.\n\n        Args:\n            func: The function to register as ping status handler\n\n        Returns:\n            The decorated function\n        \"\"\"\n        self._ping_handler = func\n        return func\n\n    def async_task(self, func: Callable) -&gt; Callable:\n        \"\"\"Decorator to track async tasks for ping status.\n\n        When a function is decorated with @async_task, it will:\n        - Set ping status to HEALTHY_BUSY while running\n        - Revert to HEALTHY when complete\n        \"\"\"\n        if not asyncio.iscoroutinefunction(func):\n            raise ValueError(\"@async_task can only be applied to async functions\")\n\n        async def wrapper(*args, **kwargs):\n            task_id = self.add_async_task(func.__name__)\n\n            try:\n                self.logger.debug(\"Starting async task: %s\", func.__name__)\n                start_time = time.time()\n                result = await func(*args, **kwargs)\n                duration = time.time() - start_time\n                self.logger.info(\"Async task completed: %s (%.3fs)\", func.__name__, duration)\n                return result\n            except Exception:\n                duration = time.time() - start_time\n                self.logger.exception(\"Async task failed: %s (%.3fs)\", func.__name__, duration)\n                raise\n            finally:\n                self.complete_async_task(task_id)\n\n        wrapper.__name__ = func.__name__\n        return wrapper\n\n    def get_current_ping_status(self) -&gt; PingStatus:\n        \"\"\"Get current ping status (forced &gt; custom &gt; automatic).\"\"\"\n        current_status = None\n\n        if self._forced_ping_status is not None:\n            current_status = self._forced_ping_status\n        elif self._ping_handler:\n            try:\n                result = self._ping_handler()\n                if isinstance(result, str):\n                    current_status = PingStatus(result)\n                else:\n                    current_status = result\n            except Exception as e:\n                self.logger.warning(\n                    \"Custom ping handler failed, falling back to automatic: %s: %s\", type(e).__name__, e\n                )\n\n        if current_status is None:\n            current_status = PingStatus.HEALTHY_BUSY if self._active_tasks else PingStatus.HEALTHY\n        if not hasattr(self, \"_last_known_status\") or self._last_known_status != current_status:\n            self._last_known_status = current_status\n            self._last_status_update_time = time.time()\n\n        return current_status\n\n    def force_ping_status(self, status: PingStatus):\n        \"\"\"Force ping status to a specific value.\"\"\"\n        self._forced_ping_status = status\n\n    def clear_forced_ping_status(self):\n        \"\"\"Clear forced status and resume automatic.\"\"\"\n        self._forced_ping_status = None\n\n    def get_async_task_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Get info about running async tasks.\"\"\"\n        running_jobs = []\n        for t in self._active_tasks.values():\n            try:\n                running_jobs.append(\n                    {\"name\": t.get(\"name\", \"unknown\"), \"duration\": time.time() - t.get(\"start_time\", time.time())}\n                )\n            except Exception as e:\n                self.logger.warning(\"Caught exception, continuing...: %s\", e)\n                continue\n\n        return {\"active_count\": len(self._active_tasks), \"running_jobs\": running_jobs}\n\n    def add_async_task(self, name: str, metadata: Optional[Dict] = None) -&gt; int:\n        \"\"\"Register an async task for interactive health tracking.\n\n        This method provides granular control over async task lifecycle,\n        allowing developers to interactively start tracking tasks for health monitoring.\n        Use this when you need precise control over when tasks begin and end.\n\n        Args:\n            name: Human-readable task name for monitoring\n            metadata: Optional additional task metadata\n\n        Returns:\n            Task ID for tracking and completion\n\n        Example:\n            task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})\n            # ... do background work ...\n            app.complete_async_task(task_id)\n        \"\"\"\n        with self._task_counter_lock:\n            task_id = hash(str(uuid.uuid4()))  # Generate truly unique hash-based ID\n\n            # Register task start with same structure as @async_task decorator\n            task_info = {\"name\": name, \"start_time\": time.time()}\n            if metadata:\n                task_info[\"metadata\"] = metadata\n\n            self._active_tasks[task_id] = task_info\n\n        self.logger.info(\"Async task started: %s (ID: %s)\", name, task_id)\n        return task_id\n\n    def complete_async_task(self, task_id: int) -&gt; bool:\n        \"\"\"Mark an async task as complete for interactive health tracking.\n\n        This method provides granular control over async task lifecycle,\n        allowing developers to interactively complete tasks for health monitoring.\n        Call this when your background work finishes.\n\n        Args:\n            task_id: Task ID returned from add_async_task\n\n        Returns:\n            True if task was found and completed, False otherwise\n\n        Example:\n            task_id = app.add_async_task(\"file_processing\")\n            # ... do background work ...\n            completed = app.complete_async_task(task_id)\n        \"\"\"\n        with self._task_counter_lock:\n            task_info = self._active_tasks.pop(task_id, None)\n            if task_info:\n                task_name = task_info.get(\"name\", \"unknown\")\n                duration = time.time() - task_info.get(\"start_time\", time.time())\n\n                self.logger.info(\"Async task completed: %s (ID: %s, Duration: %.2fs)\", task_name, task_id, duration)\n                return True\n            else:\n                self.logger.warning(\"Attempted to complete unknown task ID: %s\", task_id)\n                return False\n\n    def _build_request_context(self, request) -&gt; RequestContext:\n        \"\"\"Build request context and setup all context variables.\"\"\"\n        try:\n            headers = request.headers\n            request_id = headers.get(REQUEST_ID_HEADER)\n            if not request_id:\n                request_id = str(uuid.uuid4())\n\n            session_id = headers.get(SESSION_HEADER)\n            BedrockAgentCoreContext.set_request_context(request_id, session_id)\n\n            agent_identity_token = headers.get(ACCESS_TOKEN_HEADER)\n            if agent_identity_token:\n                BedrockAgentCoreContext.set_workload_access_token(agent_identity_token)\n\n            # Collect relevant request headers (Authorization + Custom headers)\n            request_headers = {}\n\n            # Add Authorization header if present\n            authorization_header = headers.get(AUTHORIZATION_HEADER)\n            if authorization_header is not None:\n                request_headers[AUTHORIZATION_HEADER] = authorization_header\n\n            # Add custom headers with the specified prefix\n            for header_name, header_value in headers.items():\n                if header_name.lower().startswith(CUSTOM_HEADER_PREFIX.lower()):\n                    request_headers[header_name] = header_value\n\n            # Set in context if any headers were found\n            if request_headers:\n                BedrockAgentCoreContext.set_request_headers(request_headers)\n\n            # Get the headers from context to pass to RequestContext\n            req_headers = BedrockAgentCoreContext.get_request_headers()\n\n            return RequestContext(session_id=session_id, request_headers=req_headers)\n        except Exception as e:\n            self.logger.warning(\"Failed to build request context: %s: %s\", type(e).__name__, e)\n            request_id = str(uuid.uuid4())\n            BedrockAgentCoreContext.set_request_context(request_id, None)\n            return RequestContext(session_id=None)\n\n    def _takes_context(self, handler: Callable) -&gt; bool:\n        try:\n            params = list(inspect.signature(handler).parameters.keys())\n            return len(params) &gt;= 2 and params[1] == \"context\"\n        except Exception:\n            return False\n\n    async def _handle_invocation(self, request):\n        request_context = self._build_request_context(request)\n\n        start_time = time.time()\n\n        try:\n            payload = await request.json()\n            self.logger.debug(\"Processing invocation request\")\n\n            if self.debug:\n                task_response = self._handle_task_action(payload)\n                if task_response:\n                    duration = time.time() - start_time\n                    self.logger.info(\"Debug action completed (%.3fs)\", duration)\n                    return task_response\n\n            handler = self.handlers.get(\"main\")\n            if not handler:\n                self.logger.error(\"No entrypoint defined\")\n                return JSONResponse({\"error\": \"No entrypoint defined\"}, status_code=500)\n\n            takes_context = self._takes_context(handler)\n\n            handler_name = handler.__name__ if hasattr(handler, \"__name__\") else \"unknown\"\n            self.logger.debug(\"Invoking handler: %s\", handler_name)\n            result = await self._invoke_handler(handler, request_context, takes_context, payload)\n\n            duration = time.time() - start_time\n            if inspect.isgenerator(result):\n                self.logger.info(\"Returning streaming response (generator) (%.3fs)\", duration)\n                return StreamingResponse(self._sync_stream_with_error_handling(result), media_type=\"text/event-stream\")\n            elif inspect.isasyncgen(result):\n                self.logger.info(\"Returning streaming response (async generator) (%.3fs)\", duration)\n                return StreamingResponse(self._stream_with_error_handling(result), media_type=\"text/event-stream\")\n\n            self.logger.info(\"Invocation completed successfully (%.3fs)\", duration)\n            # Use safe serialization for consistency with streaming paths\n            safe_json_string = self._safe_serialize_to_json_string(result)\n            return Response(safe_json_string, media_type=\"application/json\")\n\n        except json.JSONDecodeError as e:\n            duration = time.time() - start_time\n            self.logger.warning(\"Invalid JSON in request (%.3fs): %s\", duration, e)\n            return JSONResponse({\"error\": \"Invalid JSON\", \"details\": str(e)}, status_code=400)\n        except Exception as e:\n            duration = time.time() - start_time\n            self.logger.exception(\"Invocation failed (%.3fs)\", duration)\n            return JSONResponse({\"error\": str(e)}, status_code=500)\n\n    def _handle_ping(self, request):\n        try:\n            status = self.get_current_ping_status()\n            self.logger.debug(\"Ping request - status: %s\", status.value)\n            return JSONResponse({\"status\": status.value, \"time_of_last_update\": int(self._last_status_update_time)})\n        except Exception:\n            self.logger.exception(\"Ping endpoint failed\")\n            return JSONResponse({\"status\": PingStatus.HEALTHY.value, \"time_of_last_update\": int(time.time())})\n\n    def run(self, port: int = 8080, host: Optional[str] = None, **kwargs):\n        \"\"\"Start the Bedrock AgentCore server.\n\n        Args:\n            port: Port to serve on, defaults to 8080\n            host: Host to bind to, auto-detected if None\n            **kwargs: Additional arguments passed to uvicorn.run()\n        \"\"\"\n        import os\n\n        import uvicorn\n\n        if host is None:\n            if os.path.exists(\"/.dockerenv\") or os.environ.get(\"DOCKER_CONTAINER\"):\n                host = \"0.0.0.0\"  # nosec B104 - Docker needs this to expose the port\n            else:\n                host = \"127.0.0.1\"\n\n        # Set default uvicorn parameters, allow kwargs to override\n        uvicorn_params = {\n            \"host\": host,\n            \"port\": port,\n            \"access_log\": self.debug,\n            \"log_level\": \"info\" if self.debug else \"warning\",\n        }\n        uvicorn_params.update(kwargs)\n\n        uvicorn.run(self, **uvicorn_params)\n\n    async def _invoke_handler(self, handler, request_context, takes_context, payload):\n        try:\n            args = (payload, request_context) if takes_context else (payload,)\n\n            if asyncio.iscoroutinefunction(handler):\n                return await handler(*args)\n            else:\n                loop = asyncio.get_event_loop()\n                ctx = contextvars.copy_context()\n                return await loop.run_in_executor(None, ctx.run, handler, *args)\n        except Exception:\n            handler_name = getattr(handler, \"__name__\", \"unknown\")\n            self.logger.debug(\"Handler '%s' execution failed\", handler_name)\n            raise\n\n    def _handle_task_action(self, payload: dict) -&gt; Optional[JSONResponse]:\n        \"\"\"Handle task management actions if present in payload.\"\"\"\n        action = payload.get(\"_agent_core_app_action\")\n        if not action:\n            return None\n\n        self.logger.debug(\"Processing debug action: %s\", action)\n\n        try:\n            actions = {\n                TASK_ACTION_PING_STATUS: lambda: JSONResponse(\n                    {\n                        \"status\": self.get_current_ping_status().value,\n                        \"time_of_last_update\": int(self._last_status_update_time),\n                    }\n                ),\n                TASK_ACTION_JOB_STATUS: lambda: JSONResponse(self.get_async_task_info()),\n                TASK_ACTION_FORCE_HEALTHY: lambda: (\n                    self.force_ping_status(PingStatus.HEALTHY),\n                    self.logger.info(\"Ping status forced to Healthy\"),\n                    JSONResponse({\"forced_status\": \"Healthy\"}),\n                )[2],\n                TASK_ACTION_FORCE_BUSY: lambda: (\n                    self.force_ping_status(PingStatus.HEALTHY_BUSY),\n                    self.logger.info(\"Ping status forced to HealthyBusy\"),\n                    JSONResponse({\"forced_status\": \"HealthyBusy\"}),\n                )[2],\n                TASK_ACTION_CLEAR_FORCED_STATUS: lambda: (\n                    self.clear_forced_ping_status(),\n                    self.logger.info(\"Forced ping status cleared\"),\n                    JSONResponse({\"forced_status\": \"Cleared\"}),\n                )[2],\n            }\n\n            if action in actions:\n                response = actions[action]()\n                self.logger.debug(\"Debug action '%s' completed successfully\", action)\n                return response\n\n            self.logger.warning(\"Unknown debug action requested: %s\", action)\n            return JSONResponse({\"error\": f\"Unknown action: {action}\"}, status_code=400)\n\n        except Exception as e:\n            self.logger.exception(\"Debug action '%s' failed\", action)\n            return JSONResponse({\"error\": \"Debug action failed\", \"details\": str(e)}, status_code=500)\n\n    async def _stream_with_error_handling(self, generator):\n        \"\"\"Wrap async generator to handle errors and convert to SSE format.\"\"\"\n        try:\n            async for value in generator:\n                yield self._convert_to_sse(value)\n        except Exception as e:\n            self.logger.exception(\"Error in async streaming\")\n            error_event = {\n                \"error\": str(e),\n                \"error_type\": type(e).__name__,\n                \"message\": \"An error occurred during streaming\",\n            }\n            yield self._convert_to_sse(error_event)\n\n    def _safe_serialize_to_json_string(self, obj):\n        \"\"\"Safely serialize object directly to JSON string with progressive fallback handling.\n\n        This method eliminates double JSON encoding by returning the JSON string directly,\n        avoiding the test-then-encode pattern that leads to redundant json.dumps() calls.\n        Used by both streaming and non-streaming responses for consistent behavior.\n\n        Returns:\n            str: JSON string representation of the object\n        \"\"\"\n        try:\n            # First attempt: direct JSON serialization with Unicode support\n            return json.dumps(obj, ensure_ascii=False)\n        except (TypeError, ValueError, UnicodeEncodeError):\n            try:\n                # Second attempt: convert to serializable dictionaries, then JSON encode the dictionaries\n                converted_obj = convert_complex_objects(obj)\n                return json.dumps(converted_obj, ensure_ascii=False)\n            except Exception:\n                try:\n                    # Third attempt: convert to string, then JSON encode the string\n                    return json.dumps(str(obj), ensure_ascii=False)\n                except Exception as e:\n                    # Final fallback: JSON encode error object with ASCII fallback for problematic Unicode\n                    self.logger.warning(\"Failed to serialize object: %s: %s\", type(e).__name__, e)\n                    error_obj = {\"error\": \"Serialization failed\", \"original_type\": type(obj).__name__}\n                    return json.dumps(error_obj, ensure_ascii=False)\n\n    def _convert_to_sse(self, obj) -&gt; bytes:\n        \"\"\"Convert object to Server-Sent Events format using safe serialization.\n\n        Args:\n            obj: Object to convert to SSE format\n\n        Returns:\n            bytes: SSE-formatted data ready for streaming\n        \"\"\"\n        json_string = self._safe_serialize_to_json_string(obj)\n        sse_data = f\"data: {json_string}\\n\\n\"\n        return sse_data.encode(\"utf-8\")\n\n    def _sync_stream_with_error_handling(self, generator):\n        \"\"\"Wrap sync generator to handle errors and convert to SSE format.\"\"\"\n        try:\n            for value in generator:\n                yield self._convert_to_sse(value)\n        except Exception as e:\n            self.logger.exception(\"Error in sync streaming\")\n            error_event = {\n                \"error\": str(e),\n                \"error_type\": type(e).__name__,\n                \"message\": \"An error occurred during streaming\",\n            }\n            yield self._convert_to_sse(error_event)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.__init__","title":"<code>__init__(debug=False, lifespan=None)</code>","text":"<p>Initialize Bedrock AgentCore application.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Enable debug actions for task management (default: False)</p> <code>False</code> <code>lifespan</code> <code>Optional[Lifespan]</code> <p>Optional lifespan context manager for startup/shutdown</p> <code>None</code> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def __init__(self, debug: bool = False, lifespan: Optional[Lifespan] = None):\n    \"\"\"Initialize Bedrock AgentCore application.\n\n    Args:\n        debug: Enable debug actions for task management (default: False)\n        lifespan: Optional lifespan context manager for startup/shutdown\n    \"\"\"\n    self.handlers: Dict[str, Callable] = {}\n    self._ping_handler: Optional[Callable] = None\n    self._active_tasks: Dict[int, Dict[str, Any]] = {}\n    self._task_counter_lock: threading.Lock = threading.Lock()\n    self._forced_ping_status: Optional[PingStatus] = None\n    self._last_status_update_time: float = time.time()\n\n    routes = [\n        Route(\"/invocations\", self._handle_invocation, methods=[\"POST\"]),\n        Route(\"/ping\", self._handle_ping, methods=[\"GET\"]),\n    ]\n    super().__init__(routes=routes, lifespan=lifespan)\n    self.debug = debug  # Set after super().__init__ to avoid override\n\n    self.logger = logging.getLogger(\"bedrock_agentcore.app\")\n    if not self.logger.handlers:\n        handler = logging.StreamHandler()\n        formatter = RequestContextFormatter()\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.DEBUG if self.debug else logging.INFO)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.add_async_task","title":"<code>add_async_task(name, metadata=None)</code>","text":"<p>Register an async task for interactive health tracking.</p> <p>This method provides granular control over async task lifecycle, allowing developers to interactively start tracking tasks for health monitoring. Use this when you need precise control over when tasks begin and end.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable task name for monitoring</p> required <code>metadata</code> <code>Optional[Dict]</code> <p>Optional additional task metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Task ID for tracking and completion</p> Example <p>task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def add_async_task(self, name: str, metadata: Optional[Dict] = None) -&gt; int:\n    \"\"\"Register an async task for interactive health tracking.\n\n    This method provides granular control over async task lifecycle,\n    allowing developers to interactively start tracking tasks for health monitoring.\n    Use this when you need precise control over when tasks begin and end.\n\n    Args:\n        name: Human-readable task name for monitoring\n        metadata: Optional additional task metadata\n\n    Returns:\n        Task ID for tracking and completion\n\n    Example:\n        task_id = app.add_async_task(\"file_processing\", {\"file\": \"data.csv\"})\n        # ... do background work ...\n        app.complete_async_task(task_id)\n    \"\"\"\n    with self._task_counter_lock:\n        task_id = hash(str(uuid.uuid4()))  # Generate truly unique hash-based ID\n\n        # Register task start with same structure as @async_task decorator\n        task_info = {\"name\": name, \"start_time\": time.time()}\n        if metadata:\n            task_info[\"metadata\"] = metadata\n\n        self._active_tasks[task_id] = task_info\n\n    self.logger.info(\"Async task started: %s (ID: %s)\", name, task_id)\n    return task_id\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.add_async_task--do-background-work","title":"... do background work ...","text":"<p>app.complete_async_task(task_id)</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.async_task","title":"<code>async_task(func)</code>","text":"<p>Decorator to track async tasks for ping status.</p> <p>When a function is decorated with @async_task, it will: - Set ping status to HEALTHY_BUSY while running - Revert to HEALTHY when complete</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def async_task(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to track async tasks for ping status.\n\n    When a function is decorated with @async_task, it will:\n    - Set ping status to HEALTHY_BUSY while running\n    - Revert to HEALTHY when complete\n    \"\"\"\n    if not asyncio.iscoroutinefunction(func):\n        raise ValueError(\"@async_task can only be applied to async functions\")\n\n    async def wrapper(*args, **kwargs):\n        task_id = self.add_async_task(func.__name__)\n\n        try:\n            self.logger.debug(\"Starting async task: %s\", func.__name__)\n            start_time = time.time()\n            result = await func(*args, **kwargs)\n            duration = time.time() - start_time\n            self.logger.info(\"Async task completed: %s (%.3fs)\", func.__name__, duration)\n            return result\n        except Exception:\n            duration = time.time() - start_time\n            self.logger.exception(\"Async task failed: %s (%.3fs)\", func.__name__, duration)\n            raise\n        finally:\n            self.complete_async_task(task_id)\n\n    wrapper.__name__ = func.__name__\n    return wrapper\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.clear_forced_ping_status","title":"<code>clear_forced_ping_status()</code>","text":"<p>Clear forced status and resume automatic.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def clear_forced_ping_status(self):\n    \"\"\"Clear forced status and resume automatic.\"\"\"\n    self._forced_ping_status = None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.complete_async_task","title":"<code>complete_async_task(task_id)</code>","text":"<p>Mark an async task as complete for interactive health tracking.</p> <p>This method provides granular control over async task lifecycle, allowing developers to interactively complete tasks for health monitoring. Call this when your background work finishes.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>Task ID returned from add_async_task</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if task was found and completed, False otherwise</p> Example <p>task_id = app.add_async_task(\"file_processing\")</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def complete_async_task(self, task_id: int) -&gt; bool:\n    \"\"\"Mark an async task as complete for interactive health tracking.\n\n    This method provides granular control over async task lifecycle,\n    allowing developers to interactively complete tasks for health monitoring.\n    Call this when your background work finishes.\n\n    Args:\n        task_id: Task ID returned from add_async_task\n\n    Returns:\n        True if task was found and completed, False otherwise\n\n    Example:\n        task_id = app.add_async_task(\"file_processing\")\n        # ... do background work ...\n        completed = app.complete_async_task(task_id)\n    \"\"\"\n    with self._task_counter_lock:\n        task_info = self._active_tasks.pop(task_id, None)\n        if task_info:\n            task_name = task_info.get(\"name\", \"unknown\")\n            duration = time.time() - task_info.get(\"start_time\", time.time())\n\n            self.logger.info(\"Async task completed: %s (ID: %s, Duration: %.2fs)\", task_name, task_id, duration)\n            return True\n        else:\n            self.logger.warning(\"Attempted to complete unknown task ID: %s\", task_id)\n            return False\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.complete_async_task--do-background-work","title":"... do background work ...","text":"<p>completed = app.complete_async_task(task_id)</p>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.entrypoint","title":"<code>entrypoint(func)</code>","text":"<p>Decorator to register a function as the main entrypoint.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to register as entrypoint</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function with added serve method</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def entrypoint(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to register a function as the main entrypoint.\n\n    Args:\n        func: The function to register as entrypoint\n\n    Returns:\n        The decorated function with added serve method\n    \"\"\"\n    self.handlers[\"main\"] = func\n    func.run = lambda port=8080, host=None: self.run(port, host)\n    return func\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.force_ping_status","title":"<code>force_ping_status(status)</code>","text":"<p>Force ping status to a specific value.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def force_ping_status(self, status: PingStatus):\n    \"\"\"Force ping status to a specific value.\"\"\"\n    self._forced_ping_status = status\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.get_async_task_info","title":"<code>get_async_task_info()</code>","text":"<p>Get info about running async tasks.</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def get_async_task_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get info about running async tasks.\"\"\"\n    running_jobs = []\n    for t in self._active_tasks.values():\n        try:\n            running_jobs.append(\n                {\"name\": t.get(\"name\", \"unknown\"), \"duration\": time.time() - t.get(\"start_time\", time.time())}\n            )\n        except Exception as e:\n            self.logger.warning(\"Caught exception, continuing...: %s\", e)\n            continue\n\n    return {\"active_count\": len(self._active_tasks), \"running_jobs\": running_jobs}\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.get_current_ping_status","title":"<code>get_current_ping_status()</code>","text":"<p>Get current ping status (forced &gt; custom &gt; automatic).</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def get_current_ping_status(self) -&gt; PingStatus:\n    \"\"\"Get current ping status (forced &gt; custom &gt; automatic).\"\"\"\n    current_status = None\n\n    if self._forced_ping_status is not None:\n        current_status = self._forced_ping_status\n    elif self._ping_handler:\n        try:\n            result = self._ping_handler()\n            if isinstance(result, str):\n                current_status = PingStatus(result)\n            else:\n                current_status = result\n        except Exception as e:\n            self.logger.warning(\n                \"Custom ping handler failed, falling back to automatic: %s: %s\", type(e).__name__, e\n            )\n\n    if current_status is None:\n        current_status = PingStatus.HEALTHY_BUSY if self._active_tasks else PingStatus.HEALTHY\n    if not hasattr(self, \"_last_known_status\") or self._last_known_status != current_status:\n        self._last_known_status = current_status\n        self._last_status_update_time = time.time()\n\n    return current_status\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.ping","title":"<code>ping(func)</code>","text":"<p>Decorator to register a custom ping status handler.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to register as ping status handler</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function</p> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def ping(self, func: Callable) -&gt; Callable:\n    \"\"\"Decorator to register a custom ping status handler.\n\n    Args:\n        func: The function to register as ping status handler\n\n    Returns:\n        The decorated function\n    \"\"\"\n    self._ping_handler = func\n    return func\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreApp.run","title":"<code>run(port=8080, host=None, **kwargs)</code>","text":"<p>Start the Bedrock AgentCore server.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to serve on, defaults to 8080</p> <code>8080</code> <code>host</code> <code>Optional[str]</code> <p>Host to bind to, auto-detected if None</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments passed to uvicorn.run()</p> <code>{}</code> Source code in <code>bedrock_agentcore/runtime/app.py</code> <pre><code>def run(self, port: int = 8080, host: Optional[str] = None, **kwargs):\n    \"\"\"Start the Bedrock AgentCore server.\n\n    Args:\n        port: Port to serve on, defaults to 8080\n        host: Host to bind to, auto-detected if None\n        **kwargs: Additional arguments passed to uvicorn.run()\n    \"\"\"\n    import os\n\n    import uvicorn\n\n    if host is None:\n        if os.path.exists(\"/.dockerenv\") or os.environ.get(\"DOCKER_CONTAINER\"):\n            host = \"0.0.0.0\"  # nosec B104 - Docker needs this to expose the port\n        else:\n            host = \"127.0.0.1\"\n\n    # Set default uvicorn parameters, allow kwargs to override\n    uvicorn_params = {\n        \"host\": host,\n        \"port\": port,\n        \"access_log\": self.debug,\n        \"log_level\": \"info\" if self.debug else \"warning\",\n    }\n    uvicorn_params.update(kwargs)\n\n    uvicorn.run(self, **uvicorn_params)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext","title":"<code>BedrockAgentCoreContext</code>","text":"<p>Unified context manager for Bedrock AgentCore.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>class BedrockAgentCoreContext:\n    \"\"\"Unified context manager for Bedrock AgentCore.\"\"\"\n\n    _workload_access_token: ContextVar[Optional[str]] = ContextVar(\"workload_access_token\")\n    _request_id: ContextVar[Optional[str]] = ContextVar(\"request_id\")\n    _session_id: ContextVar[Optional[str]] = ContextVar(\"session_id\")\n    _request_headers: ContextVar[Optional[Dict[str, str]]] = ContextVar(\"request_headers\")\n\n    @classmethod\n    def set_workload_access_token(cls, token: str):\n        \"\"\"Set the workload access token in the context.\"\"\"\n        cls._workload_access_token.set(token)\n\n    @classmethod\n    def get_workload_access_token(cls) -&gt; Optional[str]:\n        \"\"\"Get the workload access token from the context.\"\"\"\n        try:\n            return cls._workload_access_token.get()\n        except LookupError:\n            return None\n\n    @classmethod\n    def set_request_context(cls, request_id: str, session_id: Optional[str] = None):\n        \"\"\"Set request-scoped identifiers.\"\"\"\n        cls._request_id.set(request_id)\n        cls._session_id.set(session_id)\n\n    @classmethod\n    def get_request_id(cls) -&gt; Optional[str]:\n        \"\"\"Get current request ID.\"\"\"\n        try:\n            return cls._request_id.get()\n        except LookupError:\n            return None\n\n    @classmethod\n    def get_session_id(cls) -&gt; Optional[str]:\n        \"\"\"Get current session ID.\"\"\"\n        try:\n            return cls._session_id.get()\n        except LookupError:\n            return None\n\n    @classmethod\n    def set_request_headers(cls, headers: Dict[str, str]):\n        \"\"\"Set request headers in the context.\"\"\"\n        cls._request_headers.set(headers)\n\n    @classmethod\n    def get_request_headers(cls) -&gt; Optional[Dict[str, str]]:\n        \"\"\"Get request headers from the context.\"\"\"\n        try:\n            return cls._request_headers.get()\n        except LookupError:\n            return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.get_request_headers","title":"<code>get_request_headers()</code>  <code>classmethod</code>","text":"<p>Get request headers from the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef get_request_headers(cls) -&gt; Optional[Dict[str, str]]:\n    \"\"\"Get request headers from the context.\"\"\"\n    try:\n        return cls._request_headers.get()\n    except LookupError:\n        return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.get_request_id","title":"<code>get_request_id()</code>  <code>classmethod</code>","text":"<p>Get current request ID.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef get_request_id(cls) -&gt; Optional[str]:\n    \"\"\"Get current request ID.\"\"\"\n    try:\n        return cls._request_id.get()\n    except LookupError:\n        return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.get_session_id","title":"<code>get_session_id()</code>  <code>classmethod</code>","text":"<p>Get current session ID.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef get_session_id(cls) -&gt; Optional[str]:\n    \"\"\"Get current session ID.\"\"\"\n    try:\n        return cls._session_id.get()\n    except LookupError:\n        return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.get_workload_access_token","title":"<code>get_workload_access_token()</code>  <code>classmethod</code>","text":"<p>Get the workload access token from the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef get_workload_access_token(cls) -&gt; Optional[str]:\n    \"\"\"Get the workload access token from the context.\"\"\"\n    try:\n        return cls._workload_access_token.get()\n    except LookupError:\n        return None\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.set_request_context","title":"<code>set_request_context(request_id, session_id=None)</code>  <code>classmethod</code>","text":"<p>Set request-scoped identifiers.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef set_request_context(cls, request_id: str, session_id: Optional[str] = None):\n    \"\"\"Set request-scoped identifiers.\"\"\"\n    cls._request_id.set(request_id)\n    cls._session_id.set(session_id)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.set_request_headers","title":"<code>set_request_headers(headers)</code>  <code>classmethod</code>","text":"<p>Set request headers in the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef set_request_headers(cls, headers: Dict[str, str]):\n    \"\"\"Set request headers in the context.\"\"\"\n    cls._request_headers.set(headers)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.BedrockAgentCoreContext.set_workload_access_token","title":"<code>set_workload_access_token(token)</code>  <code>classmethod</code>","text":"<p>Set the workload access token in the context.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>@classmethod\ndef set_workload_access_token(cls, token: str):\n    \"\"\"Set the workload access token in the context.\"\"\"\n    cls._workload_access_token.set(token)\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.PingStatus","title":"<code>PingStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Ping status enum for health check responses.</p> Source code in <code>bedrock_agentcore/runtime/models.py</code> <pre><code>class PingStatus(str, Enum):\n    \"\"\"Ping status enum for health check responses.\"\"\"\n\n    HEALTHY = \"Healthy\"\n    HEALTHY_BUSY = \"HealthyBusy\"\n</code></pre>"},{"location":"api-reference/runtime.html#bedrock_agentcore.runtime.RequestContext","title":"<code>RequestContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request context containing metadata from HTTP requests.</p> Source code in <code>bedrock_agentcore/runtime/context.py</code> <pre><code>class RequestContext(BaseModel):\n    \"\"\"Request context containing metadata from HTTP requests.\"\"\"\n\n    session_id: Optional[str] = Field(None)\n    request_headers: Optional[Dict[str, str]] = Field(None)\n</code></pre>"},{"location":"api-reference/tools.html","title":"Tools","text":"<p>Tools and utilities for Bedrock AgentCore SDK including browser and code interpreter tools.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client","title":"<code>bedrock_agentcore.tools.code_interpreter_client</code>","text":"<p>Client for interacting with the Code Interpreter sandbox service.</p> <p>This module provides a client for the AWS Code Interpreter sandbox, allowing applications to start, stop, and invoke code execution in a managed sandbox environment.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter","title":"<code>CodeInterpreter</code>","text":"<p>Client for interacting with the AWS Code Interpreter sandbox service.</p> <p>This client handles the session lifecycle and method invocation for Code Interpreter sandboxes, providing an interface to execute code in a secure, managed environment.</p> <p>Attributes:</p> Name Type Description <code>data_plane_service_name</code> <code>str</code> <p>AWS service name for the data plane.</p> <code>client</code> <p>The boto3 client for interacting with the service.</p> <code>identifier</code> <code>str</code> <p>The code interpreter identifier.</p> <code>session_id</code> <code>str</code> <p>The active session ID.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>class CodeInterpreter:\n    \"\"\"Client for interacting with the AWS Code Interpreter sandbox service.\n\n    This client handles the session lifecycle and method invocation for\n    Code Interpreter sandboxes, providing an interface to execute code\n    in a secure, managed environment.\n\n    Attributes:\n        data_plane_service_name (str): AWS service name for the data plane.\n        client: The boto3 client for interacting with the service.\n        identifier (str, optional): The code interpreter identifier.\n        session_id (str, optional): The active session ID.\n    \"\"\"\n\n    def __init__(self, region: str, session: Optional[boto3.Session] = None) -&gt; None:\n        \"\"\"Initialize a Code Interpreter client for the specified AWS region.\n\n        Args:\n            region (str): The AWS region to use for the Code Interpreter service.\n            session (Optional[boto3.Session]): Optional boto3 session to use.\n                If not provided, a new session will be created. This is useful\n                for cases where you need to use custom credentials or assume roles.\n        \"\"\"\n        self.data_plane_service_name = \"bedrock-agentcore\"\n        if session is None:\n            session = boto3.Session()\n        self.client = session.client(\n            self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self._identifier = None\n        self._session_id = None\n\n    @property\n    def identifier(self) -&gt; Optional[str]:\n        \"\"\"Get the current code interpreter identifier.\n\n        Returns:\n            Optional[str]: The current identifier or None if not set.\n        \"\"\"\n        return self._identifier\n\n    @identifier.setter\n    def identifier(self, value: Optional[str]):\n        \"\"\"Set the code interpreter identifier.\n\n        Args:\n            value (Optional[str]): The identifier to set.\n        \"\"\"\n        self._identifier = value\n\n    @property\n    def session_id(self) -&gt; Optional[str]:\n        \"\"\"Get the current session ID.\n\n        Returns:\n            Optional[str]: The current session ID or None if not set.\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, value: Optional[str]):\n        \"\"\"Set the session ID.\n\n        Args:\n            value (Optional[str]): The session ID to set.\n        \"\"\"\n        self._session_id = value\n\n    def start(\n        self,\n        identifier: Optional[str] = DEFAULT_IDENTIFIER,\n        name: Optional[str] = None,\n        session_timeout_seconds: Optional[int] = DEFAULT_TIMEOUT,\n    ) -&gt; str:\n        \"\"\"Start a code interpreter sandbox session.\n\n        This method initializes a new code interpreter session with the provided parameters.\n\n        Args:\n            identifier (Optional[str]): The code interpreter sandbox identifier to use.\n                Defaults to DEFAULT_IDENTIFIER.\n            name (Optional[str]): A name for this session. If not provided, a name\n                will be generated using a UUID.\n            session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n                Defaults to DEFAULT_TIMEOUT.\n            description (Optional[str]): A description for this session.\n                Defaults to an empty string.\n\n        Returns:\n            str: The session ID of the newly created session.\n        \"\"\"\n        response = self.client.start_code_interpreter_session(\n            codeInterpreterIdentifier=identifier,\n            name=name or f\"code-session-{uuid.uuid4().hex[:8]}\",\n            sessionTimeoutSeconds=session_timeout_seconds,\n        )\n\n        self.identifier = response[\"codeInterpreterIdentifier\"]\n        self.session_id = response[\"sessionId\"]\n\n        return self.session_id\n\n    def stop(self):\n        \"\"\"Stop the current code interpreter session if one is active.\n\n        This method stops any active session and clears the session state.\n        If no session is active, this method does nothing.\n\n        Returns:\n            bool: True if no session was active or the session was successfully stopped.\n        \"\"\"\n        if not self.session_id or not self.identifier:\n            return True\n\n        self.client.stop_code_interpreter_session(\n            **{\"codeInterpreterIdentifier\": self.identifier, \"sessionId\": self.session_id}\n        )\n\n        self.identifier = None\n        self.session_id = None\n\n    def invoke(self, method: str, params: Optional[Dict] = None):\n        \"\"\"Invoke a method in the code interpreter sandbox.\n\n        If no session is active, this method automatically starts a new session\n        before invoking the requested method.\n\n        Args:\n            method (str): The name of the method to invoke in the sandbox.\n            params (Optional[Dict]): Parameters to pass to the method. Defaults to None.\n            request_id (Optional[str]): A custom request ID. If not provided, a unique ID is generated.\n\n        Returns:\n            dict: The response from the code interpreter service.\n        \"\"\"\n        if not self.session_id or not self.identifier:\n            self.start()\n\n        return self.client.invoke_code_interpreter(\n            **{\n                \"codeInterpreterIdentifier\": self.identifier,\n                \"sessionId\": self.session_id,\n                \"name\": method,\n                \"arguments\": params or {},\n            }\n        )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.identifier","title":"<code>identifier</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current code interpreter identifier.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current identifier or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.session_id","title":"<code>session_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current session ID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current session ID or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.__init__","title":"<code>__init__(region, session=None)</code>","text":"<p>Initialize a Code Interpreter client for the specified AWS region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Code Interpreter service.</p> required <code>session</code> <code>Optional[Session]</code> <p>Optional boto3 session to use. If not provided, a new session will be created. This is useful for cases where you need to use custom credentials or assume roles.</p> <code>None</code> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def __init__(self, region: str, session: Optional[boto3.Session] = None) -&gt; None:\n    \"\"\"Initialize a Code Interpreter client for the specified AWS region.\n\n    Args:\n        region (str): The AWS region to use for the Code Interpreter service.\n        session (Optional[boto3.Session]): Optional boto3 session to use.\n            If not provided, a new session will be created. This is useful\n            for cases where you need to use custom credentials or assume roles.\n    \"\"\"\n    self.data_plane_service_name = \"bedrock-agentcore\"\n    if session is None:\n        session = boto3.Session()\n    self.client = session.client(\n        self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self._identifier = None\n    self._session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.invoke","title":"<code>invoke(method, params=None)</code>","text":"<p>Invoke a method in the code interpreter sandbox.</p> <p>If no session is active, this method automatically starts a new session before invoking the requested method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The name of the method to invoke in the sandbox.</p> required <code>params</code> <code>Optional[Dict]</code> <p>Parameters to pass to the method. Defaults to None.</p> <code>None</code> <code>request_id</code> <code>Optional[str]</code> <p>A custom request ID. If not provided, a unique ID is generated.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the code interpreter service.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def invoke(self, method: str, params: Optional[Dict] = None):\n    \"\"\"Invoke a method in the code interpreter sandbox.\n\n    If no session is active, this method automatically starts a new session\n    before invoking the requested method.\n\n    Args:\n        method (str): The name of the method to invoke in the sandbox.\n        params (Optional[Dict]): Parameters to pass to the method. Defaults to None.\n        request_id (Optional[str]): A custom request ID. If not provided, a unique ID is generated.\n\n    Returns:\n        dict: The response from the code interpreter service.\n    \"\"\"\n    if not self.session_id or not self.identifier:\n        self.start()\n\n    return self.client.invoke_code_interpreter(\n        **{\n            \"codeInterpreterIdentifier\": self.identifier,\n            \"sessionId\": self.session_id,\n            \"name\": method,\n            \"arguments\": params or {},\n        }\n    )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.start","title":"<code>start(identifier=DEFAULT_IDENTIFIER, name=None, session_timeout_seconds=DEFAULT_TIMEOUT)</code>","text":"<p>Start a code interpreter sandbox session.</p> <p>This method initializes a new code interpreter session with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Optional[str]</code> <p>The code interpreter sandbox identifier to use. Defaults to DEFAULT_IDENTIFIER.</p> <code>DEFAULT_IDENTIFIER</code> <code>name</code> <code>Optional[str]</code> <p>A name for this session. If not provided, a name will be generated using a UUID.</p> <code>None</code> <code>session_timeout_seconds</code> <code>Optional[int]</code> <p>The timeout for the session in seconds. Defaults to DEFAULT_TIMEOUT.</p> <code>DEFAULT_TIMEOUT</code> <code>description</code> <code>Optional[str]</code> <p>A description for this session. Defaults to an empty string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session ID of the newly created session.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def start(\n    self,\n    identifier: Optional[str] = DEFAULT_IDENTIFIER,\n    name: Optional[str] = None,\n    session_timeout_seconds: Optional[int] = DEFAULT_TIMEOUT,\n) -&gt; str:\n    \"\"\"Start a code interpreter sandbox session.\n\n    This method initializes a new code interpreter session with the provided parameters.\n\n    Args:\n        identifier (Optional[str]): The code interpreter sandbox identifier to use.\n            Defaults to DEFAULT_IDENTIFIER.\n        name (Optional[str]): A name for this session. If not provided, a name\n            will be generated using a UUID.\n        session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n            Defaults to DEFAULT_TIMEOUT.\n        description (Optional[str]): A description for this session.\n            Defaults to an empty string.\n\n    Returns:\n        str: The session ID of the newly created session.\n    \"\"\"\n    response = self.client.start_code_interpreter_session(\n        codeInterpreterIdentifier=identifier,\n        name=name or f\"code-session-{uuid.uuid4().hex[:8]}\",\n        sessionTimeoutSeconds=session_timeout_seconds,\n    )\n\n    self.identifier = response[\"codeInterpreterIdentifier\"]\n    self.session_id = response[\"sessionId\"]\n\n    return self.session_id\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.CodeInterpreter.stop","title":"<code>stop()</code>","text":"<p>Stop the current code interpreter session if one is active.</p> <p>This method stops any active session and clears the session state. If no session is active, this method does nothing.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if no session was active or the session was successfully stopped.</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the current code interpreter session if one is active.\n\n    This method stops any active session and clears the session state.\n    If no session is active, this method does nothing.\n\n    Returns:\n        bool: True if no session was active or the session was successfully stopped.\n    \"\"\"\n    if not self.session_id or not self.identifier:\n        return True\n\n    self.client.stop_code_interpreter_session(\n        **{\"codeInterpreterIdentifier\": self.identifier, \"sessionId\": self.session_id}\n    )\n\n    self.identifier = None\n    self.session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.code_interpreter_client.code_session","title":"<code>code_session(region, session=None)</code>","text":"<p>Context manager for creating and managing a code interpreter session.</p> <p>This context manager handles creating a client, starting a session, and ensuring the session is properly cleaned up when the context exits.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Code Interpreter service.</p> required <code>session</code> <code>Optional[Session]</code> <p>Optional boto3 session to use. If not provided, a new session will be created.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>CodeInterpreter</code> <code>CodeInterpreter</code> <p>An initialized and started code interpreter client.</p> Example <p>with code_session('us-west-2') as client: ...     result = client.invoke('listFiles') ...     # Process result here</p> Source code in <code>bedrock_agentcore/tools/code_interpreter_client.py</code> <pre><code>@contextmanager\ndef code_session(region: str, session: Optional[boto3.Session] = None) -&gt; Generator[CodeInterpreter, None, None]:\n    \"\"\"Context manager for creating and managing a code interpreter session.\n\n    This context manager handles creating a client, starting a session, and\n    ensuring the session is properly cleaned up when the context exits.\n\n    Args:\n        region (str): The AWS region to use for the Code Interpreter service.\n        session (Optional[boto3.Session]): Optional boto3 session to use.\n            If not provided, a new session will be created.\n\n    Yields:\n        CodeInterpreter: An initialized and started code interpreter client.\n\n    Example:\n        &gt;&gt;&gt; with code_session('us-west-2') as client:\n        ...     result = client.invoke('listFiles')\n        ...     # Process result here\n    \"\"\"\n    client = CodeInterpreter(region, session=session)\n    client.start()\n\n    try:\n        yield client\n    finally:\n        client.stop()\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client","title":"<code>bedrock_agentcore.tools.browser_client</code>","text":"<p>Client for interacting with the Browser sandbox service.</p> <p>This module provides a client for the AWS Browser sandbox, allowing applications to start, stop, and automate browser interactions in a managed sandbox environment using Playwright.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient","title":"<code>BrowserClient</code>","text":"<p>Client for interacting with the AWS Browser sandbox service.</p> <p>This client handles the session lifecycle and browser automation for Browser sandboxes, providing an interface to perform web automation tasks in a secure, managed environment.</p> <p>Attributes:</p> Name Type Description <code>region</code> <code>str</code> <p>The AWS region being used.</p> <code>data_plane_service_name</code> <code>str</code> <p>AWS service name for the data plane.</p> <code>client</code> <p>The boto3 client for interacting with the service.</p> <code>identifier</code> <code>str</code> <p>The browser identifier.</p> <code>session_id</code> <code>str</code> <p>The active session ID.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>class BrowserClient:\n    \"\"\"Client for interacting with the AWS Browser sandbox service.\n\n    This client handles the session lifecycle and browser automation for\n    Browser sandboxes, providing an interface to perform web automation\n    tasks in a secure, managed environment.\n\n    Attributes:\n        region (str): The AWS region being used.\n        data_plane_service_name (str): AWS service name for the data plane.\n        client: The boto3 client for interacting with the service.\n        identifier (str, optional): The browser identifier.\n        session_id (str, optional): The active session ID.\n    \"\"\"\n\n    def __init__(self, region: str) -&gt; None:\n        \"\"\"Initialize a Browser client for the specified AWS region.\n\n        Args:\n            region (str): The AWS region to use for the Browser service.\n        \"\"\"\n        self.region = region\n        self.data_plane_service_name = \"bedrock-agentcore\"\n        self.client = boto3.client(\n            self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n        )\n        self._identifier = None\n        self._session_id = None\n        self.logger = logging.getLogger(__name__)\n\n    @property\n    def identifier(self) -&gt; Optional[str]:\n        \"\"\"Get the current browser identifier.\n\n        Returns:\n            Optional[str]: The current identifier or None if not set.\n        \"\"\"\n        return self._identifier\n\n    @identifier.setter\n    def identifier(self, value: Optional[str]):\n        \"\"\"Set the browser identifier.\n\n        Args:\n            value (Optional[str]): The identifier to set.\n        \"\"\"\n        self._identifier = value\n\n    @property\n    def session_id(self) -&gt; Optional[str]:\n        \"\"\"Get the current session ID.\n\n        Returns:\n            Optional[str]: The current session ID or None if not set.\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, value: Optional[str]):\n        \"\"\"Set the session ID.\n\n        Args:\n            value (Optional[str]): The session ID to set.\n        \"\"\"\n        self._session_id = value\n\n    def start(\n        self,\n        identifier: Optional[str] = DEFAULT_IDENTIFIER,\n        name: Optional[str] = None,\n        session_timeout_seconds: Optional[int] = DEFAULT_SESSION_TIMEOUT,\n        viewport: Optional[Dict[str, int]] = None,\n    ) -&gt; str:\n        \"\"\"Start a browser sandbox session.\n\n        This method initializes a new browser session with the provided parameters.\n\n        Args:\n            identifier (Optional[str]): The browser sandbox identifier to use.\n                Defaults to DEFAULT_IDENTIFIER.\n            name (Optional[str]): A name for this session. If not provided, a name\n                will be generated using a UUID.\n            session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n                Defaults to DEFAULT_TIMEOUT.\n            viewport (Optional[Dict[str, int]]): The viewport dimensions for the browser.\n                Should be a dict with 'width' and 'height' keys (e.g., {'width': 1920, 'height': 1080}).\n                If not provided, the service default viewport will be used.\n\n        Returns:\n            str: The session ID of the newly created session.\n\n        Example:\n            &gt;&gt;&gt; client = BrowserClient('us-west-2')\n            &gt;&gt;&gt; session_id = client.start(viewport={'width': 1920, 'height': 1080})\n        \"\"\"\n        self.logger.info(\"Starting browser session...\")\n\n        # Build the request parameters\n        request_params = {\n            \"browserIdentifier\": identifier,\n            \"name\": name or f\"browser-session-{uuid.uuid4().hex[:8]}\",\n            \"sessionTimeoutSeconds\": session_timeout_seconds,\n        }\n\n        # Add viewport if provided\n        if viewport is not None:\n            request_params[\"viewPort\"] = viewport\n\n        response = self.client.start_browser_session(**request_params)\n\n        self.identifier = response[\"browserIdentifier\"]\n        self.session_id = response[\"sessionId\"]\n\n        return self.session_id\n\n    def stop(self):\n        \"\"\"Stop the current browser session if one is active.\n\n        This method stops any active session and clears the session state.\n        If no session is active, this method does nothing.\n\n        Returns:\n            bool: True if no session was active or the session was successfully stopped.\n        \"\"\"\n        self.logger.info(\"Stopping browser session...\")\n\n        if not self.session_id or not self.identifier:\n            return True\n\n        self.client.stop_browser_session(**{\"browserIdentifier\": self.identifier, \"sessionId\": self.session_id})\n\n        self.identifier = None\n        self.session_id = None\n\n    def generate_ws_headers(self) -&gt; Tuple[str, Dict[str, str]]:\n        \"\"\"Generate the WebSocket headers needed for connecting to the browser sandbox.\n\n        This method creates properly signed WebSocket headers for connecting to\n        the browser automation endpoint.\n\n        Returns:\n            Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and\n                the headers dictionary.\n\n        Raises:\n            RuntimeError: If no AWS credentials are found.\n        \"\"\"\n        self.logger.info(\"Generating websocket headers...\")\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        host = get_data_plane_endpoint(self.region).replace(\"https://\", \"\")\n        path = f\"/browser-streams/{self.identifier}/sessions/{self.session_id}/automation\"\n        ws_url = f\"wss://{host}{path}\"\n\n        boto_session = boto3.Session()\n        credentials = boto_session.get_credentials()\n        if not credentials:\n            raise RuntimeError(\"No AWS credentials found\")\n\n        frozen_credentials = credentials.get_frozen_credentials()\n\n        request = AWSRequest(\n            method=\"GET\",\n            url=f\"https://{host}{path}\",\n            headers={\n                \"host\": host,\n                \"x-amz-date\": datetime.datetime.now(datetime.timezone.utc).strftime(\"%Y%m%dT%H%M%SZ\"),\n            },\n        )\n\n        auth = SigV4Auth(frozen_credentials, self.data_plane_service_name, self.region)\n        auth.add_auth(request)\n\n        headers = {\n            \"Host\": host,\n            \"X-Amz-Date\": request.headers[\"x-amz-date\"],\n            \"Authorization\": request.headers[\"Authorization\"],\n            \"Upgrade\": \"websocket\",\n            \"Connection\": \"Upgrade\",\n            \"Sec-WebSocket-Version\": \"13\",\n            \"Sec-WebSocket-Key\": base64.b64encode(secrets.token_bytes(16)).decode(),\n            \"User-Agent\": f\"BrowserSandbox-Client/1.0 (Session: {self.session_id})\",\n        }\n\n        if frozen_credentials.token:\n            headers[\"X-Amz-Security-Token\"] = frozen_credentials.token\n\n        return ws_url, headers\n\n    def generate_live_view_url(self, expires: int = DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT) -&gt; str:\n        \"\"\"Generate a pre-signed URL for viewing the browser session.\n\n        Creates a pre-signed URL that can be used to view the current browser session.\n        If no session is active, a new session will be started.\n\n        Args:\n            expires (int, optional): The number of seconds until the pre-signed URL expires.\n                Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds).\n                Maximum allowed value is MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n\n        Returns:\n            str: The pre-signed URL for viewing the browser session.\n\n        Raises:\n            ValueError: If expires exceeds MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n            RuntimeError: If the URL generation fails.\n        \"\"\"\n        self.logger.info(\"Generating live view url...\")\n\n        if expires &gt; MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT:\n            raise ValueError(\n                f\"Expiry timeout cannot exceed {MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT} seconds, got {expires}\"\n            )\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        url = urlparse(\n            f\"{get_data_plane_endpoint(self.region)}/browser-streams/{self.identifier}/sessions/{self.session_id}/live-view\"\n        )\n        boto_session = boto3.Session()\n        credentials = boto_session.get_credentials().get_frozen_credentials()\n        request = AWSRequest(method=\"GET\", url=url.geturl(), headers={\"host\": url.hostname})\n        signer = SigV4QueryAuth(\n            credentials=credentials, service_name=self.data_plane_service_name, region_name=self.region, expires=expires\n        )\n        signer.add_auth(request)\n\n        if not request.url:\n            raise RuntimeError(\"Failed to generate live view url\")\n\n        return request.url\n\n    def take_control(self):\n        \"\"\"Take control of the browser session by disabling the automation stream.\n\n        This method disables external automation capabilities of the browser session,\n        giving this client exclusive control. If no session is active, a new session\n        will be started.\n\n        Raises:\n            RuntimeError: If a session could not be found or started.\n        \"\"\"\n        self.logger.info(\"Taking control of browser session...\")\n\n        if not self.identifier or not self.session_id:\n            self.start()\n\n        if not self.identifier or not self.session_id:\n            raise RuntimeError(\"Could not find or start a browser session\")\n\n        self._update_browser_stream(self.identifier, self.session_id, \"DISABLED\")\n\n    def release_control(self):\n        \"\"\"Release control of the browser session by enabling the automation stream.\n\n        This method enables external automation capabilities of the browser session,\n        relinquishing exclusive control. If no session exists, a warning is logged\n        and the method returns without taking action.\n        \"\"\"\n        self.logger.info(\"Releasing control of browser session...\")\n\n        if not self.identifier or not self.session_id:\n            self.logger.warning(\"Could not find a browser session when releasing control\")\n            return\n\n        self._update_browser_stream(self.identifier, self.session_id, \"ENABLED\")\n\n    def _update_browser_stream(self, identifier: str, session_id: str, stream_status: str) -&gt; None:\n        \"\"\"Update the browser stream status.\n\n        This private helper method updates the status of the browser automation stream.\n\n        Args:\n            identifier (str): The browser identifier.\n            session_id (str): The session ID.\n            stream_status (str): The status to set for the automation stream.\n                Valid values are \"ENABLED\" or \"DISABLED\".\n        \"\"\"\n        self.client.update_browser_stream(\n            **{\n                \"browserIdentifier\": identifier,\n                \"sessionId\": session_id,\n                \"streamUpdate\": {\"automationStreamUpdate\": {\"streamStatus\": stream_status}},\n            }\n        )\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.identifier","title":"<code>identifier</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current browser identifier.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current identifier or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.session_id","title":"<code>session_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current session ID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The current session ID or None if not set.</p>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.__init__","title":"<code>__init__(region)</code>","text":"<p>Initialize a Browser client for the specified AWS region.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Browser service.</p> required Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def __init__(self, region: str) -&gt; None:\n    \"\"\"Initialize a Browser client for the specified AWS region.\n\n    Args:\n        region (str): The AWS region to use for the Browser service.\n    \"\"\"\n    self.region = region\n    self.data_plane_service_name = \"bedrock-agentcore\"\n    self.client = boto3.client(\n        self.data_plane_service_name, region_name=region, endpoint_url=get_data_plane_endpoint(region)\n    )\n    self._identifier = None\n    self._session_id = None\n    self.logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.generate_live_view_url","title":"<code>generate_live_view_url(expires=DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT)</code>","text":"<p>Generate a pre-signed URL for viewing the browser session.</p> <p>Creates a pre-signed URL that can be used to view the current browser session. If no session is active, a new session will be started.</p> <p>Parameters:</p> Name Type Description Default <code>expires</code> <code>int</code> <p>The number of seconds until the pre-signed URL expires. Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds). Maximum allowed value is MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.</p> <code>DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The pre-signed URL for viewing the browser session.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If expires exceeds MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.</p> <code>RuntimeError</code> <p>If the URL generation fails.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def generate_live_view_url(self, expires: int = DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT) -&gt; str:\n    \"\"\"Generate a pre-signed URL for viewing the browser session.\n\n    Creates a pre-signed URL that can be used to view the current browser session.\n    If no session is active, a new session will be started.\n\n    Args:\n        expires (int, optional): The number of seconds until the pre-signed URL expires.\n            Defaults to DEFAULT_LIVE_VIEW_PRESIGNED_URL_TIMEOUT (300 seconds).\n            Maximum allowed value is MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n\n    Returns:\n        str: The pre-signed URL for viewing the browser session.\n\n    Raises:\n        ValueError: If expires exceeds MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT seconds.\n        RuntimeError: If the URL generation fails.\n    \"\"\"\n    self.logger.info(\"Generating live view url...\")\n\n    if expires &gt; MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT:\n        raise ValueError(\n            f\"Expiry timeout cannot exceed {MAX_LIVE_VIEW_PRESIGNED_URL_TIMEOUT} seconds, got {expires}\"\n        )\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    url = urlparse(\n        f\"{get_data_plane_endpoint(self.region)}/browser-streams/{self.identifier}/sessions/{self.session_id}/live-view\"\n    )\n    boto_session = boto3.Session()\n    credentials = boto_session.get_credentials().get_frozen_credentials()\n    request = AWSRequest(method=\"GET\", url=url.geturl(), headers={\"host\": url.hostname})\n    signer = SigV4QueryAuth(\n        credentials=credentials, service_name=self.data_plane_service_name, region_name=self.region, expires=expires\n    )\n    signer.add_auth(request)\n\n    if not request.url:\n        raise RuntimeError(\"Failed to generate live view url\")\n\n    return request.url\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.generate_ws_headers","title":"<code>generate_ws_headers()</code>","text":"<p>Generate the WebSocket headers needed for connecting to the browser sandbox.</p> <p>This method creates properly signed WebSocket headers for connecting to the browser automation endpoint.</p> <p>Returns:</p> Type Description <code>Tuple[str, Dict[str, str]]</code> <p>Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and the headers dictionary.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no AWS credentials are found.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def generate_ws_headers(self) -&gt; Tuple[str, Dict[str, str]]:\n    \"\"\"Generate the WebSocket headers needed for connecting to the browser sandbox.\n\n    This method creates properly signed WebSocket headers for connecting to\n    the browser automation endpoint.\n\n    Returns:\n        Tuple[str, Dict[str, str]]: A tuple containing the WebSocket URL and\n            the headers dictionary.\n\n    Raises:\n        RuntimeError: If no AWS credentials are found.\n    \"\"\"\n    self.logger.info(\"Generating websocket headers...\")\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    host = get_data_plane_endpoint(self.region).replace(\"https://\", \"\")\n    path = f\"/browser-streams/{self.identifier}/sessions/{self.session_id}/automation\"\n    ws_url = f\"wss://{host}{path}\"\n\n    boto_session = boto3.Session()\n    credentials = boto_session.get_credentials()\n    if not credentials:\n        raise RuntimeError(\"No AWS credentials found\")\n\n    frozen_credentials = credentials.get_frozen_credentials()\n\n    request = AWSRequest(\n        method=\"GET\",\n        url=f\"https://{host}{path}\",\n        headers={\n            \"host\": host,\n            \"x-amz-date\": datetime.datetime.now(datetime.timezone.utc).strftime(\"%Y%m%dT%H%M%SZ\"),\n        },\n    )\n\n    auth = SigV4Auth(frozen_credentials, self.data_plane_service_name, self.region)\n    auth.add_auth(request)\n\n    headers = {\n        \"Host\": host,\n        \"X-Amz-Date\": request.headers[\"x-amz-date\"],\n        \"Authorization\": request.headers[\"Authorization\"],\n        \"Upgrade\": \"websocket\",\n        \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Version\": \"13\",\n        \"Sec-WebSocket-Key\": base64.b64encode(secrets.token_bytes(16)).decode(),\n        \"User-Agent\": f\"BrowserSandbox-Client/1.0 (Session: {self.session_id})\",\n    }\n\n    if frozen_credentials.token:\n        headers[\"X-Amz-Security-Token\"] = frozen_credentials.token\n\n    return ws_url, headers\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.release_control","title":"<code>release_control()</code>","text":"<p>Release control of the browser session by enabling the automation stream.</p> <p>This method enables external automation capabilities of the browser session, relinquishing exclusive control. If no session exists, a warning is logged and the method returns without taking action.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def release_control(self):\n    \"\"\"Release control of the browser session by enabling the automation stream.\n\n    This method enables external automation capabilities of the browser session,\n    relinquishing exclusive control. If no session exists, a warning is logged\n    and the method returns without taking action.\n    \"\"\"\n    self.logger.info(\"Releasing control of browser session...\")\n\n    if not self.identifier or not self.session_id:\n        self.logger.warning(\"Could not find a browser session when releasing control\")\n        return\n\n    self._update_browser_stream(self.identifier, self.session_id, \"ENABLED\")\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.start","title":"<code>start(identifier=DEFAULT_IDENTIFIER, name=None, session_timeout_seconds=DEFAULT_SESSION_TIMEOUT, viewport=None)</code>","text":"<p>Start a browser sandbox session.</p> <p>This method initializes a new browser session with the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Optional[str]</code> <p>The browser sandbox identifier to use. Defaults to DEFAULT_IDENTIFIER.</p> <code>DEFAULT_IDENTIFIER</code> <code>name</code> <code>Optional[str]</code> <p>A name for this session. If not provided, a name will be generated using a UUID.</p> <code>None</code> <code>session_timeout_seconds</code> <code>Optional[int]</code> <p>The timeout for the session in seconds. Defaults to DEFAULT_TIMEOUT.</p> <code>DEFAULT_SESSION_TIMEOUT</code> <code>viewport</code> <code>Optional[Dict[str, int]]</code> <p>The viewport dimensions for the browser. Should be a dict with 'width' and 'height' keys (e.g., {'width': 1920, 'height': 1080}). If not provided, the service default viewport will be used.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The session ID of the newly created session.</p> Example <p>client = BrowserClient('us-west-2') session_id = client.start(viewport={'width': 1920, 'height': 1080})</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def start(\n    self,\n    identifier: Optional[str] = DEFAULT_IDENTIFIER,\n    name: Optional[str] = None,\n    session_timeout_seconds: Optional[int] = DEFAULT_SESSION_TIMEOUT,\n    viewport: Optional[Dict[str, int]] = None,\n) -&gt; str:\n    \"\"\"Start a browser sandbox session.\n\n    This method initializes a new browser session with the provided parameters.\n\n    Args:\n        identifier (Optional[str]): The browser sandbox identifier to use.\n            Defaults to DEFAULT_IDENTIFIER.\n        name (Optional[str]): A name for this session. If not provided, a name\n            will be generated using a UUID.\n        session_timeout_seconds (Optional[int]): The timeout for the session in seconds.\n            Defaults to DEFAULT_TIMEOUT.\n        viewport (Optional[Dict[str, int]]): The viewport dimensions for the browser.\n            Should be a dict with 'width' and 'height' keys (e.g., {'width': 1920, 'height': 1080}).\n            If not provided, the service default viewport will be used.\n\n    Returns:\n        str: The session ID of the newly created session.\n\n    Example:\n        &gt;&gt;&gt; client = BrowserClient('us-west-2')\n        &gt;&gt;&gt; session_id = client.start(viewport={'width': 1920, 'height': 1080})\n    \"\"\"\n    self.logger.info(\"Starting browser session...\")\n\n    # Build the request parameters\n    request_params = {\n        \"browserIdentifier\": identifier,\n        \"name\": name or f\"browser-session-{uuid.uuid4().hex[:8]}\",\n        \"sessionTimeoutSeconds\": session_timeout_seconds,\n    }\n\n    # Add viewport if provided\n    if viewport is not None:\n        request_params[\"viewPort\"] = viewport\n\n    response = self.client.start_browser_session(**request_params)\n\n    self.identifier = response[\"browserIdentifier\"]\n    self.session_id = response[\"sessionId\"]\n\n    return self.session_id\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.stop","title":"<code>stop()</code>","text":"<p>Stop the current browser session if one is active.</p> <p>This method stops any active session and clears the session state. If no session is active, this method does nothing.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if no session was active or the session was successfully stopped.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the current browser session if one is active.\n\n    This method stops any active session and clears the session state.\n    If no session is active, this method does nothing.\n\n    Returns:\n        bool: True if no session was active or the session was successfully stopped.\n    \"\"\"\n    self.logger.info(\"Stopping browser session...\")\n\n    if not self.session_id or not self.identifier:\n        return True\n\n    self.client.stop_browser_session(**{\"browserIdentifier\": self.identifier, \"sessionId\": self.session_id})\n\n    self.identifier = None\n    self.session_id = None\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.BrowserClient.take_control","title":"<code>take_control()</code>","text":"<p>Take control of the browser session by disabling the automation stream.</p> <p>This method disables external automation capabilities of the browser session, giving this client exclusive control. If no session is active, a new session will be started.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a session could not be found or started.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>def take_control(self):\n    \"\"\"Take control of the browser session by disabling the automation stream.\n\n    This method disables external automation capabilities of the browser session,\n    giving this client exclusive control. If no session is active, a new session\n    will be started.\n\n    Raises:\n        RuntimeError: If a session could not be found or started.\n    \"\"\"\n    self.logger.info(\"Taking control of browser session...\")\n\n    if not self.identifier or not self.session_id:\n        self.start()\n\n    if not self.identifier or not self.session_id:\n        raise RuntimeError(\"Could not find or start a browser session\")\n\n    self._update_browser_stream(self.identifier, self.session_id, \"DISABLED\")\n</code></pre>"},{"location":"api-reference/tools.html#bedrock_agentcore.tools.browser_client.browser_session","title":"<code>browser_session(region, viewport=None)</code>","text":"<p>Context manager for creating and managing a browser sandbox session.</p> <p>Parameters:</p> Name Type Description Default <code>region</code> <code>str</code> <p>The AWS region to use for the Browser service.</p> required <code>viewport</code> <code>Optional[Dict[str, int]]</code> <p>The viewport dimensions for the browser.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>BrowserClient</code> <code>BrowserClient</code> <p>An initialized and started browser client.</p> Source code in <code>bedrock_agentcore/tools/browser_client.py</code> <pre><code>@contextmanager\ndef browser_session(region: str, viewport: Optional[Dict[str, int]] = None) -&gt; Generator[BrowserClient, None, None]:\n    \"\"\"Context manager for creating and managing a browser sandbox session.\n\n    Args:\n        region (str): The AWS region to use for the Browser service.\n        viewport (Optional[Dict[str, int]]): The viewport dimensions for the browser.\n\n    Yields:\n        BrowserClient: An initialized and started browser client.\n    \"\"\"\n    client = BrowserClient(region)\n    client.start(viewport=viewport)\n\n    try:\n        yield client\n    finally:\n        client.stop()\n</code></pre>"},{"location":"examples/index.html","title":"Examples","text":"<p>These simple examples demonstrate key Amazon Bedrock AgentCore concepts and patterns. Each example focuses on a specific capability, making it easy to understand and adapt for your own agents. For more comprehensive examples and production-ready samples, explore the Amazon Bedrock AgentCore Samples repository.</p>"},{"location":"examples/agentcore-quickstart-example.html","title":"AgentCore Quickstart","text":""},{"location":"examples/agentcore-quickstart-example.html#introduction","title":"Introduction","text":"<p>Build and deploy a production-ready AI agent in minutes with runtime hosting, memory, secure code execution, and observability. This guide shows how to use AgentCore Runtime, Memory, Code Interpreter, and Observability.</p> <p>For Gateway and Identity features, see the Gateway quickstart and Identity quickstart.</p>"},{"location":"examples/agentcore-quickstart-example.html#prerequisites","title":"Prerequisites","text":"<ul> <li>AWS Permissions: Root users or privileged roles (such as admins) can skip this step. Others need to attach the starter toolkit policy and AmazonBedrockAgentCoreFullAccess managed policy.</li> <li>AWS CLI version 2.0 or later configured (<code>aws configure</code>)</li> <li>Amazon Bedrock model access enabled for Claude 3.7 Sonnet (Go to AWS Console \u2192 Bedrock \u2192 Model access \u2192 Enable \"Claude 3.7 Sonnet\" in your region). For information about using a different model with Strands Agents, see the Model Providers section in the Strands Agents SDK documentation.</li> <li>Python 3.10 or newer</li> </ul> <p>Important: Ensure AWS Region Consistency</p> <p>Ensure the following are all configured to use the same AWS region:</p> <ul> <li>Your <code>aws configure</code> default region</li> <li>The region where you've enabled Bedrock model access</li> <li>All resources created during deployment will use this region</li> </ul>"},{"location":"examples/agentcore-quickstart-example.html#installation-version-0121-or-later","title":"Installation (version 0.1.21 or later)","text":"<pre><code># Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install required packages\npip install bedrock-agentcore-starter-toolkit strands-agents boto3\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#step-1a-create-a-new-agent","title":"Step 1A: Create a New Agent","text":"<p>Create <code>agentcore_starter_strands.py</code>:</p> <pre><code>\"\"\"\nStrands Agent sample with AgentCore\n\"\"\"\nimport os\nfrom strands import Agent, tool\nfrom bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig, RetrievalConfig\nfrom bedrock_agentcore.memory.integrations.strands.session_manager import AgentCoreMemorySessionManager\nfrom bedrock_agentcore.tools.code_interpreter_client import CodeInterpreter\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\nMEMORY_ID = os.getenv(\"BEDROCK_AGENTCORE_MEMORY_ID\")\nREGION = os.getenv(\"AWS_REGION\")\nMODEL_ID = \"us.anthropic.claude-3-7-sonnet-20250219-v1:0\"\n\nci_sessions = {}\ncurrent_session = None\n\n@tool\ndef calculate(code: str) -&gt; str:\n    \"\"\"Execute Python code for calculations or analysis.\"\"\"\n    session_id = current_session or 'default'\n\n    if session_id not in ci_sessions:\n        ci_sessions[session_id] = {\n            'client': CodeInterpreter(REGION),\n            'session_id': None\n        }\n\n    ci = ci_sessions[session_id]\n    if not ci['session_id']:\n        ci['session_id'] = ci['client'].start(\n            name=f\"session_{session_id[:30]}\",\n            session_timeout_seconds=1800\n        )\n\n    result = ci['client'].invoke(\"executeCode\", {\n        \"code\": code,\n        \"language\": \"python\"\n    })\n\n    for event in result.get(\"stream\", []):\n        if stdout := event.get(\"result\", {}).get(\"structuredContent\", {}).get(\"stdout\"):\n            return stdout\n    return \"Executed\"\n\n@app.entrypoint\ndef invoke(payload, context):\n    global current_session\n\n    if not MEMORY_ID:\n        return {\"error\": \"Memory not configured\"}\n\n    actor_id = context.headers.get('X-Amzn-Bedrock-AgentCore-Runtime-Custom-Actor-Id', 'user') if hasattr(context, 'headers') else 'user'\n\n    session_id = getattr(context, 'session_id', 'default')\n    current_session = session_id\n\n    memory_config = AgentCoreMemoryConfig(\n        memory_id=MEMORY_ID,\n        session_id=session_id,\n        actor_id=actor_id,\n        retrieval_config={\n            f\"/users/{actor_id}/facts\": RetrievalConfig(top_k=3, relevance_score=0.5),\n            f\"/users/{actor_id}/preferences\": RetrievalConfig(top_k=3, relevance_score=0.5)\n        }\n    )\n\n    agent = Agent(\n        model=MODEL_ID,\n        session_manager=AgentCoreMemorySessionManager(memory_config, REGION),\n        system_prompt=\"You are a helpful assistant. Use tools when appropriate.\",\n        tools=[calculate]\n    )\n\n    result = agent(payload.get(\"prompt\", \"\"))\n    return {\"response\": result.message.get('content', [{}])[0].get('text', str(result))}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Create <code>requirements.txt</code>:</p> <pre><code>strands-agents\nbedrock-agentcore\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#step-1b-transform-an-existing-agent-to-be-compatible-with-runtime","title":"Step 1B: Transform an Existing Agent to be Compatible with Runtime","text":"<ol> <li>Import the Runtime App with from bedrock_agentcore.runtime import BedrockAgentCoreApp</li> <li>Initialize the App in your code with app = BedrockAgentCoreApp()</li> <li>Decorate the invocation function with the @app.entrypoint decorator</li> <li>Create a requirements.txt file with needed packages. Note: if strands-tools is detected, the correct library to add is strands-agents-tools</li> <li>Let AgentCore Runtime control the running of the agent with app.run() </li> </ol>"},{"location":"examples/agentcore-quickstart-example.html#step-2-configure-and-deploy","title":"Step 2: Configure and Deploy","text":"<p>The AgentCore CLI automates deployment with provisioning.</p>"},{"location":"examples/agentcore-quickstart-example.html#configure-the-agent","title":"Configure the Agent","text":"<p><pre><code>agentcore configure -e agentcore_starter_strands.py\n\n#Interactive prompts you'll see:\n\n# 1. Execution Role: Press Enter to auto-create or provide existing role ARN/name\n# 2. ECR Repository: Press Enter to auto-create or provide existing ECR URI\n# 3. OAuth Configuration: Configure OAuth authorizer? (yes/no) - Type `no` for this tutorial\n# 4. Request Header Allowlist: Configure request header allowlist? (yes/no) - Type `no` for this tutorial\n# 5. Memory Configuration:\n#    - If existing memories found: Choose from list or press Enter to create new\n#    - If creating new: Enable long-term memory extraction? (yes/no) - Type `yes` for this tutorial\n#    - Note: Short-term memory is always enabled by default\n# If interactive mode fails, use \"--non-interactive\" for default configs\n</code></pre> For this tutorial: When prompted for the execution role, press Enter to auto-create a new role with all required permissions for Runtime, Memory, Code Interpreter, and Observability. When prompted for long-term memory, type yes for this tutorial.</p> <p>Note: If the memory configuration prompts do not appear during <code>agentcore configure</code>, refer to the Troubleshooting section (Memory Configuration Not Appearing) to ensure the correct toolkit version is installed.</p>"},{"location":"examples/agentcore-quickstart-example.html#deploy-to-agentcore","title":"Deploy to AgentCore","text":"<pre><code>agentcore launch\n\n# This performs:\n#   1. Memory resource provisioning (STM + LTM strategies)\n#   2. Docker container build with dependencies\n#   3. ECR repository push\n#   4. AgentCore Runtime deployment with X-Ray tracing enabled\n#   5. CloudWatch Transaction Search configuration (automatic)\n#   6. Endpoint activation with trace collection\n</code></pre> <p>Expected output:</p> <pre><code>\u2705 Memory created: agentcore_starter_strands_mem-abc123\nObservability is enabled, configuring Transaction Search...\n\u2705 Transaction Search configured: resource_policy, trace_destination, indexing_rule\n\ud83d\udd0d GenAI Observability Dashboard:\n   https://console.aws.amazon.com/cloudwatch/home?region=us-west-2#gen-ai-observability/agent-core\n\u2705 Container deployed to Bedrock AgentCore\nAgent ARN: arn:aws:bedrock-agentcore:us-west-2:123456789:runtime/agentcore_starter_strands-xyz\n</code></pre> <p>If deployment encounters errors or behaves unexpectedly, check your configuration: <pre><code>cat .bedrock_agentcore.yaml  # Review deployed configuration\nagentcore status              # Verify resource provisioning status\n</code></pre> Refer to the Troubleshooting section if you see any issues.</p>"},{"location":"examples/agentcore-quickstart-example.html#step-3-monitor-deployment","title":"Step 3: Monitor Deployment","text":"<p>Check deployment status:</p> <pre><code>agentcore status\n\n# Shows:\n#   Memory ID: agentcore_starter_strands_mem-abc123\n#   Memory Status: CREATING (if still provisioning)\n#   Memory Type: STM+LTM (provisioning...) (if creating with LTM)\n#   Memory Type: STM+LTM (3 strategies) (when active with strategies)\n#   Memory Type: STM only (if configured without LTM)\n#   Observability: Enabled\n</code></pre> <p>Note: LTM strategies require 2-5 minutes to activate. STM is provisioned immediately if LTM is not selected.</p>"},{"location":"examples/agentcore-quickstart-example.html#step-4-test-memory-and-code-interpreter","title":"Step 4: Test Memory and Code Interpreter","text":""},{"location":"examples/agentcore-quickstart-example.html#test-short-term-memory-stm","title":"Test Short-Term Memory (STM)","text":"<p>Testing within a single session:</p> <pre><code># Store information (session IDs must be 33+ characters)\nagentcore invoke '{\"prompt\": \"Remember that my favorite agent platform is AgentCore\"}'\n\n# If invoked too early (memory still provisioning), you'll see:\n# \"Memory is still provisioning (current status: CREATING).\n#  Long-term memory extraction takes 60-180 seconds to activate.\n#\n#  Please wait and check status with:\n#    agentcore status\"\n\n# Retrieve within same session\nagentcore invoke '{\"prompt\": \"What is my favorite agent platform?\"}'\n\n# Expected response:\n# \"Your favorite agent platform is AgentCore.\"\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#test-long-term-memory-ltm-cross-session-persistence","title":"Test Long-Term Memory (LTM) - Cross-Session Persistence","text":"<p>LTM enables information persistence across different sessions. This requires waiting for LTM extraction after storing information.</p> <pre><code># Session 1: Store facts\nagentcore invoke '{\"prompt\": \"My email is user@example.com and I am an AgentCore user\"}'\n</code></pre> <p>Wait for extraction that runs in the background by AgentCore. This typically takes 10-30 seconds. If you do not see the facts, wait a few more seconds and try again.</p> <pre><code>sleep 20\n# Session 2: Different runtime session retrieves the facts extracted from initial session\nSESSION_ID=$(python -c \"import uuid; print(uuid.uuid4())\")\nagentcore invoke '{\"prompt\": \"Tell me about myself?\"}' --session-id $SESSION_ID\n\n# Expected response:\n# \"Your email address is user@example.com.\"\n# \"You appear to be a user of AgentCore, which seems to be your favorite agent platform.\"\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#test-code-interpreter","title":"Test Code Interpreter","text":"<pre><code># Store data\nagentcore invoke '{\"prompt\": \"My dataset has values: 23, 45, 67, 89, 12, 34, 56.\"}'\n\n# Create visualization\nagentcore invoke '{\"prompt\": \"Create a text-based bar chart visualization showing the distribution of values in my dataset with proper labels\"}'\n\n# Expected: Agent generates matplotlib code to create a bar chart\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#step-5-view-traces-and-logs","title":"Step 5: View Traces and Logs","text":""},{"location":"examples/agentcore-quickstart-example.html#access-cloudwatch-dashboard","title":"Access CloudWatch Dashboard","text":"<p>Navigate to the GenAI Observability dashboard to view end-to-end request traces including agent execution tracking, memory retrieval operations, code interpreter executions, agent reasoning steps, and latency breakdown by component. The dashboard provides a service map view showing agent runtime connections to Memory and Code Interpreter services with request flow visualization and latency metrics, as well as detailed X-Ray traces for debugging and performance analysis.</p> <pre><code># Get the dashboard URL from status\nagentcore status\n\n# Navigate to the URL shown, or go directly to:\n# https://console.aws.amazon.com/cloudwatch/home?region=us-west-2#gen-ai-observability/agent-core\n# Note: Replace the region\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#view-agent-runtime-logs","title":"View Agent Runtime Logs","text":"<pre><code># The correct log paths are shown in the invoke or status output\nagentcore status\n\n# You'll see log paths like:\n# aws logs tail /aws/bedrock-agentcore/runtimes/AGENT_ID-DEFAULT --log-stream-name-prefix \"YYYY/MM/DD/[runtime-logs]\" --follow\n\n# Copy this command from the output to view logs\n# For example:\naws logs tail /aws/bedrock-agentcore/runtimes/AGENT_ID-DEFAULT --log-stream-name-prefix \"YYYY/MM/DD/[runtime-logs]\" --follow\n\n# For recent logs, use the --since option as shown in the output:\naws logs tail /aws/bedrock-agentcore/runtimes/AGENT_ID-DEFAULT --log-stream-name-prefix \"YYYY/MM/DD/[runtime-logs]\" --since 1h\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#clean-up","title":"Clean Up","text":"<pre><code>agentcore destroy\n\n# Removes:\n#   - Runtime endpoint and agent\n#   - Memory resources (STM + LTM)\n#   - ECR repository and images\n#   - IAM roles (if auto-created)\n#   - CloudWatch log groups (optional)\n</code></pre>"},{"location":"examples/agentcore-quickstart-example.html#troubleshooting","title":"Troubleshooting","text":"Memory Configuration Not Appearing  **\"Memory option not showing during `agentcore configure`\":**  This typically occurs when using an outdated version of the starter toolkit. Ensure you have version 0.1.21 or later installed:  <pre><code># Step 1: Verify current state\nwhich python   # Should show .venv/bin/python\nwhich agentcore  # Currently showing global path\n\n# Step 2: Deactivate and reactivate venv to reset PATH\ndeactivate\nsource .venv/bin/activate\n\n# Step 3: Check if that fixed it\nwhich agentcore\n# If NOW showing .venv/bin/agentcore -&gt; RESOLVED, skip to Step 7\n# If STILL showing global path -&gt; continue to Step 4\n\n# Step 4: Force local venv to take precedence in PATH\nexport PATH=\"$(pwd)/.venv/bin:$PATH\"\n\n# Step 5: Check again\nwhich agentcore\n# If NOW showing .venv/bin/agentcore -&gt; RESOLVED, skip to Step 7\n# If STILL showing global path -&gt; continue to Step 6\n\n# Step 6: Reinstall in local venv with forced precedence\npip install --force-reinstall --no-cache-dir \"bedrock-agentcore-starter-toolkit&gt;=0.1.21\"\n\n# Step 7: Final verification\nwhich agentcore  # Must show: /path/to/your-project/.venv/bin/agentcore\npip show bedrock-agentcore-starter-toolkit  # Verify version &gt;= 0.1.21\nagentcore --version  # Double check it's working\n\n# Step 8: Try configure again\nagentcore configure -e agentcore_starter_strands.py\n\n#If Step 6 still doesn't work, the nuclear option:\ncd ..\nmkdir fresh-agentcore-project &amp;&amp; cd fresh-agentcore-project\npython3 -m venv .venv\nsource .venv/bin/activate\npip install --no-cache-dir \"bedrock-agentcore-starter-toolkit&gt;=0.1.21\" strands-agents boto3\n# Copy your agent code here, then reconfigure\n</code></pre>  **Additional checks:**  - Ensure you're running `agentcore configure` from within the activated virtual environment - If using an IDE (VSCode, PyCharm), restart the IDE after reinstalling - Verify no system-wide agentcore installation conflicts: `pip list | grep bedrock-agentcore`   Region Misconfiguration  **If you need to change your region configuration:**  1. Clean up resources in the incorrect region:    <pre><code>agentcore destroy\n\n# This removes:\n#   - Runtime endpoint and agent\n#   - Memory resources (STM + LTM)\n#   - ECR repository and images\n#   - IAM roles (if auto-created)\n#   - CloudWatch log groups (optional)\n</code></pre>  2. Verify your AWS CLI is configured for the correct region:    <pre><code>aws configure get region\n# Or reconfigure for the correct region:\naws configure set region &lt;your-desired-region&gt;\n</code></pre>  3. Ensure Bedrock model access is enabled in the target region (AWS Console \u2192 Bedrock \u2192 Model access)  4. Copy your agent code and requirements.txt to the new folder, then return to **Step 2: Configure and Deploy**   Memory Issues  **\"Memory status is not active\" error:**  - Run `agentcore status` to check memory status - If showing \"provisioning\", wait 2-3 minutes - Retry after status shows \"STM+LTM (3 strategies)\"  **Cross-session memory not working:**  - Verify LTM is active (not \"provisioning\") - Wait 15-30 seconds after storing facts for extraction - Check extraction logs for completion   Observability Issues  **No traces appearing:**  - Verify observability was enabled during `agentcore configure` - Check IAM permissions include CloudWatch and X-Ray access - Wait 30-60 seconds for traces to appear in CloudWatch - Traces are viewable at: AWS Console \u2192 CloudWatch \u2192 Service Map or X-Ray \u2192 Traces  **Missing memory logs:**  - Check log group exists: `/aws/vendedlogs/bedrock-agentcore/memory/APPLICATION_LOGS/` - Verify IAM role has CloudWatch Logs permissions"},{"location":"examples/agentcore-quickstart-example.html#summary","title":"Summary","text":"<p>You've deployed a production agent with:</p> <ul> <li>Runtime for managed container orchestration</li> <li>Memory with STM for immediate context and LTM for cross-session persistence</li> <li>Code Interpreter for secure Python execution with data visualization capabilities</li> <li>AWS X-Ray Tracing automatically configured for distributed tracing</li> <li>CloudWatch Integration for logs and metrics with Transaction Search enabled</li> </ul> <p>All services are automatically instrumented with X-Ray tracing, providing complete visibility into agent behavior, memory operations, and tool executions through the CloudWatch dashboard.</p>"},{"location":"examples/async-processing.html","title":"Async Processing","text":"<p>This example demonstrates how to use Bedrock AgentCore's <code>@async_task</code> decorator for automatic health status management.</p>"},{"location":"examples/async-processing.html#overview","title":"Overview","text":"<p>Bedrock AgentCore provides automatic ping status management based on running async tasks:</p> <ul> <li>Automatic Health Reporting: Ping status automatically reflects system busyness</li> <li>Simple Integration: Just use the <code>@async_task</code> decorator</li> <li>Zero Configuration: Status tracking works out of the box</li> </ul>"},{"location":"examples/async-processing.html#key-concepts","title":"Key Concepts","text":"<ul> <li><code>Healthy</code>: System ready for new work</li> <li><code>HealthyBusy</code>: System busy with async tasks</li> </ul>"},{"location":"examples/async-processing.html#simple-agent-example","title":"Simple Agent Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple agent demonstrating @async_task decorator usage.\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n# Long-running task that automatically affects ping status\n@app.async_task\nasync def process_data(data_id: str):\n    \"\"\"Process data asynchronously - status becomes 'HealthyBusy' during execution.\"\"\"\n    print(f\"[{datetime.now()}] Processing data: {data_id}\")\n\n    # Simulate processing work\n    await asyncio.sleep(30)  # Long-running task\n\n    print(f\"[{datetime.now()}] Completed processing: {data_id}\")\n    return f\"Processed {data_id}\"\n\n# Another background task\n@app.async_task\nasync def cleanup_task():\n    \"\"\"Cleanup task that also affects ping status.\"\"\"\n    print(f\"[{datetime.now()}] Starting cleanup...\")\n    await asyncio.sleep(10)\n    print(f\"[{datetime.now()}] Cleanup completed\")\n    return \"Cleanup done\"\n\n@app.entrypoint\nasync def handler(event):\n    \"\"\"Main handler - starts async tasks.\"\"\"\n    action = event.get(\"action\", \"info\")\n\n    if action == \"process\":\n        data_id = event.get(\"data_id\", \"default_data\")\n        # Start the async task (status will become HealthyBusy)\n        await process_data(data_id)\n        return {\"message\": f\"Processing {data_id}\", \"status\": \"completed\"}\n\n    elif action == \"cleanup\":\n        # Start cleanup task\n        await cleanup_task()\n        return {\"message\": \"Cleanup completed\"}\n\n    elif action == \"status\":\n        # Get current status\n        task_info = app.get_async_task_info()\n        current_status = app.get_current_ping_status()\n\n        return {\n            \"ping_status\": current_status.value,\n            \"active_tasks\": task_info[\"active_count\"],\n            \"running_jobs\": task_info[\"running_jobs\"]\n        }\n\n    else:\n        return {\n            \"message\": \"Simple BedrockAgentCore Agent\",\n            \"available_actions\": [\"process\", \"cleanup\", \"status\"],\n            \"usage\": \"Send {'action': 'process', 'data_id': 'my_data'}\"\n        }\n\nif __name__ == \"__main__\":\n    print(\"Starting simple BedrockAgentCore agent...\")\n    print(\"The agent will automatically report 'HealthyBusy' when processing tasks\")\n    app.run()\n</code></pre>"},{"location":"examples/async-processing.html#how-it-works","title":"How It Works","text":"<ol> <li>Decorate async functions with <code>@app.async_task</code></li> <li>Call the functions normally in your handler</li> <li>Status updates automatically:</li> <li><code>Healthy</code> when no tasks are running</li> <li><code>HealthyBusy</code> when any <code>@async_task</code> function is executing</li> </ol>"},{"location":"examples/async-processing.html#usage-examples","title":"Usage Examples","text":"<pre><code># Check current ping status\ncurl http://localhost:8080/ping\n\n# Start processing (status will become HealthyBusy)\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"process\", \"data_id\": \"sample_data\"}'\n\n# Check status while processing\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"status\"}'\n\n# Run cleanup task\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"cleanup\"}'\n</code></pre>"},{"location":"examples/async-processing.html#key-benefits","title":"Key Benefits","text":"<ol> <li>Automatic Status Tracking: No manual ping status management needed</li> <li>Cost Control: Status automatically prevents new work assignment when busy</li> <li>Simple to Use: Just add <code>@async_task</code> decorator to long-running functions</li> <li>Error Handling: Status correctly updates even if tasks fail</li> </ol> <p>This simple pattern provides automatic health monitoring for your BedrockAgentCore applications without any additional configuration.</p>"},{"location":"examples/gateway-integration.html","title":"Gateway Integration Examples","text":""},{"location":"examples/gateway-integration.html#lambda-function-as-mcp-tool","title":"Lambda Function as MCP Tool","text":"<pre><code>from bedrock_agentcore.gateway import GatewayClient\nimport json\n\nclient = GatewayClient(region_name='us-west-2')\n\n# Define Lambda tools with detailed schemas\nlambda_config = {\n    \"arn\": \"arn:aws:lambda:us-west-2:123:function:DataProcessor\",\n    \"tools\": [\n        {\n            \"name\": \"process_data\",\n            \"description\": \"Process user data in JSON or CSV format\",\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\"type\": \"string\"},\n                    \"format\": {\"type\": \"string\"}  # Note: enum not supported, document in description\n                },\n                \"required\": [\"data\", \"format\"]\n            }\n        },\n        {\n            \"name\": \"validate_data\",\n            \"description\": \"Validate data structure\",\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"data\": {\"type\": \"string\"}\n                },\n                \"required\": [\"data\"]\n            }\n        }\n    ]\n}\n\n# Create Gateway with semantic search enabled\ncognito = client.create_oauth_authorizer_with_cognito(\"data-processor\")\ngateway = client.setup_gateway(\n    gateway_name=\"data-processor\",\n    target_source=json.dumps(lambda_config),\n    execution_role_arn=\"arn:aws:iam::123:role/ExecutionRole\",\n    authorizer_config=cognito['authorizer_config'],\n    target_type='lambda',\n    enable_semantic_search=True,\n    description=\"Data processing gateway with validation tools\"\n)\n\nprint(f\"Gateway created: {gateway.get_mcp_url()}\")\n</code></pre>"},{"location":"examples/gateway-integration.html#openapi-integration","title":"OpenAPI Integration","text":""},{"location":"examples/gateway-integration.html#from-s3","title":"From S3","text":"<pre><code>gateway = client.setup_gateway(\n    gateway_name=\"my-api\",\n    target_source=\"s3://my-bucket/api-spec.json\",\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#inline-openapi-specification","title":"Inline OpenAPI Specification","text":"<pre><code>openapi_spec = {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\"title\": \"User API\", \"version\": \"1.0.0\"},\n    \"servers\": [{\"url\": \"https://api.example.com\"}],\n    \"paths\": {\n        \"/users\": {\n            \"get\": {\n                \"operationId\": \"listUsers\",\n                \"summary\": \"List all users\",\n                \"responses\": {\"200\": {\"description\": \"User list\"}}\n            }\n        },\n        \"/users/{id}\": {\n            \"get\": {\n                \"operationId\": \"getUser\",\n                \"summary\": \"Get user by ID\",\n                \"parameters\": [{\n                    \"name\": \"id\",\n                    \"in\": \"path\",\n                    \"required\": True,\n                    \"schema\": {\"type\": \"string\"}\n                }],\n                \"responses\": {\"200\": {\"description\": \"User found\"}}\n            }\n        }\n    }\n}\n\ngateway = client.setup_gateway(\n    gateway_name=\"user-api\",\n    target_source=json.dumps(openapi_spec),\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#yaml-openapi-from-file","title":"YAML OpenAPI (from file)","text":"<pre><code>import yaml\n\n# Load YAML OpenAPI spec\nwith open('openapi.yaml', 'r') as f:\n    yaml_content = f.read()\n    openapi_spec = yaml.safe_load(yaml_content)\n\n# Convert to JSON string for inline use\ngateway = client.setup_gateway(\n    gateway_name=\"yaml-api\",\n    target_source=json.dumps(openapi_spec),\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n\n# Or use S3 (YAML files work directly)\ngateway = client.setup_gateway(\n    gateway_name=\"yaml-api\",\n    target_source=\"s3://my-bucket/openapi.yaml\",\n    execution_role_arn=role_arn,\n    authorizer_config=cognito['authorizer_config'],\n    target_type='openapi'\n)\n</code></pre>"},{"location":"examples/gateway-integration.html#oauth-token-management","title":"OAuth Token Management","text":"<p>When integrating Gateway with any agent framework, you'll need to handle OAuth tokens properly:</p> <pre><code>import os\nfrom datetime import datetime, timedelta\nimport httpx\nimport asyncio\n\nclass GatewayTokenManager:\n    \"\"\"Manages OAuth tokens with automatic refresh\"\"\"\n\n    def __init__(self, client_id, client_secret, token_endpoint, scope):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.token_endpoint = token_endpoint\n        self.scope = scope\n        self._token = None\n        self._expires_at = None\n\n    async def get_token(self):\n        \"\"\"Get valid token, refreshing if needed\"\"\"\n        if self._token and self._expires_at &gt; datetime.now():\n            return self._token\n\n        # Fetch new token\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                self.token_endpoint,\n                data={\n                    'grant_type': 'client_credentials',\n                    'client_id': self.client_id,\n                    'client_secret': self.client_secret,\n                    'scope': self.scope\n                },\n                headers={'Content-Type': 'application/x-www-form-urlencoded'}\n            )\n            data = response.json()\n            self._token = data['access_token']\n            # Buffer expiry by 5 minutes\n            expires_in = data.get('expires_in', 3600) - 300\n            self._expires_at = datetime.now() + timedelta(seconds=expires_in)\n            return self._token\n</code></pre>"},{"location":"examples/gateway-integration.html#generic-agent-integration","title":"Generic Agent Integration","text":"<p>Here's how to integrate Gateway with any agent framework:</p> <pre><code>import os\nimport asyncio\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\n# Initialize token manager with Gateway credentials\ntoken_manager = GatewayTokenManager(\n    client_id=os.environ['GATEWAY_CLIENT_ID'],\n    client_secret=os.environ['GATEWAY_CLIENT_SECRET'],\n    token_endpoint=os.environ['GATEWAY_TOKEN_ENDPOINT'],\n    scope=os.environ['GATEWAY_SCOPE']\n)\n\n# Gateway MCP endpoint\nGATEWAY_URL = os.environ['GATEWAY_MCP_URL']\n\n# Generic function to call Gateway tools\nasync def call_gateway_tool(tool_name: str, arguments: dict):\n    \"\"\"Call any tool exposed through Gateway\"\"\"\n    token = await token_manager.get_token()\n\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            GATEWAY_URL,\n            headers={\n                \"Authorization\": f\"Bearer {token}\",\n                \"Content-Type\": \"application/json\"\n            },\n            json={\n                \"jsonrpc\": \"2.0\",\n                \"id\": 1,\n                \"method\": \"tools/call\",\n                \"params\": {\n                    \"name\": tool_name,\n                    \"arguments\": arguments\n                }\n            }\n        )\n\n        result = response.json()\n        if 'error' in result:\n            raise Exception(f\"Tool error: {result['error']}\")\n\n        return result.get('result')\n\n# Example: Using in your agent logic\nasync def process_user_request(user_message: str):\n    # Parse intent from user message\n    if \"weather\" in user_message.lower():\n        # Extract location (this would be done by your agent's NLU)\n        location = extract_location(user_message)\n        weather_data = await call_gateway_tool(\"get_weather\", {\"location\": location})\n        return f\"The weather in {location} is: {weather_data}\"\n\n    elif \"user\" in user_message.lower():\n        # Get user information\n        user_id = extract_user_id(user_message)\n        user_data = await call_gateway_tool(\"getUser\", {\"id\": user_id})\n        return f\"User information: {user_data}\"\n\n    return \"I couldn't understand your request.\"\n</code></pre>"},{"location":"examples/gateway-integration.html#complete-example-weather-agent","title":"Complete Example: Weather Agent","text":"<pre><code>from bedrock_agentcore.gateway import GatewayClient\nimport json\nimport asyncio\nimport httpx\n\n# Step 1: Create Gateway\nasync def setup_weather_gateway():\n    client = GatewayClient(region_name='us-west-2')\n\n    # Configure Lambda with weather tools\n    lambda_config = {\n        \"arn\": \"arn:aws:lambda:us-west-2:123:function:WeatherService\",\n        \"tools\": [\n            {\n                \"name\": \"get_current_weather\",\n                \"description\": \"Get current weather for a city\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"city\": {\"type\": \"string\"},\n                        \"country\": {\"type\": \"string\"}\n                    },\n                    \"required\": [\"city\"]\n                }\n            },\n            {\n                \"name\": \"get_forecast\",\n                \"description\": \"Get 5-day weather forecast\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"city\": {\"type\": \"string\"},\n                        \"days\": {\"type\": \"number\"}\n                    },\n                    \"required\": [\"city\"]\n                }\n            }\n        ]\n    }\n\n    # Create Gateway with EZ Auth\n    cognito = client.create_oauth_authorizer_with_cognito(\"weather-service\")\n    gateway = client.setup_gateway(\n        gateway_name=\"weather-service\",\n        target_source=json.dumps(lambda_config),\n        execution_role_arn=\"arn:aws:iam::123:role/WeatherExecutionRole\",\n        authorizer_config=cognito['authorizer_config'],\n        target_type='lambda',\n        enable_semantic_search=True\n    )\n\n    return gateway, cognito['client_info']\n\n# Step 2: Use the Gateway\nasync def weather_agent():\n    gateway, client_info = await setup_weather_gateway()\n\n    # Initialize token manager\n    token_manager = GatewayTokenManager(\n        client_id=client_info['client_id'],\n        client_secret=client_info['client_secret'],\n        token_endpoint=client_info['token_endpoint'],\n        scope=client_info['scope']\n    )\n\n    # Get weather for multiple cities\n    cities = [\"Seattle\", \"New York\", \"London\"]\n\n    for city in cities:\n        token = await token_manager.get_token()\n\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                gateway.get_mcp_url(),\n                headers={\"Authorization\": f\"Bearer {token}\"},\n                json={\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": 1,\n                    \"method\": \"tools/call\",\n                    \"params\": {\n                        \"name\": \"get_current_weather\",\n                        \"arguments\": {\"city\": city}\n                    }\n                }\n            )\n\n            result = response.json()\n            print(f\"Weather in {city}: {result.get('result')}\")\n\n# Run the agent\nif __name__ == \"__main__\":\n    asyncio.run(weather_agent())\n</code></pre>"},{"location":"examples/memory_gateway_agent.html","title":"Amazon Bedrock AgentCore Quickstart","text":""},{"location":"examples/memory_gateway_agent.html#introduction","title":"Introduction","text":"<p>Amazon Bedrock AgentCore is a suite of services designed to accelerate AI agent development, deployment, and management. Unlike traditional ML platforms, AgentCore offers specialized infrastructure for agentic workflows with memory persistence, tool connectivity, and secure runtime environments.</p> <p>This quickstart guide will show you how to build and deploy a fully-functional AI agent with:</p> <ul> <li>Short-term and long-term memory to recall conversations within and across sessions</li> <li>Gateway integration for tool access (with a calculator example)</li> <li>Secure runtime deployment for production-ready hosting</li> </ul> <p>By the end, you'll have an agent that remembers user preferences, accesses tools, and runs in a secure, scalable environment\u2014all without managing complex infrastructure.</p>"},{"location":"examples/memory_gateway_agent.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>AWS CLI configured with credentials (<code>aws configure</code>)</li> <li>Access to Amazon Bedrock models (Claude 3.7 Sonnet)</li> <li>Python 3.10 or newer</li> </ul>"},{"location":"examples/memory_gateway_agent.html#installation","title":"Installation","text":"<p>Set up your environment:</p> <pre><code># Create and activate virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install required packages\npip install bedrock-agentcore strands-agents bedrock-agentcore-starter-toolkit\n</code></pre>"},{"location":"examples/memory_gateway_agent.html#lets-define-our-agent","title":"Let's Define Our Agent","text":"<p>First, we'll create an AI agent with memory capabilities using the Strands framework. This agent will form the foundation for our memory and gateway integrations.</p> <p>Create a file named <code>agent.py</code>:</p> <pre><code>\"\"\"\nThis is your AI agent with memory capabilities.\nIt uses Strands framework and can optionally connect to AgentCore Memory.\n\"\"\"\n\nimport os\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom bedrock_agentcore.memory import MemoryClient\nfrom strands import Agent\nfrom strands.hooks import AgentInitializedEvent, HookProvider, HookRegistry, MessageAddedEvent\n\n# Initialize the AgentCore runtime app\napp = BedrockAgentCoreApp()\n\n# Connect to memory service (if MEMORY_ID is set)\nmemory_client = MemoryClient(region_name='us-west-2')\nMEMORY_ID = os.getenv('MEMORY_ID')\n\nclass MemoryHook(HookProvider):\n    \"\"\"\n    This hook automatically handles memory operations:\n    - Loads previous conversation when agent starts\n    - Saves each message after it's processed\n    \"\"\"\n\n    def on_agent_initialized(self, event):\n        \"\"\"Runs when agent starts - loads conversation history\"\"\"\n        if not MEMORY_ID: return\n\n        # Get last 3 conversation turns from memory\n        turns = memory_client.get_last_k_turns(\n            memory_id=MEMORY_ID,\n            actor_id=\"user\",\n            session_id=event.agent.state.get(\"session_id\", \"default\"),\n            k=3  # Number of previous exchanges to remember\n        )\n\n        # Add conversation history to agent's context\n        if turns:\n            context = \"\\n\".join([f\"{m['role']}: {m['content']['text']}\"\n                               for t in turns for m in t])\n            event.agent.system_prompt += f\"\\n\\nPrevious:\\n{context}\"\n\n    def on_message_added(self, event):\n        \"\"\"Runs after each message - saves it to memory\"\"\"\n        if not MEMORY_ID: return\n\n        # Save the latest message to memory\n        msg = event.agent.messages[-1]\n        memory_client.create_event(\n            memory_id=MEMORY_ID,\n            actor_id=\"user\",\n            session_id=event.agent.state.get(\"session_id\", \"default\"),\n            messages=[(str(msg[\"content\"]), msg[\"role\"])]\n        )\n\n    def register_hooks(self, registry):\n        \"\"\"Registers both hooks with the agent\"\"\"\n        registry.add_callback(AgentInitializedEvent, self.on_agent_initialized)\n        registry.add_callback(MessageAddedEvent, self.on_message_added)\n\n# Create the Strands agent\nagent = Agent(\n    model=\"us.anthropic.claude-3-7-sonnet-20250219-v1:0\",  # Bedrock Claude model\n    system_prompt=\"You're a helpful assistant with memory.\",\n    hooks=[MemoryHook()] if MEMORY_ID else [],  # Add memory hook if configured\n    state={\"session_id\": \"default\"}\n)\n\n@app.entrypoint\ndef invoke(payload, context):\n    \"\"\"\n    Main entry point - this function runs for each user message.\n    - payload: Contains the user's prompt\n    - context: Contains runtime info like session_id\n    \"\"\"\n    # Use the session ID from runtime (for session isolation)\n    if hasattr(context, 'session_id'):\n        agent.state.set(\"session_id\", context.session_id)\n\n    # Process the user's message and return response\n    response = agent(payload.get(\"prompt\", \"Hello\"))\n    return response.message['content'][0]['text']\n\nif __name__ == \"__main__\":\n    app.run()  # Start the agent locally for testing\n</code></pre> <p>Let's also create a <code>requirements.txt</code> file for deployment:</p> <pre><code>bedrock-agentcore\nstrands-agents\n</code></pre>"},{"location":"examples/memory_gateway_agent.html#lets-add-short-term-and-long-term-memory","title":"Let's Add Short-term and Long-term Memory","text":"<p>Now, let's create memory resources for our agent. AgentCore Memory provides two types of memory:</p> <ol> <li>Short-term memory (STM): Stores raw conversation turns within a session</li> <li>Long-term memory (LTM): Intelligently extracts and retains information across sessions</li> </ol> <p>Create a file named <code>setup_memory.py</code>:</p> <pre><code>\"\"\"\nThis script creates two types of memory resources:\n1. STM (Short-Term Memory): Remembers within session only\n2. LTM (Long-Term Memory): Extracts and remembers across sessions\n\nRun this once to create your memory resources.\n\"\"\"\n\nfrom bedrock_agentcore.memory import MemoryClient\nimport uuid\n\n# Connect to AgentCore Memory service\nclient = MemoryClient(region_name='us-west-2')\n\nprint(\"Creating memory resources...\\n\")\n\n# === SHORT-TERM MEMORY ===\n# Only stores raw conversation, no intelligent extraction\nstm = client.create_memory_and_wait(\n    name=f\"Demo_STM_{uuid.uuid4().hex[:8]}\",  # Unique name\n    strategies=[],  # Empty = no extraction strategies\n    event_expiry_days=7  # Keep conversations for 7 days\n)\nprint(f\"\u2705 STM Memory Created: {stm['id']}\")\nprint(\"   What it does:\")\nprint(\"   - Stores exact conversation messages\")\nprint(\"   - Remembers within the same session only\")\nprint(\"   - Instant retrieval (no processing needed)\")\n\n# === LONG-TERM MEMORY ===\n# Intelligently extracts preferences and facts\nltm = client.create_memory_and_wait(\n    name=f\"Demo_LTM_{uuid.uuid4().hex[:8]}\",\n    strategies=[\n        # Extracts user preferences like \"I prefer Python\"\n        {\"userPreferenceMemoryStrategy\": {\n            \"name\": \"prefs\",\n            \"namespaces\": [\"/user/preferences\"]\n        }},\n        # Extracts facts like \"My birthday is in January\"\n        {\"semanticMemoryStrategy\": {\n            \"name\": \"facts\",\n            \"namespaces\": [\"/user/facts\"]\n        }}\n    ],\n    event_expiry_days=30  # Keep for 30 days\n)\nprint(f\"\\n\u2705 LTM Memory Created: {ltm['id']}\")\nprint(\"   What it does:\")\nprint(\"   - Everything STM does PLUS:\")\nprint(\"   - Extracts preferences and facts automatically\")\nprint(\"   - Remembers across different sessions\")\nprint(\"   - Needs 5-10 seconds to process extractions\")\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Choose which memory to use:\")\nprint(f\"  export MEMORY_ID={stm['id']}  # For STM demo\")\nprint(f\"  export MEMORY_ID={ltm['id']}  # For LTM demo\")\nprint(\"=\"*60)\n</code></pre> <p>Run the memory setup script:</p> <pre><code>python setup_memory.py\n</code></pre> <p>You'll see output showing the IDs for both memory types. Note these IDs\u2014you'll use them to set the <code>MEMORY_ID</code> environment variable when deploying your agent.</p>"},{"location":"examples/memory_gateway_agent.html#lets-add-gateway-with-a-calculator-tool","title":"Let's Add Gateway with a Calculator Tool","text":"<p>Now we'll add a gateway with a calculator tool. Gateway allows your agent to access tools securely.</p> <p>Create <code>setup_gateway.py</code>:</p> <pre><code>\"\"\"\nThis script creates a gateway with a calculator tool.\nThe gateway provides a secure way for your agent to access tools.\n\"\"\"\n\nfrom bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\nimport json\nimport logging\nimport uuid\n\n# Create a unique name for the gateway\ngateway_name = f\"Demo_Gateway_{uuid.uuid4().hex[:8]}\"\n\n# Initialize client\nclient = GatewayClient(region_name=\"us-west-2\")\nclient.logger.setLevel(logging.INFO)\n\n# Create OAuth authorizer with Cognito\nprint(\"Creating OAuth authorization server...\")\ncognito_response = client.create_oauth_authorizer_with_cognito(gateway_name)\nprint(\"\u2705 Authorization server created\\n\")\n\n# Create Gateway\nprint(\"Creating Gateway...\")\ngateway = client.create_mcp_gateway(\n    name=gateway_name,\n    role_arn=None,  # Auto-creates IAM role\n    authorizer_config=cognito_response[\"authorizer_config\"],\n    enable_semantic_search=True,\n)\nprint(f\"\u2705 Gateway created: {gateway['gatewayUrl']}\\n\")\n\n# Fix IAM permissions\nprint(\"Fixing IAM permissions...\")\nclient.fix_iam_permissions(gateway)\nprint(\"\u23f3 Waiting 30s for IAM propagation...\")\nimport time\ntime.sleep(30)\nprint(\"\u2705 IAM permissions configured\\n\")\n\n# Add calculator Lambda target\nprint(\"Adding calculator Lambda target...\")\ncalculator_schema = {\n    \"inlinePayload\": [\n        {\n            \"name\": \"calculate\",\n            \"description\": \"Perform a mathematical calculation\",\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"operation\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"add\", \"subtract\", \"multiply\", \"divide\"],\n                        \"description\": \"The mathematical operation to perform\"\n                    },\n                    \"a\": {\"type\": \"number\", \"description\": \"First operand\"},\n                    \"b\": {\"type\": \"number\", \"description\": \"Second operand\"}\n                },\n                \"required\": [\"operation\", \"a\", \"b\"]\n            }\n        }\n    ]\n}\n\nlambda_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=\"CalculatorTool\",\n    target_type=\"lambda\",\n    target_payload={\"toolSchema\": calculator_schema}\n)\nprint(\"\u2705 Calculator target added\\n\")\n\n# Get access token\nprint(\"Getting access token...\")\naccess_token = client.get_access_token_for_cognito(cognito_response[\"client_info\"])\nprint(\"\u2705 Access token obtained\\n\")\n\n# Save configuration for agent\nconfig = {\n    \"gateway_url\": gateway[\"gatewayUrl\"],\n    \"gateway_id\": gateway[\"gatewayId\"],\n    \"access_token\": access_token\n}\n\nwith open(\"gateway_config.json\", \"w\") as f:\n    json.dump(config, f, indent=2)\n\nprint(\"=\" * 60)\nprint(\"\u2705 Gateway setup complete!\")\nprint(f\"Gateway URL: {gateway['gatewayUrl']}\")\nprint(f\"Gateway ID: {gateway['gatewayId']}\")\nprint(\"\\nConfiguration saved to: gateway_config.json\")\nprint(\"=\" * 60)\n</code></pre> <p>Run the gateway setup script:</p> <pre><code>python setup_gateway.py\n</code></pre> <p>The script creates a gateway with a calculator tool and saves the configuration to <code>gateway_config.json</code>.</p>"},{"location":"examples/memory_gateway_agent.html#lets-update-our-agent-to-use-the-gateway","title":"Let's Update Our Agent to Use the Gateway","text":"<p>Now, let's update our agent to use the gateway. Create <code>agent_with_gateway.py</code>:</p> <pre><code>\"\"\"\nEnhanced agent with both memory and gateway integration.\n\"\"\"\n\nimport os\nimport json\nfrom mcp import ClientSession\nfrom mcp.client.streamable_http import streamablehttp_client\nimport asyncio\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom bedrock_agentcore.memory import MemoryClient\nfrom strands import Agent\nfrom strands.hooks import AgentInitializedEvent, HookProvider, HookRegistry, MessageAddedEvent\n\n# Initialize the AgentCore runtime app\napp = BedrockAgentCoreApp()\n\n# Connect to memory service (if MEMORY_ID is set)\nmemory_client = MemoryClient(region_name='us-west-2')\nMEMORY_ID = os.getenv('MEMORY_ID')\n\n# Load gateway configuration\ngateway_config = {}\ntry:\n    with open(\"gateway_config.json\", \"r\") as f:\n        gateway_config = json.load(f)\n    print(f\"Loaded gateway config: {gateway_config['gateway_url']}\")\nexcept:\n    print(\"Gateway config not found. Only memory features will be available.\")\n\n\nclass MemoryHook(HookProvider):\n    \"\"\"Handles memory operations - same as before\"\"\"\n\n    def on_agent_initialized(self, event):\n        if not MEMORY_ID: return\n\n        turns = memory_client.get_last_k_turns(\n            memory_id=MEMORY_ID,\n            actor_id=\"user\",\n            session_id=event.agent.state.get(\"session_id\", \"default\"),\n            k=3\n        )\n\n        if turns:\n            context = \"\\n\".join([f\"{m['role']}: {m['content']['text']}\"\n                               for t in turns for m in t])\n            event.agent.system_prompt += f\"\\n\\nPrevious:\\n{context}\"\n\n    def on_message_added(self, event):\n        if not MEMORY_ID: return\n\n        msg = event.agent.messages[-1]\n        memory_client.create_event(\n            memory_id=MEMORY_ID,\n            actor_id=\"user\",\n            session_id=event.agent.state.get(\"session_id\", \"default\"),\n            messages=[(str(msg[\"content\"]), msg[\"role\"])]\n        )\n\n    def register_hooks(self, registry):\n        registry.add_callback(AgentInitializedEvent, self.on_agent_initialized)\n        registry.add_callback(MessageAddedEvent, self.on_message_added)\n\n\nasync def get_gateway_tools():\n    \"\"\"Get tools from gateway using MCP\"\"\"\n    if not gateway_config:\n        return None\n\n    try:\n        gateway_url = gateway_config[\"gateway_url\"]\n        access_token = gateway_config[\"access_token\"]\n\n        headers = {\"Authorization\": f\"Bearer {access_token}\"}\n\n        async with streamablehttp_client(gateway_url, headers=headers) as (read, write, _):\n            async with ClientSession(read, write) as session:\n                await session.initialize()\n                tools_result = await session.list_tools()\n                print(f\"Found {len(tools_result.tools)} tools in Gateway\")\n                return tools_result.tools\n    except Exception as e:\n        print(f\"Gateway error: {e}\")\n        return None\n\n\n# Create the Strands agent\nagent = Agent(\n    model=\"us.anthropic.claude-3-7-sonnet-20250219-v1:0\",\n    system_prompt=\"You're a helpful assistant with memory and calculation abilities.\",\n    hooks=[MemoryHook()] if MEMORY_ID else [],\n    state={\"session_id\": \"default\"}\n)\n\n@app.entrypoint\ndef invoke(payload, context):\n    \"\"\"Main entry point with gateway integration\"\"\"\n    # Use the session ID from runtime\n    if hasattr(context, 'session_id'):\n        agent.state.set(\"session_id\", context.session_id)\n\n    # Try to get gateway tools\n    gateway_tools = None\n    if gateway_config:\n        try:\n            gateway_tools = asyncio.run(get_gateway_tools())\n            if gateway_tools:\n                # Update agent with gateway tools\n                agent.tools = gateway_tools\n        except Exception as e:\n            print(f\"Error getting gateway tools: {e}\")\n\n    # Process the user's message\n    response = agent(payload.get(\"prompt\", \"Hello\"))\n    return response.message['content'][0]['text']\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Update <code>requirements.txt</code> to include MCP:</p> <pre><code>bedrock-agentcore\nstrands-agents\nmcp\n</code></pre>"},{"location":"examples/memory_gateway_agent.html#deploying-to-agentcore-runtime","title":"Deploying to AgentCore Runtime","text":"<p>Now, let's deploy our agent to AgentCore Runtime. Runtime provides a secure, managed environment for your agent.</p> <pre><code># Configure the agent for deployment\nagentcore configure -e agent_with_gateway.py\n\n# Deploy with short-term memory\nexport MEMORY_ID=&lt;your-stm-id&gt;  # Use the STM ID from the setup_memory.py output\nagentcore launch\n</code></pre> <p>AgentCore CLI will handle: 1. Creating a container image with your agent code 2. Setting up necessary IAM roles and permissions 3. Deploying to a secure, managed runtime environment</p> <p>After deployment completes (it may take a few minutes), you'll see output with your agent's ARN and endpoint details.</p>"},{"location":"examples/memory_gateway_agent.html#testing-your-agent","title":"Testing Your Agent","text":"<p>Now let's test our agent's memory and gateway capabilities!</p>"},{"location":"examples/memory_gateway_agent.html#testing-short-term-memory","title":"Testing Short-Term Memory","text":"<pre><code># First interaction - tell agent your name\nagentcore invoke '{\"prompt\": \"My name is Bob\"}'\n\n# Second interaction - see if agent remembers\nagentcore invoke '{\"prompt\": \"What is my name?\"}'\n</code></pre> <p>You should see the agent respond with \"Your name is Bob\" in the second interaction, demonstrating short-term memory within the session.</p>"},{"location":"examples/memory_gateway_agent.html#testing-gateway-calculator","title":"Testing Gateway Calculator","text":"<pre><code># Test calculator functionality\nagentcore invoke '{\"prompt\": \"Calculate 25 multiplied by 18\"}'\n\n# Try addition\nagentcore invoke '{\"prompt\": \"What is 42 + 28?\"}'\n</code></pre> <p>The agent should use the gateway calculator tool to perform these calculations and return the correct results.</p>"},{"location":"examples/memory_gateway_agent.html#testing-long-term-memory","title":"Testing Long-Term Memory","text":"<p>Now, let's deploy with long-term memory and test cross-session memory:</p> <pre><code># Update deployment with long-term memory\nexport MEMORY_ID=&lt;your-ltm-id&gt;  # Use the LTM ID from setup_memory.py output\nagentcore launch\n\n# Tell agent your preferences in one session\nSESSION1=\"first-session-12345678901234567890123456\"\nagentcore invoke '{\"prompt\": \"I prefer Python and short answers\"}' --session-id $SESSION1\n\n# Wait for extraction (async process)\necho \"Waiting 10 seconds for LTM extraction...\"\nsleep 10\n\n# Different session still remembers!\nSESSION2=\"second-session-98765432109876543210987654\"\nagentcore invoke '{\"prompt\": \"What are my preferences?\"}' --session-id $SESSION2\n</code></pre> <p>Even though you're using a completely different session, the agent should remember that you prefer Python and short answers, demonstrating long-term memory extraction and recall.</p>"},{"location":"examples/memory_gateway_agent.html#whats-happening-behind-the-scenes","title":"What's Happening Behind the Scenes?","text":"<ol> <li> <p>Short-Term Memory: The <code>MemoryHook</code> class automatically saves each message to AgentCore Memory and loads recent conversation turns when the agent starts.</p> </li> <li> <p>Long-Term Memory: The memory strategies you created automatically extract user preferences and facts from conversations. These extracted memories persist across different sessions.</p> </li> <li> <p>Gateway: The agent connects to the gateway you created and discovers the calculator tool using the MCP (Model Context Protocol). When you ask calculation questions, the agent invokes this tool to get accurate results.</p> </li> <li> <p>Runtime: AgentCore Runtime provides a secure, isolated environment for your agent with automatic scaling and session management.</p> </li> </ol>"},{"location":"examples/memory_gateway_agent.html#conclusion","title":"Conclusion","text":"<p>Congratulations! In just 15 minutes, you've built and deployed a production-ready AI agent with:</p> <ul> <li>Memory capabilities that persist both within and across sessions</li> <li>Tool access through Gateway for accurate calculations</li> <li>Secure runtime deployment for production use</li> </ul> <p>This foundation can be extended with additional tools, more sophisticated memory strategies, and integration with other AWS services to build powerful, context-aware AI applications.</p>"},{"location":"examples/memory_gateway_agent.html#next-steps","title":"Next Steps","text":"<ul> <li>Add more tools to your gateway (e.g., weather API, database access)</li> <li>Implement more complex memory strategies</li> <li>Build a web interface for your agent using API Gateway and Lambda</li> <li>Explore AgentCore Browser for web browsing capabilities</li> </ul>"},{"location":"examples/runtime-framework-agents.html","title":"Framework Agents Examples","text":"<p>This guide shows how to use popular AI agent frameworks with Amazon Bedrock AgentCore Runtime.</p>"},{"location":"examples/runtime-framework-agents.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you've completed the QuickStart guide and have: - AWS credentials configured - AgentCore CLI installed (<code>agentcore --help</code> works) - A project folder with virtual environment activated</p>"},{"location":"examples/runtime-framework-agents.html#langgraph-agent","title":"LangGraph Agent","text":"<p>LangGraph enables building stateful, multi-actor applications with LLMs.</p>"},{"location":"examples/runtime-framework-agents.html#installation","title":"Installation","text":"<pre><code>pip install langchain-aws langgraph\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#create-the-agent","title":"Create the Agent","text":"<p>Create <code>langgraph_agent.py</code>:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom langchain_aws import ChatBedrock\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.graph.message import add_messages\nfrom typing import Annotated, TypedDict\n\napp = BedrockAgentCoreApp()\n\n# Define state for conversation memory\nclass State(TypedDict):\n    messages: Annotated[list, add_messages]\n\n# Initialize Bedrock LLM\nllm = ChatBedrock(\n    model_id=\"us.anthropic.claude-3-7-sonnet-20250219-v1:0\",\n    model_kwargs={\"temperature\": 0.7}\n)\n\n# Define the chat node that processes messages\ndef chat_node(state: State):\n    response = llm.invoke(state[\"messages\"])\n    return {\"messages\": [response]}\n\n# Build the graph\nworkflow = StateGraph(State)\nworkflow.add_node(\"chat\", chat_node)\nworkflow.add_edge(START, \"chat\")\nworkflow.add_edge(\"chat\", END)\ngraph = workflow.compile()\n\n@app.entrypoint\ndef invoke(payload):\n    user_message = payload.get(\"prompt\", \"Hello!\")\n    result = graph.invoke({\n        \"messages\": [{\"role\": \"user\", \"content\": user_message}]\n    })\n    # Extract the assistant's response\n    last_message = result[\"messages\"][-1]\n    return {\"result\": last_message.content}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#deploy","title":"Deploy","text":"<pre><code># Create requirements.txt for container\necho \"langchain-aws\nlanggraph\" &gt; requirements.txt\n\n# Configure and deploy\nagentcore configure --entrypoint langgraph_agent.py\nagentcore launch\n\n# Test\nagentcore invoke '{\"prompt\": \"Explain LangGraph in one sentence\"}'\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#crewai-agent","title":"CrewAI Agent","text":"<p>CrewAI enables building collaborative AI agent teams.</p>"},{"location":"examples/runtime-framework-agents.html#installation_1","title":"Installation","text":"<pre><code>pip install crewai crewai-tools\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#create-the-agent_1","title":"Create the Agent","text":"<p>Create <code>crewai_agent.py</code>:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom crewai import Agent, Task, Crew, Process\nimport os\n\napp = BedrockAgentCoreApp()\n\n# Set AWS region for litellm (used by CrewAI)\nos.environ[\"AWS_DEFAULT_REGION\"] = os.environ.get(\"AWS_REGION\", \"us-west-2\")\n\n# Create an agent with specific role and capabilities\nresearcher = Agent(\n    role=\"Research Assistant\",\n    goal=\"Provide helpful and accurate information\",\n    backstory=\"You are a knowledgeable research assistant with expertise in many domains\",\n    verbose=False,\n    llm=\"bedrock/us.anthropic.claude-3-7-sonnet-20250219-v1:0\",  # litellm format required\n    max_iter=2  # Limit iterations to control costs\n)\n\n@app.entrypoint\ndef invoke(payload):\n    user_message = payload.get(\"prompt\", \"Hello!\")\n\n    # Create a task for the agent\n    task = Task(\n        description=user_message,\n        agent=researcher,\n        expected_output=\"A helpful and informative response\"\n    )\n\n    # Create and run the crew\n    crew = Crew(\n        agents=[researcher],\n        tasks=[task],\n        process=Process.sequential,\n        verbose=False\n    )\n\n    result = crew.kickoff()\n    return {\"result\": result.raw}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#deploy_1","title":"Deploy","text":"<pre><code># Create requirements.txt for container\necho \"crewai\ncrewai-tools\" &gt; requirements.txt\n\n# Configure and deploy\nagentcore configure --entrypoint crewai_agent.py\nagentcore launch\n\n# Test\nagentcore invoke '{\"prompt\": \"What are the benefits of using CrewAI?\"}'\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#key-differences-between-frameworks","title":"Key Differences Between Frameworks","text":"Framework Best For Key Features Strands Simple agents Minimal setup, built-in tools, great for beginners LangGraph Stateful workflows Graph-based flows, state management, complex routing CrewAI Multi-agent teams Role-based agents, collaborative tasks, delegation"},{"location":"examples/runtime-framework-agents.html#common-patterns","title":"Common Patterns","text":""},{"location":"examples/runtime-framework-agents.html#adding-tools","title":"Adding Tools","text":"<p>All frameworks support tools. Here's an example with Strands:</p> <pre><code>from strands import Agent, tool\n\n@tool\ndef get_weather(location: str) -&gt; str:\n    \"\"\"Get weather for a location.\"\"\"\n    return f\"Weather in {location}: Sunny, 72\u00b0F\"\n\nagent = Agent(tools=[get_weather])\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#error-handling","title":"Error Handling","text":"<p>Always include error handling in production:</p> <pre><code>@app.entrypoint\ndef invoke(payload):\n    try:\n        user_message = payload.get(\"prompt\", \"Hello!\")\n        # Your agent logic here\n        return {\"result\": response}\n    except Exception as e:\n        app.logger.error(f\"Agent error: {e}\")\n        return {\"error\": \"An error occurred processing your request\"}\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#using-environment-variables","title":"Using Environment Variables","text":"<p>For API keys or configuration:</p> <pre><code>import os\n\n@app.entrypoint\ndef invoke(payload):\n    api_key = os.environ.get(\"MY_API_KEY\")\n    # Use the API key in your agent logic\n</code></pre> <p>Then set the environment variable during deployment:</p> <pre><code>agentcore launch --env MY_API_KEY=your-key-here\n</code></pre>"},{"location":"examples/runtime-framework-agents.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/runtime-framework-agents.html#model-access-issues","title":"Model Access Issues","text":"<p>If you see \"model access denied\": 1. Ensure Claude models are enabled in Bedrock console 2. Check you're using the correct model ID format 3. Verify your AWS region matches where models are enabled</p>"},{"location":"examples/runtime-framework-agents.html#crewai-specific-issues","title":"CrewAI Specific Issues","text":"<p>CrewAI uses litellm, which requires: - Model format: <code>bedrock/model-id</code> (not just <code>model-id</code>) - AWS_DEFAULT_REGION environment variable set</p>"},{"location":"examples/semantic_search.html","title":"Semantic Search Memory Example","text":"<p>This example demonstrates the complete workflow for creating a memory resource with semantic strategy, writing events, and retrieving memory records.</p> <pre><code># Semantic Search Memory Example\n\nfrom bedrock_agentcore_starter_toolkit.operations.memory.manager import MemoryManager\nfrom bedrock_agentcore.memory.session import MemorySessionManager\nfrom bedrock_agentcore.memory.constants import ConversationalMessage, MessageRole\nfrom bedrock_agentcore_starter_toolkit.operations.memory.models.strategies import SemanticStrategy\nimport time\n\nmemory_manager = MemoryManager(region_name=\"us-west-2\")\n\nprint(\"Creating memory resource...\")\n\nmemory = memory_manager.get_or_create_memory(\n    name=\"CustomerSupportSemantic\",\n    description=\"Customer support memory store\",\n    strategies=[\n        SemanticStrategy(\n            name=\"semanticLongTermMemory\",\n            namespaces=['/strategies/{memoryStrategyId}/actors/{actorId}'],\n        )\n    ]\n)\n\nprint(f\"Memory ID: {memory.get('id')}\")\n\n# Create a session to store memory events\nsession_manager = MemorySessionManager(\n    memory_id=memory.get(\"id\"),\n    region_name=\"us-west-2\")\n\nsession = session_manager.create_memory_session(\n    actor_id=\"User1\",\n    session_id=\"OrderSupportSession1\"\n)\n\n# Write memory events (conversation turns)\nsession.add_turns(\n    messages=[\n        ConversationalMessage(\n            \"Hi, how can I help you today?\",\n            MessageRole.ASSISTANT)],\n)\n\nsession.add_turns(\n    messages=[\n        ConversationalMessage(\n            \"Hi, I am a new customer. I just made an order, but it hasn't arrived. The Order number is #35476\",\n            MessageRole.USER)],\n)\n\nsession.add_turns(\n    messages=[\n        ConversationalMessage(\n            \"I'm sorry to hear that. Let me look up your order.\",\n            MessageRole.ASSISTANT)],\n)\n\n# Get the last k turns in the session\nturns = session.get_last_k_turns(k=5)\n\nfor turn in turns:\n    print(f\"Turn: {turn}\")\n\n# List all memory records\nmemory_records = session.list_long_term_memory_records(\n    namespace_prefix=\"/\"\n)\n\nfor record in memory_records:\n    print(f\"Memory record: {record}\")\n    print(\"--------------------------------------------------------------------\")\n\n# Perform a semantic search\nmemory_records = session.search_long_term_memories(\n    query=\"can you summarize the support issue\",\n    namespace_prefix=\"/\",\n    top_k=3\n)\n\nfor record in memory_records:\n    print(f\"retrieved memory: {record}\")\n    print(\"--------------------------------------------------------------------\")\n\n\n# Cleanup - delete the memory resource\nprint(\"Cleaning up...\")\n\nmemory_manager.delete_memory(memory_id=memory.get(\"id\"))\n</code></pre>"},{"location":"examples/session-management.html","title":"Session Management","text":"<p>Agent that maintains conversation state using session IDs.</p>"},{"location":"examples/session-management.html#handler-code","title":"Handler Code","text":"<pre><code># handler.py\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom bedrock_agentcore.context import RequestContext\n\napp = BedrockAgentCoreApp()\n\n# Simple in-memory session storage (use database in production)\nsessions = {}\n\n@app.entrypoint\ndef chat_handler(payload, context: RequestContext):\n    \"\"\"Handle chat with session management\"\"\"\n    session_id = context.session_id or \"default\"\n    message = payload.get(\"message\", \"\")\n\n    # Initialize session if new\n    if session_id not in sessions:\n        sessions[session_id] = {\n            \"messages\": [],\n            \"count\": 0\n        }\n\n    # Add message to session\n    sessions[session_id][\"messages\"].append(message)\n    sessions[session_id][\"count\"] += 1\n\n    # Generate response\n    count = sessions[session_id][\"count\"]\n    return {\n        \"response\": f\"Message {count}: You said '{message}'\",\n        \"session_id\": session_id,\n        \"message_count\": count\n    }\n\napp.run()\n</code></pre>"},{"location":"examples/session-management.html#usage","title":"Usage","text":""},{"location":"examples/session-management.html#cli","title":"CLI","text":"<pre><code>agentcore configure --entrypoint handler.py\nagentcore launch\n\n# Start conversation\nagentcore invoke '{\"message\": \"Hello\"}' --session-id conv1\n\n# Continue conversation\nagentcore invoke '{\"message\": \"How are you?\"}' --session-id conv1\n\n# Session id is automatically persisted and reused in .bedrock_agentcore.yaml\nagentcore invoke '{\"message\": \"Goodbye\"}'\n\n# Start a new conversation\nagentcore invoke '{\"message\": \"Hello\"}' --session-id conv2\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/basic-runtime/runtime-cfn-template.html","title":"Runtime cfn template","text":"<pre><code>AWSTemplateFormatVersion: \"2010-09-09\"\nDescription: \"Basic AgentCore deployment - Simple agent runtime without memory, code interpreter, or browser\"\n\n# ============================================================================\n# PARAMETERS SECTION\n# ============================================================================\nParameters:\n  # Agent Configuration\n  AgentName:\n    Type: String\n    Default: \"BasicAgent\"\n    Description: \"Name for the agent runtime\"\n    AllowedPattern: \"^[a-zA-Z][a-zA-Z0-9_]{0,47}$\"\n    ConstraintDescription: \"Must start with a letter, max 48 characters, alphanumeric and underscores only\"\n\n  # Container Configuration\n  ImageTag:\n    Type: String\n    Default: \"latest\"\n    Description: \"Tag for the Docker image\"\n\n  # Network Configuration\n  NetworkMode:\n    Type: String\n    Default: \"PUBLIC\"\n    Description: \"Network mode for AgentCore resources\"\n    AllowedValues:\n      - PUBLIC\n      - PRIVATE\n\n  # ECR Configuration\n  ECRRepositoryName:\n    Type: String\n    Default: \"basic-agent\"\n    Description: \"Name of the ECR repository\"\n\n# ============================================================================\n# METADATA SECTION\n# ============================================================================\nMetadata:\n  AWS::CloudFormation::Interface:\n    ParameterGroups:\n      - Label:\n          default: \"Agent Configuration\"\n        Parameters:\n          - AgentName\n          - NetworkMode\n      - Label:\n          default: \"Container Configuration\"\n        Parameters:\n          - ECRRepositoryName\n          - ImageTag\n    ParameterLabels:\n      AgentName:\n        default: \"Agent Name\"\n      NetworkMode:\n        default: \"Network Mode\"\n      ECRRepositoryName:\n        default: \"ECR Repository Name\"\n      ImageTag:\n        default: \"Image Tag\"\n\n# ============================================================================\n# RESOURCES SECTION\n# ============================================================================\nResources:\n  # ========================================================================\n  # ECR MODULE - Container Registry\n  # ========================================================================\n\n  ECRRepository:\n    Type: AWS::ECR::Repository\n    DeletionPolicy: Delete\n    UpdateReplacePolicy: Delete\n    Properties:\n      RepositoryName: !Sub \"${AWS::StackName}-${ECRRepositoryName}\"\n      ImageTagMutability: MUTABLE\n      EmptyOnDelete: true\n      ImageScanningConfiguration:\n        ScanOnPush: true\n      RepositoryPolicyText:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AllowPullFromAccount\n            Effect: Allow\n            Principal:\n              AWS: !Sub \"arn:aws:iam::${AWS::AccountId}:root\"\n            Action:\n              - ecr:BatchGetImage\n              - ecr:GetDownloadUrlForLayer\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-ecr-repository\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: ECR\n\n  # ========================================================================\n  # IAM MODULE - Security and Permissions\n  # ========================================================================\n\n  # Agent Execution Role\n  AgentExecutionRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-agent-execution-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AssumeRolePolicy\n            Effect: Allow\n            Principal:\n              Service: bedrock-agentcore.amazonaws.com\n            Action: sts:AssumeRole\n            Condition:\n              StringEquals:\n                aws:SourceAccount: !Ref AWS::AccountId\n              ArnLike:\n                aws:SourceArn: !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*\"\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess\n      Policies:\n        - PolicyName: AgentCoreExecutionPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRImageAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchCheckLayerAvailability\n                Resource: !GetAtt ECRRepository.Arn\n              - Sid: ECRTokenAccess\n                Effect: Allow\n                Action:\n                  - ecr:GetAuthorizationToken\n                Resource: \"*\"\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:DescribeLogStreams\n                  - logs:CreateLogGroup\n                  - logs:DescribeLogGroups\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: \"*\"\n              - Sid: XRayTracing\n                Effect: Allow\n                Action:\n                  - xray:PutTraceSegments\n                  - xray:PutTelemetryRecords\n                  - xray:GetSamplingRules\n                  - xray:GetSamplingTargets\n                Resource: \"*\"\n              - Sid: CloudWatchMetrics\n                Effect: Allow\n                Resource: \"*\"\n                Action: cloudwatch:PutMetricData\n                Condition:\n                  StringEquals:\n                    cloudwatch:namespace: bedrock-agentcore\n              - Sid: GetAgentAccessToken\n                Effect: Allow\n                Action:\n                  - bedrock-agentcore:GetWorkloadAccessToken\n                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT\n                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId\n                Resource:\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default\"\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/*\"\n              - Sid: BedrockModelInvocation\n                Effect: Allow\n                Action:\n                  - bedrock:InvokeModel\n                  - bedrock:InvokeModelWithResponseStream\n                Resource: \"*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-agent-execution-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # CodeBuild Service Role\n  CodeBuildRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-codebuild-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: codebuild.amazonaws.com\n            Action: sts:AssumeRole\n      Policies:\n        - PolicyName: CodeBuildPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:CreateLogGroup\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: !Sub \"arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*\"\n              - Sid: ECRAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchCheckLayerAvailability\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchGetImage\n                  - ecr:GetAuthorizationToken\n                  - ecr:PutImage\n                  - ecr:InitiateLayerUpload\n                  - ecr:UploadLayerPart\n                  - ecr:CompleteLayerUpload\n                Resource:\n                  - !GetAtt ECRRepository.Arn\n                  - \"*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # Lambda Custom Resource Role\n  CustomResourceRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-custom-resource-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n            Action: sts:AssumeRole\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\n      Policies:\n        - PolicyName: CustomResourcePolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRAccess\n                Effect: Allow\n                Action:\n                  - ecr:ListImages\n                  - ecr:BatchDeleteImage\n                  - ecr:GetAuthorizationToken\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:PutImage\n                  - ecr:InitiateLayerUpload\n                  - ecr:UploadLayerPart\n                  - ecr:CompleteLayerUpload\n                Resource: !GetAtt ECRRepository.Arn\n              - Sid: CodeBuildAccess\n                Effect: Allow\n                Action:\n                  - codebuild:StartBuild\n                  - codebuild:BatchGetBuilds\n                  - codebuild:BatchGetProjects\n                Resource: !GetAtt AgentImageBuildProject.Arn\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-custom-resource-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # ========================================================================\n  # LAMBDA MODULE - Custom Resources\n  # ========================================================================\n\n  CodeBuildTriggerFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub \"${AWS::StackName}-codebuild-trigger\"\n      Description: \"Triggers CodeBuild projects as CloudFormation custom resource\"\n      Handler: index.handler\n      Role: !GetAtt CustomResourceRole.Arn\n      Runtime: python3.9\n      Timeout: 900\n      Code:\n        ZipFile: |\n          import boto3\n          import cfnresponse\n          import json\n          import logging\n          import time\n\n          logger = logging.getLogger()\n          logger.setLevel(logging.INFO)\n\n          def handler(event, context):\n              logger.info('Received event: %s', json.dumps(event))\n\n              try:\n                  if event['RequestType'] == 'Delete':\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})\n                      return\n\n                  project_name = event['ResourceProperties']['ProjectName']\n                  wait_for_completion = event['ResourceProperties'].get('WaitForCompletion', 'true').lower() == 'true'\n\n                  logger.info(f\"Attempting to start CodeBuild project: {project_name}\")\n                  logger.info(f\"Wait for completion: {wait_for_completion}\")\n\n                  # Start the CodeBuild project\n                  codebuild = boto3.client('codebuild')\n\n                  # First, verify the project exists\n                  try:\n                      project_info = codebuild.batch_get_projects(names=[project_name])\n                      if not project_info['projects']:\n                          raise Exception(f\"CodeBuild project '{project_name}' not found\")\n                      logger.info(f\"CodeBuild project '{project_name}' found\")\n                  except Exception as e:\n                      logger.error(f\"Error checking project existence: {str(e)}\")\n                      raise\n\n                  response = codebuild.start_build(projectName=project_name)\n                  build_id = response['build']['id']\n\n                  logger.info(f\"Successfully started build: {build_id}\")\n\n                  if not wait_for_completion:\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                          'BuildId': build_id,\n                          'Status': 'STARTED'\n                      })\n                      return\n\n                  # Wait for the build to complete\n                  max_wait_time = context.get_remaining_time_in_millis() / 1000 - 30  # Leave 30s buffer\n                  start_time = time.time()\n\n                  while True:\n                      if time.time() - start_time &gt; max_wait_time:\n                          error_message = f\"Build {build_id} timed out\"\n                          logger.error(error_message)\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': error_message})\n                          return\n\n                      build_response = codebuild.batch_get_builds(ids=[build_id])\n                      build_status = build_response['builds'][0]['buildStatus']\n\n                      if build_status == 'SUCCEEDED':\n                          logger.info(f\"Build {build_id} succeeded\")\n                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                              'BuildId': build_id,\n                              'Status': build_status\n                          })\n                          return\n                      elif build_status in ['FAILED', 'FAULT', 'STOPPED', 'TIMED_OUT']:\n                          error_message = f\"Build {build_id} failed with status: {build_status}\"\n                          logger.error(error_message)\n\n                          # Get build logs for debugging\n                          try:\n                              logs_info = build_response['builds'][0].get('logs', {})\n                              if logs_info.get('groupName') and logs_info.get('streamName'):\n                                  logger.info(f\"Build logs available in CloudWatch\")\n                          except Exception as log_error:\n                              logger.warning(f\"Could not get log information: {log_error}\")\n\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {\n                              'Error': error_message,\n                              'BuildId': build_id\n                          })\n                          return\n\n                      logger.info(f\"Build {build_id} status: {build_status}\")\n                      time.sleep(30)  # Check every 30 seconds\n\n              except Exception as e:\n                  logger.error('Error: %s', str(e))\n                  cfnresponse.send(event, context, cfnresponse.FAILED, {\n                      'Error': str(e)\n                  })\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-trigger\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: Lambda\n\n  # ========================================================================\n  # CODEBUILD MODULE - Container Image Building\n  # ========================================================================\n\n  AgentImageBuildProject:\n    Type: AWS::CodeBuild::Project\n    Properties:\n      Name: !Sub \"${AWS::StackName}-basic-agent-build\"\n      Description: !Sub \"Build basic agent Docker image for ${AWS::StackName}\"\n      ServiceRole: !GetAtt CodeBuildRole.Arn\n      Artifacts:\n        Type: NO_ARTIFACTS\n      Environment:\n        Type: ARM_CONTAINER\n        ComputeType: BUILD_GENERAL1_LARGE\n        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0\n        PrivilegedMode: true\n        EnvironmentVariables:\n          - Name: AWS_DEFAULT_REGION\n            Value: !Ref AWS::Region\n          - Name: AWS_ACCOUNT_ID\n            Value: !Ref AWS::AccountId\n          - Name: IMAGE_REPO_NAME\n            Value: !Ref ECRRepository\n          - Name: IMAGE_TAG\n            Value: !Ref ImageTag\n          - Name: STACK_NAME\n            Value: !Ref AWS::StackName\n      Source:\n        Type: NO_SOURCE\n        BuildSpec: |\n          version: 0.2\n          phases:\n            pre_build:\n              commands:\n                - echo Logging in to Amazon ECR...\n                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com\n            build:\n              commands:\n                - echo Build started on `date`\n                - echo Building the Docker image for basic agent ARM64...\n\n                # Step 1.1: Create requirements.txt\n                - |\n                  cat &gt; requirements.txt &lt;&lt; 'EOF'\n                  strands-agents\n                  boto3\n                  bedrock-agentcore\n                  EOF\n\n                # Step 1.2: Create my_agent.py (simplified basic version)\n                - |\n                  cat &gt; my_agent.py &lt;&lt; 'EOF'\n                  from strands import Agent\n                  import os\n                  from bedrock_agentcore.runtime import BedrockAgentCoreApp\n\n                  app = BedrockAgentCoreApp()\n\n                  def create_basic_agent() -&gt; Agent:\n                      \"\"\"Create a basic agent with simple functionality\"\"\"\n                      system_prompt = \"\"\"You are a helpful assistant. Answer questions clearly and concisely.\"\"\"\n\n                      return Agent(\n                          system_prompt=system_prompt,\n                          name=\"BasicAgent\"\n                      )\n\n                  @app.entrypoint\n                  async def invoke(payload=None):\n                      \"\"\"Main entrypoint for the agent\"\"\"\n                      try:\n                          # Get the query from payload\n                          query = payload.get(\"prompt\", \"Hello, how are you?\") if payload else \"Hello, how are you?\"\n\n                          # Create and use the agent\n                          agent = create_basic_agent()\n                          response = agent(query)\n\n                          return {\n                              \"status\": \"success\",\n                              \"response\": response.message['content'][0]['text']\n                          }\n\n                      except Exception as e:\n                          return {\n                              \"status\": \"error\",\n                              \"error\": str(e)\n                          }\n\n                  if __name__ == \"__main__\":\n                      app.run()\n                  EOF\n\n                # Step 1.3: Create Dockerfile\n                - |\n                  cat &gt; Dockerfile &lt;&lt; 'EOF'\n                  FROM public.ecr.aws/docker/library/python:3.11-slim\n                  WORKDIR /app\n\n                  COPY requirements.txt requirements.txt\n                  RUN pip install -r requirements.txt\n                  RUN pip install aws-opentelemetry-distro&gt;=0.10.1\n\n                  ENV AWS_REGION=us-west-2\n                  ENV AWS_DEFAULT_REGION=us-west-2\n\n                  # Create non-root user\n                  RUN useradd -m -u 1000 bedrock_agentcore\n                  USER bedrock_agentcore\n\n                  EXPOSE 8080\n                  EXPOSE 8000\n\n                  COPY . .\n\n                  CMD [\"opentelemetry-instrument\", \"python\", \"-m\", \"my_agent\"]\n                  EOF\n\n                # Step 1.4: Build the image\n                - echo Building ARM64 image...\n                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .\n                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n\n            post_build:\n              commands:\n                - echo Build completed on `date`\n                - echo Pushing the Docker image...\n                - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n                - echo ARM64 Docker image pushed successfully\n\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-basic-build\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: CodeBuild\n\n  # CUSTOM RESOURCE - Trigger Image Build\n  TriggerImageBuild:\n    Type: Custom::CodeBuildTrigger\n    DependsOn:\n      - ECRRepository\n      - AgentImageBuildProject\n      - CodeBuildTriggerFunction\n    Properties:\n      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn\n      ProjectName: !Ref AgentImageBuildProject\n      WaitForCompletion: \"true\"\n\n  # ========================================================================\n  # AGENTCORE MODULE - Runtime Only (No Tools)\n  # ========================================================================\n\n  # AgentCore Runtime\n  AgentRuntime:\n    Type: AWS::BedrockAgentCore::Runtime\n    DependsOn:\n      - TriggerImageBuild\n    Properties:\n      AgentRuntimeName: !Sub\n        - \"${StackNameUnderscore}_${AgentName}\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      AgentRuntimeArtifact:\n        ContainerConfiguration:\n          ContainerUri: !Sub \"${ECRRepository.RepositoryUri}:${ImageTag}\"\n      RoleArn: !GetAtt AgentExecutionRole.Arn\n      NetworkConfiguration:\n        NetworkMode: !Ref NetworkMode\n      Description: !Sub \"Basic agent runtime for ${AWS::StackName}\"\n\n# ============================================================================\n# OUTPUTS SECTION\n# ============================================================================\nOutputs:\n  # AGENTCORE MODULE OUTPUTS\n  AgentRuntimeId:\n    Description: \"ID of the created agent runtime\"\n    Value: !GetAtt AgentRuntime.AgentRuntimeId\n    Export:\n      Name: !Sub \"${AWS::StackName}-AgentRuntimeId\"\n\n  ECRRepositoryUri:\n    Description: \"URI of the ECR repository\"\n    Value: !GetAtt ECRRepository.RepositoryUri\n    Export:\n      Name: !Sub \"${AWS::StackName}-ECRRepositoryUri\"\n\n  AgentExecutionRoleArn:\n    Description: \"ARN of the agent execution role\"\n    Value: !GetAtt AgentExecutionRole.Arn\n    Export:\n      Name: !Sub \"${AWS::StackName}-AgentExecutionRoleArn\"\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/basic-runtime/runtime-deploy-bash-script.html","title":"Runtime deploy bash script","text":"<pre><code>#!/bin/bash\n\n# Deploy script for Basic Agent Runtime CloudFormation stack\n# This script deploys a basic AgentCore Runtime with a simple Strands agent\n\nset -e\n\n# Configuration\nSTACK_NAME=\"${1:-basic-agent-demo}\"\nREGION=\"${2:-us-west-2}\"\nTEMPLATE_FILE=\"template.yaml\"\n\necho \"==========================================\"\necho \"Deploying Basic Agent Runtime\"\necho \"==========================================\"\necho \"Stack Name: $STACK_NAME\"\necho \"Region: $REGION\"\necho \"==========================================\"\n\n# Check if template file exists\nif [ ! -f \"$TEMPLATE_FILE\" ]; then\n    echo \"Error: Template file '$TEMPLATE_FILE' not found!\"\n    exit 1\nfi\n\n# Deploy the CloudFormation stack\necho \"\"\necho \"Creating CloudFormation stack...\"\naws cloudformation create-stack \\\n    --stack-name \"$STACK_NAME\" \\\n    --template-body file://\"$TEMPLATE_FILE\" \\\n    --capabilities CAPABILITY_NAMED_IAM \\\n    --region \"$REGION\"\n\nif [ $? -eq 0 ]; then\n    echo \"\"\n    echo \"\u2713 Stack creation initiated successfully!\"\n    echo \"\"\n    echo \"Waiting for stack creation to complete...\"\n    echo \"This will take approximately 10-15 minutes...\"\n    echo \"\"\n\n    aws cloudformation wait stack-create-complete \\\n        --stack-name \"$STACK_NAME\" \\\n        --region \"$REGION\"\n\n    if [ $? -eq 0 ]; then\n        echo \"\"\n        echo \"==========================================\"\n        echo \"\u2713 Stack deployed successfully!\"\n        echo \"==========================================\"\n        echo \"\"\n        echo \"Stack Outputs:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs' \\\n            --output table \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Agent Runtime ID:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`AgentRuntimeId`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"To delete this stack, run:\"\n        echo \"  ./cleanup.sh $STACK_NAME $REGION\"\n        echo \"\"\n    else\n        echo \"\"\n        echo \"\u2717 Stack creation failed or timed out\"\n        echo \"Check the CloudFormation console for details\"\n        exit 1\n    fi\nelse\n    echo \"\"\n    echo \"\u2717 Failed to initiate stack creation\"\n    exit 1\nfi\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/end-to-end-weather-agent/weather-agent-cfn-template.html","title":"Weather agent cfn template","text":"<pre><code>AWSTemplateFormatVersion: \"2010-09-09\"\nDescription: \"Complete AgentCore deployment - Single stack with modular organization\"\n\n# ============================================================================\n# PARAMETERS SECTION\n# ============================================================================\nParameters:\n  # Agent Configuration\n  AgentName:\n    Type: String\n    Default: \"TestAgent\"\n    Description: \"Name for the agent runtime\"\n    AllowedPattern: \"^[a-zA-Z][a-zA-Z0-9_]{0,47}$\"\n    ConstraintDescription: \"Must start with a letter, max 48 characters, alphanumeric and underscores only\"\n\n  # Container Configuration\n  ImageTag:\n    Type: String\n    Default: \"latest\"\n    Description: \"Tag for the Docker image\"\n\n  # Network Configuration\n  NetworkMode:\n    Type: String\n    Default: \"PUBLIC\"\n    Description: \"Network mode for AgentCore resources\"\n    AllowedValues:\n      - PUBLIC\n      - PRIVATE\n\n  # ECR Configuration\n  ECRRepositoryName:\n    Type: String\n    Default: \"agent-cfn-weather\"\n    Description: \"Name of the ECR repository\"\n\n  # Memory Configuration\n  MemoryName:\n    Type: String\n    Default: \"TestAgentCoreMemoryWeather\"\n    Description: \"Name for the AgentCore memory resource\"\n    AllowedPattern: \"^[a-zA-Z][a-zA-Z0-9_]{0,47}$\"\n    ConstraintDescription: \"Must start with a letter, max 48 characters, alphanumeric and underscores only\"\n\n# ============================================================================\n# METADATA SECTION\n# ============================================================================\nMetadata:\n  AWS::CloudFormation::Interface:\n    ParameterGroups:\n      - Label:\n          default: \"Agent Configuration\"\n        Parameters:\n          - AgentName\n          - NetworkMode\n      - Label:\n          default: \"Container Configuration\"\n        Parameters:\n          - ECRRepositoryName\n          - ImageTag\n      - Label:\n          default: \"Memory Configuration\"\n        Parameters:\n          - MemoryName\n    ParameterLabels:\n      AgentName:\n        default: \"Agent Name\"\n      NetworkMode:\n        default: \"Network Mode\"\n      ECRRepositoryName:\n        default: \"ECR Repository Name\"\n      ImageTag:\n        default: \"Image Tag\"\n      MemoryName:\n        default: \"Memory Name\"\n\n# ============================================================================\n# RESOURCES SECTION - ORGANIZED BY MODULE\n# ============================================================================\nResources:\n  # ========================================================================\n  # ECR MODULE - Container Registry\n  # ========================================================================\n\n  ECRRepository:\n    Type: AWS::ECR::Repository\n    DeletionPolicy: Delete\n    UpdateReplacePolicy: Delete\n    Properties:\n      RepositoryName: !Sub \"${AWS::StackName}-${ECRRepositoryName}\"\n      ImageTagMutability: MUTABLE\n      EmptyOnDelete: true\n      ImageScanningConfiguration:\n        ScanOnPush: true\n      RepositoryPolicyText:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AllowPullFromAccount\n            Effect: Allow\n            Principal:\n              AWS: !Sub \"arn:aws:iam::${AWS::AccountId}:root\"\n            Action:\n              - ecr:BatchGetImage\n              - ecr:GetDownloadUrlForLayer\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-ecr-repository\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: ECR\n\n  # ========================================================================\n  # S3 MODULE - Results Storage\n  # ========================================================================\n\n  ResultsBucket:\n    Type: AWS::S3::Bucket\n    Properties:\n      BucketName: !Sub \"${AWS::StackName}-results-${AWS::AccountId}\"\n      PublicAccessBlockConfiguration:\n        BlockPublicAcls: true\n        BlockPublicPolicy: true\n        IgnorePublicAcls: true\n        RestrictPublicBuckets: true\n      VersioningConfiguration:\n        Status: Enabled\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-results-bucket\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: S3\n\n  # ========================================================================\n  # IAM MODULE - Security and Permissions\n  # ========================================================================\n\n  # Agent Execution Role\n  AgentExecutionRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-agent-execution-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AssumeRolePolicy\n            Effect: Allow\n            Principal:\n              Service: bedrock-agentcore.amazonaws.com\n            Action: sts:AssumeRole\n            Condition:\n              StringEquals:\n                aws:SourceAccount: !Ref AWS::AccountId\n              ArnLike:\n                aws:SourceArn: !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*\"\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess\n      Policies:\n        - PolicyName: AgentCoreExecutionPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRImageAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchCheckLayerAvailability\n                Resource: !GetAtt ECRRepository.Arn\n              - Sid: ECRTokenAccess\n                Effect: Allow\n                Action:\n                  - ecr:GetAuthorizationToken\n                Resource: \"*\"\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:DescribeLogStreams\n                  - logs:CreateLogGroup\n                  - logs:DescribeLogGroups\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: \"*\"\n              - Sid: XRayTracing\n                Effect: Allow\n                Action:\n                  - xray:PutTraceSegments\n                  - xray:PutTelemetryRecords\n                  - xray:GetSamplingRules\n                  - xray:GetSamplingTargets\n                Resource: \"*\"\n              - Sid: CloudWatchMetrics\n                Effect: Allow\n                Resource: \"*\"\n                Action: cloudwatch:PutMetricData\n                Condition:\n                  StringEquals:\n                    cloudwatch:namespace: bedrock-agentcore\n              - Sid: GetAgentAccessToken\n                Effect: Allow\n                Action:\n                  - bedrock-agentcore:GetWorkloadAccessToken\n                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT\n                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId\n                Resource:\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default\"\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/*\"\n              - Sid: BedrockModelInvocation\n                Effect: Allow\n                Action:\n                  - bedrock:InvokeModel\n                  - bedrock:InvokeModelWithResponseStream\n                Resource: \"*\"\n              - Sid: S3ResultsAccess\n                Effect: Allow\n                Action:\n                  - s3:PutObject\n                  - s3:GetObject\n                  - s3:DeleteObject\n                Resource: !Sub \"${ResultsBucket.Arn}/*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-agent-execution-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # CodeBuild Service Role\n  CodeBuildRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-codebuild-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: codebuild.amazonaws.com\n            Action: sts:AssumeRole\n      Policies:\n        - PolicyName: CodeBuildPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:CreateLogGroup\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: !Sub \"arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*\"\n              - Sid: ECRAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchCheckLayerAvailability\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchGetImage\n                  - ecr:GetAuthorizationToken\n                  - ecr:PutImage\n                  - ecr:InitiateLayerUpload\n                  - ecr:UploadLayerPart\n                  - ecr:CompleteLayerUpload\n                Resource:\n                  - !GetAtt ECRRepository.Arn\n                  - \"*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # Lambda Custom Resource Role\n  CustomResourceRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-custom-resource-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n            Action: sts:AssumeRole\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\n      Policies:\n        - PolicyName: CustomResourcePolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRAccess\n                Effect: Allow\n                Action:\n                  - ecr:ListImages\n                  - ecr:BatchDeleteImage\n                  - ecr:GetAuthorizationToken\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:PutImage\n                  - ecr:InitiateLayerUpload\n                  - ecr:UploadLayerPart\n                  - ecr:CompleteLayerUpload\n                Resource: !GetAtt ECRRepository.Arn\n              - Sid: CodeBuildAccess\n                Effect: Allow\n                Action:\n                  - codebuild:StartBuild\n                  - codebuild:BatchGetBuilds\n                  - codebuild:BatchGetProjects\n                Resource: !GetAtt AgentImageBuildProject.Arn\n              - Sid: BedrockAgentCoreMemoryAccess\n                Effect: Allow\n                Action:\n                  - bedrock-agentcore:CreateEvent\n                  - bedrock-agentcore:ListEvents\n                  - bedrock-agentcore:GetMemory\n                Resource: \"*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-custom-resource-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # ========================================================================\n  # LAMBDA MODULE - Custom Resources\n  # ========================================================================\n\n  CodeBuildTriggerFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub \"${AWS::StackName}-codebuild-trigger\"\n      Description: \"Triggers CodeBuild projects as CloudFormation custom resource\"\n      Handler: index.handler\n      Role: !GetAtt CustomResourceRole.Arn\n      Runtime: python3.9\n      Timeout: 900\n      Code:\n        ZipFile: |\n          import boto3\n          import cfnresponse\n          import json\n          import logging\n          import time\n\n          logger = logging.getLogger()\n          logger.setLevel(logging.INFO)\n\n          def handler(event, context):\n              logger.info('Received event: %s', json.dumps(event))\n\n              try:\n                  if event['RequestType'] == 'Delete':\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})\n                      return\n\n                  project_name = event['ResourceProperties']['ProjectName']\n                  wait_for_completion = event['ResourceProperties'].get('WaitForCompletion', 'true').lower() == 'true'\n\n                  logger.info(f\"Attempting to start CodeBuild project: {project_name}\")\n                  logger.info(f\"Wait for completion: {wait_for_completion}\")\n\n                  # Start the CodeBuild project\n                  codebuild = boto3.client('codebuild')\n\n                  # First, verify the project exists\n                  try:\n                      project_info = codebuild.batch_get_projects(names=[project_name])\n                      if not project_info['projects']:\n                          raise Exception(f\"CodeBuild project '{project_name}' not found\")\n                      logger.info(f\"CodeBuild project '{project_name}' found\")\n                  except Exception as e:\n                      logger.error(f\"Error checking project existence: {str(e)}\")\n                      raise\n\n                  response = codebuild.start_build(projectName=project_name)\n                  build_id = response['build']['id']\n\n                  logger.info(f\"Successfully started build: {build_id}\")\n\n                  if not wait_for_completion:\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                          'BuildId': build_id,\n                          'Status': 'STARTED'\n                      })\n                      return\n\n                  # Wait for the build to complete\n                  max_wait_time = context.get_remaining_time_in_millis() / 1000 - 30  # Leave 30s buffer\n                  start_time = time.time()\n\n                  while True:\n                      if time.time() - start_time &gt; max_wait_time:\n                          error_message = f\"Build {build_id} timed out\"\n                          logger.error(error_message)\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': error_message})\n                          return\n\n                      build_response = codebuild.batch_get_builds(ids=[build_id])\n                      build_status = build_response['builds'][0]['buildStatus']\n\n                      if build_status == 'SUCCEEDED':\n                          logger.info(f\"Build {build_id} succeeded\")\n                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                              'BuildId': build_id,\n                              'Status': build_status\n                          })\n                          return\n                      elif build_status in ['FAILED', 'FAULT', 'STOPPED', 'TIMED_OUT']:\n                          error_message = f\"Build {build_id} failed with status: {build_status}\"\n                          logger.error(error_message)\n\n                          # Get build logs for debugging\n                          try:\n                              logs_info = build_response['builds'][0].get('logs', {})\n                              if logs_info.get('groupName') and logs_info.get('streamName'):\n                                  logger.info(f\"Build logs available in CloudWatch\")\n                          except Exception as log_error:\n                              logger.warning(f\"Could not get log information: {log_error}\")\n\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {\n                              'Error': error_message,\n                              'BuildId': build_id\n                          })\n                          return\n\n                      logger.info(f\"Build {build_id} status: {build_status}\")\n                      time.sleep(30)  # Check every 30 seconds\n\n              except Exception as e:\n                  logger.error('Error: %s', str(e))\n                  cfnresponse.send(event, context, cfnresponse.FAILED, {\n                      'Error': str(e)\n                  })\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-trigger\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: Lambda\n\n  MemoryInitializerFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub \"${AWS::StackName}-memory-initializer\"\n      Description: \"Initializes AgentCore Memory with default entries after memory creation\"\n      Handler: index.handler\n      Role: !GetAtt CustomResourceRole.Arn\n      Runtime: python3.9\n      Timeout: 300\n      Code:\n        ZipFile: |\n          import boto3\n          import cfnresponse\n          import json\n          import logging\n          import time\n          from datetime import datetime\n\n          logger = logging.getLogger()\n          logger.setLevel(logging.INFO)\n\n          def handler(event, context):\n              logger.info('Received event: %s', json.dumps(event))\n\n              try:\n                  if event['RequestType'] == 'Delete':\n                      # No cleanup needed for memory entries\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})\n                      return\n\n                  memory_id = event['ResourceProperties']['MemoryId']\n                  region = event['ResourceProperties'].get('Region', 'us-west-2')\n                  timestamp = datetime.utcnow().isoformat() + 'Z'\n\n                  logger.info(f\"Initializing memory entries for Memory ID: {memory_id}\")\n\n                  activity_preferences = {\n                      \"good_weather\": [\"hiking\", \"beach volleyball\", \"outdoor picnic\", \"farmers market\", \"gardening\", \"photography\", \"bird watching\"],\n                      \"ok_weather\": [\"walking tours\", \"outdoor dining\", \"park visits\", \"museums\"],\n                      \"poor_weather\": [\"indoor museums\", \"shopping\", \"restaurants\", \"movies\"]\n                  }\n\n                  # Convert the dictionary to a JSON string for storage in the blob\n                  activity_preferences_json = json.dumps(activity_preferences)\n\n                  # Initialize the bedrock-agentcore client\n                  client = boto3.client('bedrock-agentcore', region_name=region)\n\n                  response = client.create_event(\n                      memoryId=memory_id,\n                      actorId=\"user123\",\n                      sessionId=\"session456\",\n                      eventTimestamp=timestamp,\n                      payload=[\n                          {\n                              'blob': activity_preferences_json,\n                          }\n                      ]\n                  )\n                  logger.info(f\"Successfully created memory event: {response}\")\n\n                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                      'MemoryId': memory_id,\n                      'Status': 'INITIALIZED'\n                  })\n\n              except Exception as e:\n                  logger.error('Error initializing memory: %s', str(e))\n                  cfnresponse.send(event, context, cfnresponse.FAILED, {\n                      'Error': str(e)\n                  })\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-memory-initializer\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: Lambda\n\n  # ========================================================================\n  # CODEBUILD MODULE - Container Image Building\n  # ========================================================================\n\n  AgentImageBuildProject:\n    Type: AWS::CodeBuild::Project\n    Properties:\n      Name: !Sub \"${AWS::StackName}-strands-agent-build\"\n      Description: !Sub \"Build Strands agent Docker image for ${AWS::StackName}\"\n      ServiceRole: !GetAtt CodeBuildRole.Arn\n      Artifacts:\n        Type: NO_ARTIFACTS\n      Environment:\n        Type: ARM_CONTAINER\n        ComputeType: BUILD_GENERAL1_LARGE\n        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0\n        PrivilegedMode: true\n        EnvironmentVariables:\n          - Name: AWS_DEFAULT_REGION\n            Value: !Ref AWS::Region\n          - Name: AWS_ACCOUNT_ID\n            Value: !Ref AWS::AccountId\n          - Name: IMAGE_REPO_NAME\n            Value: !Ref ECRRepository\n          - Name: IMAGE_TAG\n            Value: !Ref ImageTag\n          - Name: STACK_NAME\n            Value: !Ref AWS::StackName\n      Source:\n        Type: NO_SOURCE\n        BuildSpec: |\n          version: 0.2\n          phases:\n            pre_build:\n              commands:\n                - echo Logging in to Amazon ECR...\n                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com\n            build:\n              commands:\n                - echo Build started on `date`\n                - echo Building the Docker image for default agent ARM64...\n\n                # Step 1.1: Create requirements.txt\n                - |\n                  cat &gt; requirements.txt &lt;&lt; 'EOF'\n                  strands-agents\n                  strands-agents-tools\n                  uv\n                  boto3\n                  bedrock-agentcore\n                  bedrock-agentcore-starter-toolkit\n                  browser-use==0.3.2\n                  langchain-aws&gt;=0.1.0\n                  rich\n                  EOF\n\n                # Step 1.2: Create my_agent.py\n                - |\n                  cat &gt; my_agent.py &lt;&lt; 'EOF'\n                  from strands import Agent, tool\n                  from strands_tools import use_aws\n                  from typing import Dict, Any\n                  import json\n                  import os\n                  import asyncio\n                  from contextlib import suppress\n\n                  from bedrock_agentcore.tools.browser_client import BrowserClient\n                  from browser_use import Agent as BrowserAgent\n                  from browser_use.browser.session import BrowserSession\n                  from browser_use.browser import BrowserProfile\n                  from langchain_aws import ChatBedrockConverse\n                  from bedrock_agentcore.tools.code_interpreter_client import CodeInterpreter\n                  from bedrock_agentcore.memory import MemoryClient\n                  from rich.console import Console\n                  import re\n\n                  from bedrock_agentcore.runtime import BedrockAgentCoreApp\n                  app = BedrockAgentCoreApp()\n\n                  console = Console()\n\n                  # Configuration\n                  BROWSER_ID = os.getenv('BROWSER_ID', \"agentcore_dev_browser-Df3lyxkbjo\")\n                  CODE_INTERPRETER_ID = os.getenv('CODE_INTERPRETER_ID', \"agentcore_dev_code_interpreter-IqIg8bqnKn\")\n                  MEMORY_ID = os.getenv('MEMORY_ID', \"agentcore_dev_TestAgentCoreMemory-N7LCAH8ZCK\")\n                  RESULTS_BUCKET = os.getenv('RESULTS_BUCKET', \"default-results-bucket\")\n                  region = 'us-west-2'\n\n                  # Async helper functions\n                  async def run_browser_task(browser_session, bedrock_chat, task: str) -&gt; str:\n                      \"\"\"Run a browser automation task using browser_use\"\"\"\n                      try:\n                          console.print(f\"[blue]\ud83e\udd16 Executing browser task:[/blue] {task[:100]}...\")\n\n                          agent = BrowserAgent(\n                              task=task,\n                              llm=bedrock_chat,\n                              browser=browser_session\n                          )\n\n                          result = await agent.run()\n                          console.print(\"[green]\u2705 Browser task completed successfully![/green]\")\n\n                          if 'done' in result.last_action() and 'text' in result.last_action()['done']:\n                              return result.last_action()['done']['text'] \n                          else:\n                              raise ValueError(\"NO Data\")\n\n                      except Exception as e:\n                          console.print(f\"[red]\u274c Browser task error: {e}[/red]\")\n                          raise\n\n                  async def initialize_browser_session():\n                      \"\"\"Initialize Browser-use session with AgentCore WebSocket connection\"\"\"\n                      try:\n                          client = BrowserClient(region)\n                          client.start(identifier=BROWSER_ID)\n\n                          ws_url, headers = client.generate_ws_headers()\n                          console.print(f\"[cyan]\ud83d\udd17 Browser WebSocket URL: {ws_url[:50]}...[/cyan]\")\n\n                          browser_profile = BrowserProfile(\n                              headers=headers,\n                              timeout=150000,\n                          )\n\n                          browser_session = BrowserSession(\n                              cdp_url=ws_url,\n                              browser_profile=browser_profile,\n                              keep_alive=True\n                          )\n\n                          console.print(\"[cyan]\ud83d\udd04 Initializing browser session...[/cyan]\")\n                          await browser_session.start()\n\n                          bedrock_chat = ChatBedrockConverse(\n                              model_id=\"us.anthropic.claude-3-7-sonnet-20250219-v1:0\",\n                              region_name=\"us-west-2\"\n                          )\n\n                          console.print(\"[green]\u2705 Browser session initialized and ready[/green]\")\n                          return browser_session, bedrock_chat, client \n\n                      except Exception as e:\n                          console.print(f\"[red]\u274c Failed to initialize browser session: {e}[/red]\")\n                          raise\n\n                  # Tools for Strands Agent\n                  @tool\n                  async def get_weather_data(city: str) -&gt; Dict[str, Any]:\n                      \"\"\"Get weather data for a city using browser automation\"\"\"\n                      browser_session = None\n\n                      try:\n                          console.print(f\"[cyan]\ud83c\udf10 Getting weather data for {city}[/cyan]\")\n\n                          browser_session, bedrock_chat, browser_client = await initialize_browser_session()\n\n                          task = f\"\"\"Instruction: Extract 8-Day Weather Forecast for {city} from weather.gov\n                              Steps:\n                                  - Go to https://weather.gov.\n                                  - Enter \u201c{city}\u201d into the search box and Click on `GO` to execute the search.\n                                  - On the local forecast page, click the \"Printable Forecast\" link.\n                                  - Wait for the printable forecast page to load completely.\n                                  - For each day in the forecast, extract these fields:\n                                      - date (format YYYY-MM-DD) \n                                      - high (highest temperature)\n                                      - low (lowest temperature)\n                                      - conditions (short weather summary, e.g., \"Clear\")\n                                      - wind (wind speed as an integer; use mph or km/h as consistent)\n                                      - precip (precipitation chance or amount, zero if none)\n                                  - Format the extracted data as a JSON array of daily forecast objects, e.g.:\n                                      ```json\n                                      [\n                                      {{\n                                          \"date\": \"2025-09-17\",\n                                          \"high\": 78,\n                                          \"low\": 62,\n                                          \"conditions\": \"Clear\",\n                                          \"wind\": 10,\n                                          \"precip\": 80\n                                      }},\n                                      {{\n                                          \"date\": \"2025-09-18\",\n                                          \"high\": 82,\n                                          \"low\": 65,\n                                          \"conditions\": \"Partly Cloudy\",\n                                          \"wind\": 10,\n                                          \"precip\": 80\n\n                                      }}\n                                      // ... Repeat for each day ...\n                                      ]```\n\n                                  - Return only this JSON array as the final output.\n\n                              Additional Notes:\n                                  Use null or 0 if any numeric value is missing.\n                                  Avoid scraping ads, navigation, or unrelated page elements.\n                                  If \"Printable Forecast\" is missing, fallback to the main forecast page.\n                                  Include error handling (e.g., return an empty array if forecast data isn't found).\n                                  Confirm the city name matches the requested location before returning results. \n                          \"\"\"\n\n                          result = await run_browser_task(browser_session, bedrock_chat, task)\n\n                          if browser_client :\n                              browser_client.stop()\n\n                          return {\n                              \"status\": \"success\",\n                              \"content\": [{\"text\": result}]\n                          }\n\n                      except Exception as e:\n                          console.print(f\"[red]\u274c Error getting weather data: {e}[/red]\")\n                          return {\n                              \"status\": \"error\",\n                              \"content\": [{\"text\": f\"Error getting weather data: {str(e)}\"}]\n                          }\n\n                      finally:\n                          if browser_session:\n                              console.print(\"[yellow]\ud83d\udd0c Closing browser session...[/yellow]\")\n                              with suppress(Exception):\n                                  await browser_session.close()\n                              console.print(\"[green]\u2705 Browser session closed[/green]\")\n\n                  @tool\n                  def generate_analysis_code(weather_data: str) -&gt; Dict[str, Any]:\n                      \"\"\"Generate Python code for weather classification\"\"\"\n                      try:\n                          query = f\"\"\"Create Python code to classify weather days as GOOD/OK/POOR:\n\n                          Rules: \n                          - GOOD: 65-80\u00b0F, clear conditions, no rain\n                          - OK: 55-85\u00b0F, partly cloudy, slight rain chance  \n                          - POOR: &lt;55\u00b0F or &gt;85\u00b0F, cloudy/rainy\n\n                          Weather data: \n                          {weather_data} \n\n                          Store weather data stored in python variable for using it in python code \n\n                          Return code that outputs list of tuples: [('2025-09-16', 'GOOD'), ('2025-09-17', 'OK'), ...]\"\"\"\n\n                          agent = Agent()\n                          result = agent(query)\n\n                          pattern = r'```(?:json|python)\\n(.*?)\\n```'\n                          match = re.search(pattern, result.message['content'][0]['text'], re.DOTALL)\n                          python_code = match.group(1).strip() if match else result.message['content'][0]['text']\n\n                          return {\"status\": \"success\", \"content\": [{\"text\": python_code}]}\n                      except Exception as e:\n                          return {\"status\": \"error\", \"content\": [{\"text\": f\"Error: {str(e)}\"}]}\n\n                  @tool \n                  def execute_code(python_code: str) -&gt; Dict[str, Any]:\n                      \"\"\"Execute Python code using AgentCore Code Interpreter\"\"\"\n                      try:\n                          code_client = CodeInterpreter('us-west-2')\n                          code_client.start(identifier=CODE_INTERPRETER_ID)\n\n                          response = code_client.invoke(\"executeCode\", {\n                              \"code\": python_code,\n                              \"language\": \"python\",\n                              \"clearContext\": True\n                          })\n\n                          for event in response[\"stream\"]:\n                              code_execute_result = json.dumps(event[\"result\"])\n\n                          analysis_results = json.loads(code_execute_result)\n                          console.print(\"Analysis results:\", analysis_results)\n\n                          return {\"status\": \"success\", \"content\": [{\"text\": str(analysis_results)}]}\n\n                      except Exception as e:\n                          return {\"status\": \"error\", \"content\": [{\"text\": f\"Error: {str(e)}\"}]}\n\n                  @tool\n                  def get_activity_preferences() -&gt; Dict[str, Any]:\n                      \"\"\"Get activity preferences from memory\"\"\"\n                      try:\n                          client = MemoryClient(region_name='us-west-2')\n                          response = client.list_events(\n                              memory_id=MEMORY_ID,\n                              actor_id=\"user123\",\n                              session_id=\"session456\",\n                              max_results=50,\n                              include_payload=True\n                          )\n\n                          preferences = response[0][\"payload\"][0]['blob'] if response else \"No preferences found\"\n                          return {\"status\": \"success\", \"content\": [{\"text\": preferences}]}\n                      except Exception as e:\n                          return {\"status\": \"error\", \"content\": [{\"text\": f\"Error: {str(e)}\"}]}\n\n                  def create_weather_agent() -&gt; Agent:\n                      \"\"\"Create the weather agent with all tools\"\"\"\n                      system_prompt = f\"\"\"You are a Weather-Based Activity Planning Assistant.\n\n                      When a user asks about activities for a location, follow below stepes Sequentially:\n                      1. Extract city from user query\n                      2. Call get_weather_data(city) to get weather information\n                      3. Call generate_analysis_code(weather_data) to create classification code\n                      4. Call execute_code(python_code) to get Day Type ( GOOD, OK , POOR ) for forecasting dates. \n                      5. Call get_activity_preferences() to get user preferences\n                      6. Generate Activity Recommendations based on weather and preferences that you have recieved from previous steps\n                      7. Generate the comprehensive Markdown file (results.md) and store it in S3 Bucket :  {RESULTS_BUCKET} through use_aws tool. \n\n                      IMPORTANT: Provide complete recommendations and end your response. Do NOT ask follow-up questions or wait for additional input.\"\"\"\n\n                      return Agent(\n                          tools=[get_weather_data, generate_analysis_code, execute_code, get_activity_preferences, use_aws],\n                          system_prompt=system_prompt,\n                          name=\"WeatherActivityPlanner\"\n                      )\n\n                  @app.async_task\n                  async def async_main(query=None):\n                      \"\"\"Async main function\"\"\"\n                      console.print(\"\ud83c\udf24\ufe0f Weather-Based Activity Planner - Async Version\")\n                      console.print(\"=\" * 30)\n\n                      agent = create_weather_agent()\n\n                      query = query or \"What should I do this weekend in Richmond VA?\"\n                      console.print(f\"\\n[bold blue]\ud83d\udd0d Query:[/bold blue] {query}\")\n                      console.print(\"-\" * 50)\n\n                      try:\n                          os.environ[\"BYPASS_TOOL_CONSENT\"] = \"True\"\n                          result = agent(query)\n\n                          return {\n                            \"status\": \"completed\",\n                            \"result\": result.message['content'][0]['text']\n                          }\n\n                      except Exception as e:\n                          console.print(f\"[red]\u274c Error: {e}[/red]\")\n                          import traceback\n                          traceback.print_exc()\n                          return {\n                            \"status\": \"error\",\n                            \"error\": str(e)\n                          }\n\n                  @app.entrypoint\n                  async def invoke(payload=None):\n                      try:\n                          # change\n                          query = payload.get(\"prompt\")\n\n                          asyncio.create_task(async_main(query))\n\n                          msg = (\n                               \"Processing started ... \"\n                              f\"You can monitor status in CloudWatch logs at /aws/bedrock-agentcore/runtimes/&lt;agent-runtime-id&gt; .....\"\n                              f\"You can see the result at {RESULTS_BUCKET} ....\"\n                          )\n\n                          return {\n                              \"status\": \"Started\",\n                              \"message\": msg\n                          }\n\n                      except Exception as e:\n                          return {\"error\": str(e)}\n\n                  if __name__ == \"__main__\":\n                      app.run()\n                  EOF\n\n                # Step 1.3: Create Dockerfile\n                - |\n                  cat &gt; Dockerfile &lt;&lt; 'EOF'\n                  FROM public.ecr.aws/docker/library/python:3.11-slim\n                  WORKDIR /app\n\n                  COPY requirements.txt requirements.txt\n                  RUN pip install -r requirements.txt\n                  RUN pip install aws-opentelemetry-distro&gt;=0.10.1\n\n                  ENV AWS_REGION=us-west-2\n                  ENV AWS_DEFAULT_REGION=us-west-2\n\n                  # Create non-root user\n                  RUN useradd -m -u 1000 bedrock_agentcore\n                  USER bedrock_agentcore\n\n                  EXPOSE 8080\n                  EXPOSE 8000\n\n                  COPY . . \n\n                  CMD [\"opentelemetry-instrument\", \"python\", \"-m\", \"my_agent\"]\n\n                  EOF\n\n                # Step 1.5: Build the image\n                - echo Building ARM64 image...\n                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .\n                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n\n            post_build:\n              commands:\n                - echo Build completed on `date`\n                - echo Pushing the Docker image...\n                - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n                - echo ARM64 Docker image pushed successfully\n\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-strands-build\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: CodeBuild\n\n  # CUSTOM RESOURCE - Trigger Image Build\n  TriggerImageBuild:\n    Type: Custom::CodeBuildTrigger\n    DependsOn:\n      - ECRRepository\n      - AgentImageBuildProject\n      - CodeBuildTriggerFunction\n    Properties:\n      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn\n      ProjectName: !Ref AgentImageBuildProject\n      WaitForCompletion: \"true\"\n\n  # ========================================================================\n  # AGENTCORE MODULE - Runtime and Tools\n  # ========================================================================\n\n  # AgentCore Runtime\n  AgentRuntime:\n    Type: AWS::BedrockAgentCore::Runtime\n    DependsOn: \n      - TriggerImageBuild\n      - BrowserTool\n      - CodeInterpreterTool\n      - BasicMemory\n    Properties:\n      AgentRuntimeName: !Sub \n        - \"${StackNameUnderscore}_${AgentName}\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      AgentRuntimeArtifact:\n        ContainerConfiguration:\n          ContainerUri: !Sub \"${ECRRepository.RepositoryUri}:${ImageTag}\"\n      RoleArn: !GetAtt AgentExecutionRole.Arn\n      NetworkConfiguration:\n        NetworkMode: !Ref NetworkMode\n      Description: !Sub \"Strands agent runtime for ${AWS::StackName}\"\n      EnvironmentVariables:\n        BROWSER_ID: !GetAtt BrowserTool.BrowserId\n        CODE_INTERPRETER_ID: !GetAtt CodeInterpreterTool.CodeInterpreterId\n        MEMORY_ID: !GetAtt BasicMemory.MemoryId\n        RESULTS_BUCKET: !Ref ResultsBucket\n\n\n  # Browser Tool\n  BrowserTool:\n    Type: AWS::BedrockAgentCore::BrowserCustom\n    Properties:\n      Name: !Sub \n        - \"${StackNameUnderscore}_browser\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      Description: !Sub \"Browser tool for ${AWS::StackName} web automation\"\n      NetworkConfiguration:\n        NetworkMode: !Ref NetworkMode\n      RecordingConfig:\n        Enabled: false\n\n  # Code Interpreter Tool\n  CodeInterpreterTool:\n    Type: AWS::BedrockAgentCore::CodeInterpreterCustom\n    Properties:\n      Name: !Sub \n        - \"${StackNameUnderscore}_code_interpreter\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      Description: !Sub \"Code interpreter tool for ${AWS::StackName} code execution\"\n      NetworkConfiguration:\n        NetworkMode: !Ref NetworkMode\n\n  # Basic Memory\n  BasicMemory:\n    Type: AWS::BedrockAgentCore::Memory\n    Properties:\n      Name: !Sub \n        - \"${StackNameUnderscore}_${MemoryName}\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      Description: !Sub \"Memory created for ${AWS::StackName} integration testing\"\n      EventExpiryDuration: 30\n\n  # ========================================================================\n  # CUSTOM RESOURCE - Initialize Memory with Default Entries\n  # ========================================================================\n\n  InitializeMemoryEntries:\n    Type: Custom::MemoryInitializer\n    DependsOn:\n      - BasicMemory\n      - MemoryInitializerFunction\n    Properties:\n      ServiceToken: !GetAtt MemoryInitializerFunction.Arn\n      MemoryId: !GetAtt BasicMemory.MemoryId\n      Region: !Ref AWS::Region\n\n# ============================================================================\n# OUTPUTS SECTION - ORGANIZED BY MODULE\n# ============================================================================\nOutputs:\n  # AGENTCORE MODULE OUTPUTS\n  AgentRuntimeId:\n    Description: \"ID of the created agent runtime\"\n    Value: !GetAtt AgentRuntime.AgentRuntimeId\n    Export:\n      Name: !Sub \"${AWS::StackName}-AgentRuntimeId\"\n\n  BrowserId:\n    Description: ID of the created browser\n    Value: !GetAtt BrowserTool.BrowserId\n    Export:\n      Name: !Sub \"${AWS::StackName}-BrowserId\"\n\n  CodeInterpreterId:\n    Description: ID of the created code interpreter\n    Value: !GetAtt CodeInterpreterTool.CodeInterpreterId\n    Export:\n      Name: !Sub \"${AWS::StackName}-CodeInterpreterId\"\n\n  MemoryId:\n    Description: \"ID of the created memory\"\n    Value: !GetAtt BasicMemory.MemoryId\n    Export:\n      Name: !Sub \"${AWS::StackName}-MemoryId\"\n\n  ResultsBucket:\n    Description: \"S3 bucket for storing agent results\"\n    Value: !Ref ResultsBucket\n    Export:\n      Name: !Sub \"${AWS::StackName}-ResultsBucket\"\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/end-to-end-weather-agent/weather-agent-deploy-bash-script.html","title":"Weather agent deploy bash script","text":"<pre><code>#!/bin/bash\n\n# Deploy script for Weather Agent Runtime CloudFormation stack\n# This script deploys a complete weather agent with browser, code interpreter, and memory\n\nset -e\n\n# Configuration\nSTACK_NAME=\"${1:-weather-agent-demo}\"\nREGION=\"${2:-us-west-2}\"\nTEMPLATE_FILE=\"end-to-end-weather-agent.yaml\"\n\necho \"==========================================\"\necho \"Deploying Weather Agent Runtime\"\necho \"==========================================\"\necho \"Stack Name: $STACK_NAME\"\necho \"Region: $REGION\"\necho \"==========================================\"\n\n# Check if template file exists\nif [ ! -f \"$TEMPLATE_FILE\" ]; then\n    echo \"Error: Template file '$TEMPLATE_FILE' not found!\"\n    exit 1\nfi\n\n# Deploy the CloudFormation stack\necho \"\"\necho \"Creating CloudFormation stack...\"\naws cloudformation create-stack \\\n    --stack-name \"$STACK_NAME\" \\\n    --template-body file://\"$TEMPLATE_FILE\" \\\n    --capabilities CAPABILITY_NAMED_IAM \\\n    --region \"$REGION\"\n\nif [ $? -eq 0 ]; then\n    echo \"\"\n    echo \"\u2713 Stack creation initiated successfully!\"\n    echo \"\"\n    echo \"Waiting for stack creation to complete...\"\n    echo \"This will take approximately 15-20 minutes...\"\n    echo \"(Building Docker image, deploying agent with browser, code interpreter, and memory)\"\n    echo \"\"\n\n    aws cloudformation wait stack-create-complete \\\n        --stack-name \"$STACK_NAME\" \\\n        --region \"$REGION\"\n\n    if [ $? -eq 0 ]; then\n        echo \"\"\n        echo \"==========================================\"\n        echo \"\u2713 Stack deployed successfully!\"\n        echo \"==========================================\"\n        echo \"\"\n        echo \"Stack Outputs:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs' \\\n            --output table \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Agent Runtime ID:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`AgentRuntimeId`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Browser ID:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`BrowserId`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Code Interpreter ID:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`CodeInterpreterId`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Memory ID:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`MemoryId`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Results Bucket:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`ResultsBucket`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"To delete this stack, run:\"\n        echo \"  ./cleanup.sh $STACK_NAME $REGION\"\n        echo \"\"\n    else\n        echo \"\"\n        echo \"\u2717 Stack creation failed or timed out\"\n        echo \"Check the CloudFormation console for details\"\n        exit 1\n    fi\nelse\n    echo \"\"\n    echo \"\u2717 Failed to initiate stack creation\"\n    exit 1\nfi\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/mcp-server-runtime/get-cognito-authentication.html","title":"Get cognito authentication","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nSimple Cognito Authentication Script\nMatches the approach from the original tutorial\n\"\"\"\n\nimport boto3\nimport sys\n\n\ndef get_token(client_id, username, password, region=None):\n    \"\"\"Get authentication token from Cognito.\"\"\"\n    # Use provided region or default from environment/config\n    if region:\n        cognito_client = boto3.client(\"cognito-idp\", region_name=region)\n    else:\n        cognito_client = boto3.client(\"cognito-idp\")\n\n    try:\n        auth_response = cognito_client.initiate_auth(\n            ClientId=client_id,\n            AuthFlow=\"USER_PASSWORD_AUTH\",\n            AuthParameters={\"USERNAME\": username, \"PASSWORD\": password},\n        )\n\n        return auth_response[\"AuthenticationResult\"][\"AccessToken\"]\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        print(\"Troubleshooting:\")\n        print(\"  - Verify the Client ID is correct\")\n        print(\"  - Ensure you're using the correct region\")\n        print(\"  - Check that the user exists and password is correct\")\n        print(\"  - Verify USER_PASSWORD_AUTH is enabled for this client\")\n        sys.exit(1)\n\n\ndef main():\n    if len(sys.argv) &lt; 4 or len(sys.argv) &gt; 5:\n        print(\"Usage: python get_token.py &lt;client_id&gt; &lt;username&gt; &lt;password&gt; [region]\")\n        print(\"\\nExamples:\")\n        print(\"  python get_token.py abc123xyz testuser MyPassword123!\")\n        print(\"  python get_token.py abc123xyz testuser MyPassword123! us-west-2\")\n        sys.exit(1)\n\n    client_id = sys.argv[1]\n    username = sys.argv[2]\n    password = sys.argv[3]\n    region = sys.argv[4] if len(sys.argv) == 5 else None\n\n    if region:\n        print(f\"Authenticating with Cognito in region {region}...\")\n    else:\n        print(\"Authenticating with Cognito...\")\n\n    token = get_token(client_id, username, password, region)\n\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Authentication Successful!\")\n    print(\"=\" * 70)\n    print(\"\\nAccess Token:\")\n    print(token)\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Export Command:\")\n    print(\"=\" * 70)\n    print(f'\\nexport JWT_TOKEN=\"{token}\"')\n    print(\"\\nThen use in curl:\")\n    print('curl -H \"Authorization: Bearer $JWT_TOKEN\" &lt;your-api-url&gt;')\n    print()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/mcp-server-runtime/mcp-server-deploy-bash-script.html","title":"Mcp server deploy bash script","text":"<pre><code>#!/bin/bash\n# Streamlined deployment script for MCP Server on AgentCore Runtime\n\nset -e\n\nSTACK_NAME=\"${1:-mcp-server-demo}\"\nREGION=\"${2:-us-west-2}\"\n\necho \"==========================================\"\necho \"MCP Server Deployment Script\"\necho \"==========================================\"\necho \"Stack Name: $STACK_NAME\"\necho \"Region: $REGION\"\necho \"\"\n\n# Deploy CloudFormation stack\necho \"\ud83d\udce6 Deploying CloudFormation stack...\"\naws cloudformation create-stack \\\n  --stack-name \"$STACK_NAME\" \\\n  --template-body file://mcp-server-template.yaml \\\n  --capabilities CAPABILITY_NAMED_IAM \\\n  --region \"$REGION\"\n\necho \"\u2713 Stack creation initiated\"\necho \"\"\n\n# Wait for stack to complete\necho \"\u23f3 Waiting for stack to complete (this takes ~10-15 minutes)...\"\naws cloudformation wait stack-create-complete \\\n  --stack-name \"$STACK_NAME\" \\\n  --region \"$REGION\"\n\necho \"\u2713 Stack deployment complete!\"\necho \"\"\n\n# Get stack outputs\necho \"\ud83d\udccb Retrieving stack outputs...\"\nCLIENT_ID=$(aws cloudformation describe-stacks \\\n  --stack-name \"$STACK_NAME\" \\\n  --query 'Stacks[0].Outputs[?OutputKey==`CognitoUserPoolClientId`].OutputValue' \\\n  --output text \\\n  --region \"$REGION\")\n\nAGENT_ARN=$(aws cloudformation describe-stacks \\\n  --stack-name \"$STACK_NAME\" \\\n  --query 'Stacks[0].Outputs[?OutputKey==`MCPServerRuntimeArn`].OutputValue' \\\n  --output text \\\n  --region \"$REGION\")\n\necho \"\"\necho \"==========================================\"\necho \"\u2705 Deployment Complete!\"\necho \"==========================================\"\necho \"\"\necho \"Stack Name: $STACK_NAME\"\necho \"Region: $REGION\"\necho \"Client ID: $CLIENT_ID\"\necho \"Agent ARN: $AGENT_ARN\"\necho \"\"\necho \"Test Credentials:\"\necho \"  Username: testuser\"\necho \"  Password: MyPassword123!\"\necho \"\"\necho \"==========================================\"\necho \"Next Steps:\"\necho \"==========================================\"\necho \"\"\necho \"Test your MCP server:\"\necho \"  ./test.sh $STACK_NAME $REGION\"\necho \"\"\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/mcp-server-runtime/mcp-server-on-runtime-cfn-template.html","title":"Mcp server on runtime cfn template","text":"<pre><code>AWSTemplateFormatVersion: \"2010-09-09\"\nDescription: \"MCP Server on AgentCore Runtime - Deploy an MCP server with custom tools (add_numbers, multiply_numbers, greet_user)\"\n\n# ============================================================================\n# PARAMETERS SECTION\n# ============================================================================\nParameters:\n  # Agent Configuration\n  AgentName:\n    Type: String\n    Default: \"MCPServerAgent\"\n    Description: \"Name for the MCP server runtime\"\n    AllowedPattern: \"^[a-zA-Z][a-zA-Z0-9_]{0,47}$\"\n    ConstraintDescription: \"Must start with a letter, max 48 characters, alphanumeric and underscores only\"\n\n  # Container Configuration\n  ImageTag:\n    Type: String\n    Default: \"latest\"\n    Description: \"Tag for the Docker image\"\n\n  # Network Configuration\n  NetworkMode:\n    Type: String\n    Default: \"PUBLIC\"\n    Description: \"Network mode for AgentCore resources\"\n    AllowedValues:\n      - PUBLIC\n      - PRIVATE\n\n  # ECR Configuration\n  ECRRepositoryName:\n    Type: String\n    Default: \"mcp-server\"\n    Description: \"Name of the ECR repository\"\n\n# ============================================================================\n# METADATA SECTION\n# ============================================================================\nMetadata:\n  AWS::CloudFormation::Interface:\n    ParameterGroups:\n      - Label:\n          default: \"Agent Configuration\"\n        Parameters:\n          - AgentName\n          - NetworkMode\n      - Label:\n          default: \"Container Configuration\"\n        Parameters:\n          - ECRRepositoryName\n          - ImageTag\n    ParameterLabels:\n      AgentName:\n        default: \"Agent Name\"\n      NetworkMode:\n        default: \"Network Mode\"\n      ECRRepositoryName:\n        default: \"ECR Repository Name\"\n      ImageTag:\n        default: \"Image Tag\"\n\n# ============================================================================\n# RESOURCES SECTION\n# ============================================================================\nResources:\n  # ========================================================================\n  # ECR MODULE - Container Registry\n  # ========================================================================\n\n  ECRRepository:\n    Type: AWS::ECR::Repository\n    DeletionPolicy: Delete\n    UpdateReplacePolicy: Delete\n    Properties:\n      RepositoryName: !Sub \"${AWS::StackName}-${ECRRepositoryName}\"\n      ImageTagMutability: MUTABLE\n      EmptyOnDelete: true\n      ImageScanningConfiguration:\n        ScanOnPush: true\n      RepositoryPolicyText:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AllowPullFromAccount\n            Effect: Allow\n            Principal:\n              AWS: !Sub \"arn:aws:iam::${AWS::AccountId}:root\"\n            Action:\n              - ecr:BatchGetImage\n              - ecr:GetDownloadUrlForLayer\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-ecr-repository\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: ECR\n\n  # ========================================================================\n  # COGNITO MODULE - Authentication\n  # ========================================================================\n\n  CognitoUserPool:\n    Type: AWS::Cognito::UserPool\n    Properties:\n      UserPoolName: !Sub \"${AWS::StackName}-user-pool\"\n      Policies:\n        PasswordPolicy:\n          MinimumLength: 8\n          RequireUppercase: false\n          RequireLowercase: false\n          RequireNumbers: false\n          RequireSymbols: false\n      Schema:\n        - Name: email\n          AttributeDataType: String\n          Required: false\n          Mutable: true\n      UserPoolTags:\n        Name: !Sub \"${AWS::StackName}-user-pool\"\n        StackName: !Ref AWS::StackName\n        Module: Cognito\n\n  CognitoUserPoolClient:\n    Type: AWS::Cognito::UserPoolClient\n    Properties:\n      ClientName: !Sub \"${AWS::StackName}-client\"\n      UserPoolId: !Ref CognitoUserPool\n      GenerateSecret: false\n      ExplicitAuthFlows:\n        - ALLOW_USER_PASSWORD_AUTH\n        - ALLOW_REFRESH_TOKEN_AUTH\n      PreventUserExistenceErrors: ENABLED\n\n  CognitoUser:\n    Type: AWS::Cognito::UserPoolUser\n    Properties:\n      UserPoolId: !Ref CognitoUserPool\n      Username: testuser\n      MessageAction: SUPPRESS\n\n  SetCognitoUserPassword:\n    Type: Custom::CognitoSetPassword\n    DependsOn: CognitoUser\n    Properties:\n      ServiceToken: !GetAtt CognitoPasswordSetterFunction.Arn\n      UserPoolId: !Ref CognitoUserPool\n      Username: testuser\n      Password: MyPassword123!\n\n  # ========================================================================\n  # IAM MODULE - Security and Permissions\n  # ========================================================================\n\n  # Agent Execution Role\n  AgentExecutionRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-agent-execution-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AssumeRolePolicy\n            Effect: Allow\n            Principal:\n              Service: bedrock-agentcore.amazonaws.com\n            Action: sts:AssumeRole\n            Condition:\n              StringEquals:\n                aws:SourceAccount: !Ref AWS::AccountId\n              ArnLike:\n                aws:SourceArn: !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*\"\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess\n      Policies:\n        - PolicyName: AgentCoreExecutionPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRImageAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchCheckLayerAvailability\n                Resource: !GetAtt ECRRepository.Arn\n              - Sid: ECRTokenAccess\n                Effect: Allow\n                Action:\n                  - ecr:GetAuthorizationToken\n                Resource: \"*\"\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:DescribeLogStreams\n                  - logs:CreateLogGroup\n                  - logs:DescribeLogGroups\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: \"*\"\n              - Sid: XRayTracing\n                Effect: Allow\n                Action:\n                  - xray:PutTraceSegments\n                  - xray:PutTelemetryRecords\n                  - xray:GetSamplingRules\n                  - xray:GetSamplingTargets\n                Resource: \"*\"\n              - Sid: CloudWatchMetrics\n                Effect: Allow\n                Resource: \"*\"\n                Action: cloudwatch:PutMetricData\n                Condition:\n                  StringEquals:\n                    cloudwatch:namespace: bedrock-agentcore\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-agent-execution-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # CodeBuild Service Role\n  CodeBuildRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-codebuild-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: codebuild.amazonaws.com\n            Action: sts:AssumeRole\n      Policies:\n        - PolicyName: CodeBuildPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:CreateLogGroup\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: !Sub \"arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*\"\n              - Sid: ECRAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchCheckLayerAvailability\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchGetImage\n                  - ecr:GetAuthorizationToken\n                  - ecr:PutImage\n                  - ecr:InitiateLayerUpload\n                  - ecr:UploadLayerPart\n                  - ecr:CompleteLayerUpload\n                Resource:\n                  - !GetAtt ECRRepository.Arn\n                  - \"*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # Lambda Custom Resource Role\n  CustomResourceRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-custom-resource-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n            Action: sts:AssumeRole\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\n      Policies:\n        - PolicyName: CustomResourcePolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: CodeBuildAccess\n                Effect: Allow\n                Action:\n                  - codebuild:StartBuild\n                  - codebuild:BatchGetBuilds\n                  - codebuild:BatchGetProjects\n                Resource: !GetAtt MCPServerImageBuildProject.Arn\n              - Sid: CognitoAccess\n                Effect: Allow\n                Action:\n                  - cognito-idp:AdminSetUserPassword\n                Resource: !GetAtt CognitoUserPool.Arn\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-custom-resource-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # ========================================================================\n  # LAMBDA MODULE - Custom Resources\n  # ========================================================================\n\n  CodeBuildTriggerFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub \"${AWS::StackName}-codebuild-trigger\"\n      Description: \"Triggers CodeBuild projects as CloudFormation custom resource\"\n      Handler: index.handler\n      Role: !GetAtt CustomResourceRole.Arn\n      Runtime: python3.9\n      Timeout: 900\n      Code:\n        ZipFile: |\n          import boto3\n          import cfnresponse\n          import json\n          import logging\n          import time\n\n          logger = logging.getLogger()\n          logger.setLevel(logging.INFO)\n\n          def handler(event, context):\n              logger.info('Received event: %s', json.dumps(event))\n\n              try:\n                  if event['RequestType'] == 'Delete':\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})\n                      return\n\n                  project_name = event['ResourceProperties']['ProjectName']\n                  wait_for_completion = event['ResourceProperties'].get('WaitForCompletion', 'true').lower() == 'true'\n\n                  logger.info(f\"Attempting to start CodeBuild project: {project_name}\")\n                  logger.info(f\"Wait for completion: {wait_for_completion}\")\n\n                  codebuild = boto3.client('codebuild')\n\n                  try:\n                      project_info = codebuild.batch_get_projects(names=[project_name])\n                      if not project_info['projects']:\n                          raise Exception(f\"CodeBuild project '{project_name}' not found\")\n                      logger.info(f\"CodeBuild project '{project_name}' found\")\n                  except Exception as e:\n                      logger.error(f\"Error checking project existence: {str(e)}\")\n                      raise\n\n                  response = codebuild.start_build(projectName=project_name)\n                  build_id = response['build']['id']\n\n                  logger.info(f\"Successfully started build: {build_id}\")\n\n                  if not wait_for_completion:\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                          'BuildId': build_id,\n                          'Status': 'STARTED'\n                      })\n                      return\n\n                  max_wait_time = context.get_remaining_time_in_millis() / 1000 - 30\n                  start_time = time.time()\n\n                  while True:\n                      if time.time() - start_time &gt; max_wait_time:\n                          error_message = f\"Build {build_id} timed out\"\n                          logger.error(error_message)\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': error_message})\n                          return\n\n                      build_response = codebuild.batch_get_builds(ids=[build_id])\n                      build_status = build_response['builds'][0]['buildStatus']\n\n                      if build_status == 'SUCCEEDED':\n                          logger.info(f\"Build {build_id} succeeded\")\n                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                              'BuildId': build_id,\n                              'Status': build_status\n                          })\n                          return\n                      elif build_status in ['FAILED', 'FAULT', 'STOPPED', 'TIMED_OUT']:\n                          error_message = f\"Build {build_id} failed with status: {build_status}\"\n                          logger.error(error_message)\n\n                          try:\n                              logs_info = build_response['builds'][0].get('logs', {})\n                              if logs_info.get('groupName') and logs_info.get('streamName'):\n                                  logger.info(f\"Build logs available in CloudWatch\")\n                          except Exception as log_error:\n                              logger.warning(f\"Could not get log information: {log_error}\")\n\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {\n                              'Error': error_message,\n                              'BuildId': build_id\n                          })\n                          return\n\n                      logger.info(f\"Build {build_id} status: {build_status}\")\n                      time.sleep(30)\n\n              except Exception as e:\n                  logger.error('Error: %s', str(e))\n                  cfnresponse.send(event, context, cfnresponse.FAILED, {\n                      'Error': str(e)\n                  })\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-trigger\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: Lambda\n\n  CognitoPasswordSetterFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub \"${AWS::StackName}-cognito-password-setter\"\n      Description: \"Sets Cognito user password\"\n      Handler: index.handler\n      Role: !GetAtt CustomResourceRole.Arn\n      Runtime: python3.9\n      Timeout: 300\n      Code:\n        ZipFile: |\n          import boto3\n          import cfnresponse\n          import json\n          import logging\n\n          logger = logging.getLogger()\n          logger.setLevel(logging.INFO)\n\n          def handler(event, context):\n              logger.info('Received event: %s', json.dumps(event))\n\n              try:\n                  if event['RequestType'] == 'Delete':\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})\n                      return\n\n                  user_pool_id = event['ResourceProperties']['UserPoolId']\n                  username = event['ResourceProperties']['Username']\n                  password = event['ResourceProperties']['Password']\n\n                  cognito = boto3.client('cognito-idp')\n\n                  # Set permanent password\n                  cognito.admin_set_user_password(\n                      UserPoolId=user_pool_id,\n                      Username=username,\n                      Password=password,\n                      Permanent=True\n                  )\n\n                  logger.info(f\"Password set successfully for user: {username}\")\n\n                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                      'Status': 'SUCCESS'\n                  })\n\n              except Exception as e:\n                  logger.error('Error: %s', str(e))\n                  cfnresponse.send(event, context, cfnresponse.FAILED, {\n                      'Error': str(e)\n                  })\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-cognito-password-setter\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: Lambda\n\n  # ========================================================================\n  # CODEBUILD MODULE - Container Image Building\n  # ========================================================================\n\n  MCPServerImageBuildProject:\n    Type: AWS::CodeBuild::Project\n    Properties:\n      Name: !Sub \"${AWS::StackName}-mcp-server-build\"\n      Description: !Sub \"Build MCP server Docker image for ${AWS::StackName}\"\n      ServiceRole: !GetAtt CodeBuildRole.Arn\n      Artifacts:\n        Type: NO_ARTIFACTS\n      Environment:\n        Type: ARM_CONTAINER\n        ComputeType: BUILD_GENERAL1_LARGE\n        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0\n        PrivilegedMode: true\n        EnvironmentVariables:\n          - Name: AWS_DEFAULT_REGION\n            Value: !Ref AWS::Region\n          - Name: AWS_ACCOUNT_ID\n            Value: !Ref AWS::AccountId\n          - Name: IMAGE_REPO_NAME\n            Value: !Ref ECRRepository\n          - Name: IMAGE_TAG\n            Value: !Ref ImageTag\n          - Name: STACK_NAME\n            Value: !Ref AWS::StackName\n      Source:\n        Type: NO_SOURCE\n        BuildSpec: |\n          version: 0.2\n          phases:\n            pre_build:\n              commands:\n                - echo Logging in to Amazon ECR...\n                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com\n            build:\n              commands:\n                - echo Build started on `date`\n                - echo Building the Docker image for MCP server ARM64...\n\n                # Create requirements.txt\n                - |\n                  cat &gt; requirements.txt &lt;&lt; 'EOF'\n                  mcp&gt;=1.10.0\n                  boto3\n                  bedrock-agentcore\n                  EOF\n\n                # Create mcp_server.py\n                - |\n                  cat &gt; mcp_server.py &lt;&lt; 'EOF'\n                  from mcp.server.fastmcp import FastMCP\n                  from starlette.responses import JSONResponse\n\n                  mcp = FastMCP(host=\"0.0.0.0\", stateless_http=True)\n\n                  @mcp.tool()\n                  def add_numbers(a: int, b: int) -&gt; int:\n                      \"\"\"Add two numbers together\"\"\"\n                      return a + b\n\n                  @mcp.tool()\n                  def multiply_numbers(a: int, b: int) -&gt; int:\n                      \"\"\"Multiply two numbers together\"\"\"\n                      return a * b\n\n                  @mcp.tool()\n                  def greet_user(name: str) -&gt; str:\n                      \"\"\"Greet a user by name\"\"\"\n                      return f\"Hello, {name}! Nice to meet you.\"\n\n                  if __name__ == \"__main__\":\n                      mcp.run(transport=\"streamable-http\")\n                  EOF\n\n                # Create Dockerfile\n                - |\n                  cat &gt; Dockerfile &lt;&lt; 'EOF'\n                  FROM public.ecr.aws/docker/library/python:3.11-slim\n                  WORKDIR /app\n\n                  COPY requirements.txt requirements.txt\n                  RUN pip install -r requirements.txt\n\n                  ENV AWS_REGION=us-west-2\n                  ENV AWS_DEFAULT_REGION=us-west-2\n\n                  # Create non-root user\n                  RUN useradd -m -u 1000 bedrock_agentcore\n                  USER bedrock_agentcore\n\n                  EXPOSE 8000\n\n                  COPY . .\n\n                  CMD [\"python\", \"-m\", \"mcp_server\"]\n                  EOF\n\n                # Build the image\n                - echo Building ARM64 image...\n                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .\n                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n\n            post_build:\n              commands:\n                - echo Build completed on `date`\n                - echo Pushing the Docker image...\n                - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n                - echo ARM64 Docker image pushed successfully\n\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-mcp-server-build\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: CodeBuild\n\n  # CUSTOM RESOURCE - Trigger Image Build\n  TriggerImageBuild:\n    Type: Custom::CodeBuildTrigger\n    DependsOn:\n      - ECRRepository\n      - MCPServerImageBuildProject\n      - CodeBuildTriggerFunction\n    Properties:\n      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn\n      ProjectName: !Ref MCPServerImageBuildProject\n      WaitForCompletion: \"true\"\n\n  # ========================================================================\n  # AGENTCORE MODULE - MCP Server Runtime\n  # ========================================================================\n\n  MCPServerRuntime:\n    Type: AWS::BedrockAgentCore::Runtime\n    DependsOn:\n      - TriggerImageBuild\n    Properties:\n      AgentRuntimeName: !Sub\n        - \"${StackNameUnderscore}_${AgentName}\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      AgentRuntimeArtifact:\n        ContainerConfiguration:\n          ContainerUri: !Sub \"${ECRRepository.RepositoryUri}:${ImageTag}\"\n      RoleArn: !GetAtt AgentExecutionRole.Arn\n      NetworkConfiguration:\n        NetworkMode: !Ref NetworkMode\n      ProtocolConfiguration: MCP\n      AuthorizerConfiguration:\n        CustomJWTAuthorizer:\n          AllowedClients:\n            - !Ref CognitoUserPoolClient\n          DiscoveryUrl: !Sub \"https://cognito-idp.${AWS::Region}.amazonaws.com/${CognitoUserPool}/.well-known/openid-configuration\"\n      Description: !Sub \"MCP server runtime for ${AWS::StackName}\"\n\n# ============================================================================\n# OUTPUTS SECTION\n# ============================================================================\nOutputs:\n  # AGENTCORE MODULE OUTPUTS\n  MCPServerRuntimeId:\n    Description: \"ID of the created MCP server runtime\"\n    Value: !GetAtt MCPServerRuntime.AgentRuntimeId\n    Export:\n      Name: !Sub \"${AWS::StackName}-MCPServerRuntimeId\"\n\n  MCPServerRuntimeArn:\n    Description: \"ARN of the created MCP server runtime\"\n    Value: !GetAtt MCPServerRuntime.AgentRuntimeArn\n    Export:\n      Name: !Sub \"${AWS::StackName}-MCPServerRuntimeArn\"\n\n  MCPServerInvocationURL:\n    Description: \"URL to invoke the MCP server\"\n    Value: !Sub\n      - \"https://bedrock-agentcore.${AWS::Region}.amazonaws.com/runtimes/${EncodedArn}/invocations?qualifier=DEFAULT\"\n      - EncodedArn: !Join\n          - \"\"\n          - - !Select [0, !Split [\":\", !GetAtt MCPServerRuntime.AgentRuntimeArn]]\n            - \"%3A\"\n            - !Select [1, !Split [\":\", !GetAtt MCPServerRuntime.AgentRuntimeArn]]\n            - \"%3A\"\n            - !Select [2, !Split [\":\", !GetAtt MCPServerRuntime.AgentRuntimeArn]]\n            - \"%3A\"\n            - !Select [3, !Split [\":\", !GetAtt MCPServerRuntime.AgentRuntimeArn]]\n            - \"%3A\"\n            - !Select [4, !Split [\":\", !GetAtt MCPServerRuntime.AgentRuntimeArn]]\n            - \"%3A\"\n            - !Select [5, !Split [\":\", !GetAtt MCPServerRuntime.AgentRuntimeArn]]\n            - \"%2F\"\n            - !Select [1, !Split [\"/\", !GetAtt MCPServerRuntime.AgentRuntimeArn]]\n    Export:\n      Name: !Sub \"${AWS::StackName}-MCPServerInvocationURL\"\n\n  # ECR OUTPUTS\n  ECRRepositoryUri:\n    Description: \"URI of the ECR repository\"\n    Value: !GetAtt ECRRepository.RepositoryUri\n    Export:\n      Name: !Sub \"${AWS::StackName}-ECRRepositoryUri\"\n\n  # IAM OUTPUTS\n  AgentExecutionRoleArn:\n    Description: \"ARN of the agent execution role\"\n    Value: !GetAtt AgentExecutionRole.Arn\n    Export:\n      Name: !Sub \"${AWS::StackName}-AgentExecutionRoleArn\"\n\n  # COGNITO OUTPUTS\n  CognitoUserPoolId:\n    Description: \"ID of the Cognito User Pool\"\n    Value: !Ref CognitoUserPool\n    Export:\n      Name: !Sub \"${AWS::StackName}-CognitoUserPoolId\"\n\n  CognitoUserPoolClientId:\n    Description: \"ID of the Cognito User Pool Client\"\n    Value: !Ref CognitoUserPoolClient\n    Export:\n      Name: !Sub \"${AWS::StackName}-CognitoUserPoolClientId\"\n\n  CognitoDiscoveryUrl:\n    Description: \"Cognito OIDC Discovery URL\"\n    Value: !Sub \"https://cognito-idp.${AWS::Region}.amazonaws.com/${CognitoUserPool}/.well-known/openid-configuration\"\n    Export:\n      Name: !Sub \"${AWS::StackName}-CognitoDiscoveryUrl\"\n\n  # AUTHENTICATION INFO\n  TestUsername:\n    Description: \"Test username for authentication\"\n    Value: \"testuser\"\n\n  TestPassword:\n    Description: \"Test password for authentication\"\n    Value: \"MyPassword123!\"\n\n  GetTokenCommand:\n    Description: \"Command to get authentication token\"\n    Value: !Sub |\n      python get_token.py ${CognitoUserPoolClient} testuser MyPassword123!\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/multi-agent-runtime/multi-agent-runtime-cfn-template.html","title":"Multi agent runtime cfn template","text":"<pre><code>AWSTemplateFormatVersion: \"2010-09-09\"\nDescription: \"Multi-Agent AgentCore deployment - Two agents where agent1 orchestrates and calls agent2\"\n\n# ============================================================================\n# PARAMETERS SECTION\n# ============================================================================\nParameters:\n  # Agent Configuration\n  Agent1Name:\n    Type: String\n    Default: \"OrchestratorAgent\"\n    Description: \"Name for the orchestrator agent runtime (agent1)\"\n    AllowedPattern: \"^[a-zA-Z][a-zA-Z0-9_]{0,47}$\"\n    ConstraintDescription: \"Must start with a letter, max 48 characters, alphanumeric and underscores only\"\n\n  Agent2Name:\n    Type: String\n    Default: \"SpecialistAgent\"\n    Description: \"Name for the specialist agent runtime (agent2)\"\n    AllowedPattern: \"^[a-zA-Z][a-zA-Z0-9_]{0,47}$\"\n    ConstraintDescription: \"Must start with a letter, max 48 characters, alphanumeric and underscores only\"\n\n  # Container Configuration\n  ImageTag:\n    Type: String\n    Default: \"latest\"\n    Description: \"Tag for the Docker images\"\n\n  # Network Configuration\n  NetworkMode:\n    Type: String\n    Default: \"PUBLIC\"\n    Description: \"Network mode for AgentCore resources\"\n    AllowedValues:\n      - PUBLIC\n      - PRIVATE\n\n  # ECR Configuration\n  ECRRepositoryName:\n    Type: String\n    Default: \"multi-agent\"\n    Description: \"Base name of the ECR repositories\"\n\n# ============================================================================\n# METADATA SECTION\n# ============================================================================\nMetadata:\n  AWS::CloudFormation::Interface:\n    ParameterGroups:\n      - Label:\n          default: \"Agent Configuration\"\n        Parameters:\n          - Agent1Name\n          - Agent2Name\n          - NetworkMode\n      - Label:\n          default: \"Container Configuration\"\n        Parameters:\n          - ECRRepositoryName\n          - ImageTag\n    ParameterLabels:\n      Agent1Name:\n        default: \"Agent 1 Name (Orchestrator)\"\n      Agent2Name:\n        default: \"Agent 2 Name (Specialist)\"\n      NetworkMode:\n        default: \"Network Mode\"\n      ECRRepositoryName:\n        default: \"ECR Repository Base Name\"\n      ImageTag:\n        default: \"Image Tag\"\n\n# ============================================================================\n# RESOURCES SECTION\n# ============================================================================\nResources:\n  # ========================================================================\n  # ECR MODULE - Container Registry\n  # ========================================================================\n\n  ECRRepositoryAgent1:\n    Type: AWS::ECR::Repository\n    DeletionPolicy: Delete\n    UpdateReplacePolicy: Delete\n    Properties:\n      RepositoryName: !Sub \"${AWS::StackName}-${ECRRepositoryName}-agent1\"\n      ImageTagMutability: MUTABLE\n      EmptyOnDelete: true\n      ImageScanningConfiguration:\n        ScanOnPush: true\n      RepositoryPolicyText:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AllowPullFromAccount\n            Effect: Allow\n            Principal:\n              AWS: !Sub \"arn:aws:iam::${AWS::AccountId}:root\"\n            Action:\n              - ecr:BatchGetImage\n              - ecr:GetDownloadUrlForLayer\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-ecr-repository-agent1\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: ECR\n\n  ECRRepositoryAgent2:\n    Type: AWS::ECR::Repository\n    DeletionPolicy: Delete\n    UpdateReplacePolicy: Delete\n    Properties:\n      RepositoryName: !Sub \"${AWS::StackName}-${ECRRepositoryName}-agent2\"\n      ImageTagMutability: MUTABLE\n      EmptyOnDelete: true\n      ImageScanningConfiguration:\n        ScanOnPush: true\n      RepositoryPolicyText:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AllowPullFromAccount\n            Effect: Allow\n            Principal:\n              AWS: !Sub \"arn:aws:iam::${AWS::AccountId}:root\"\n            Action:\n              - ecr:BatchGetImage\n              - ecr:GetDownloadUrlForLayer\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-ecr-repository-agent2\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: ECR\n\n  # ========================================================================\n  # IAM MODULE - Security and Permissions\n  # ========================================================================\n\n  # Agent1 Execution Role (with permissions to invoke Agent2)\n  Agent1ExecutionRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-agent1-execution-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AssumeRolePolicy\n            Effect: Allow\n            Principal:\n              Service: bedrock-agentcore.amazonaws.com\n            Action: sts:AssumeRole\n            Condition:\n              StringEquals:\n                aws:SourceAccount: !Ref AWS::AccountId\n              ArnLike:\n                aws:SourceArn: !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*\"\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess\n      Policies:\n        - PolicyName: Agent1ExecutionPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRImageAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchCheckLayerAvailability\n                Resource: !GetAtt ECRRepositoryAgent1.Arn\n              - Sid: ECRTokenAccess\n                Effect: Allow\n                Action:\n                  - ecr:GetAuthorizationToken\n                Resource: \"*\"\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:DescribeLogStreams\n                  - logs:CreateLogGroup\n                  - logs:DescribeLogGroups\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: \"*\"\n              - Sid: XRayTracing\n                Effect: Allow\n                Action:\n                  - xray:PutTraceSegments\n                  - xray:PutTelemetryRecords\n                  - xray:GetSamplingRules\n                  - xray:GetSamplingTargets\n                Resource: \"*\"\n              - Sid: CloudWatchMetrics\n                Effect: Allow\n                Resource: \"*\"\n                Action: cloudwatch:PutMetricData\n                Condition:\n                  StringEquals:\n                    cloudwatch:namespace: bedrock-agentcore\n              - Sid: GetAgentAccessToken\n                Effect: Allow\n                Action:\n                  - bedrock-agentcore:GetWorkloadAccessToken\n                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT\n                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId\n                Resource:\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default\"\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/*\"\n              - Sid: BedrockModelInvocation\n                Effect: Allow\n                Action:\n                  - bedrock:InvokeModel\n                  - bedrock:InvokeModelWithResponseStream\n                Resource: \"*\"\n              - Sid: InvokeAgent2Runtime\n                Effect: Allow\n                Action:\n                  - bedrock-agentcore:InvokeAgentRuntime\n                Resource: !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:runtime/*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-agent1-execution-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # Agent2 Execution Role (basic permissions)\n  Agent2ExecutionRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-agent2-execution-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Sid: AssumeRolePolicy\n            Effect: Allow\n            Principal:\n              Service: bedrock-agentcore.amazonaws.com\n            Action: sts:AssumeRole\n            Condition:\n              StringEquals:\n                aws:SourceAccount: !Ref AWS::AccountId\n              ArnLike:\n                aws:SourceArn: !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*\"\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/BedrockAgentCoreFullAccess\n      Policies:\n        - PolicyName: Agent2ExecutionPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRImageAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchCheckLayerAvailability\n                Resource: !GetAtt ECRRepositoryAgent2.Arn\n              - Sid: ECRTokenAccess\n                Effect: Allow\n                Action:\n                  - ecr:GetAuthorizationToken\n                Resource: \"*\"\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:DescribeLogStreams\n                  - logs:CreateLogGroup\n                  - logs:DescribeLogGroups\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: \"*\"\n              - Sid: XRayTracing\n                Effect: Allow\n                Action:\n                  - xray:PutTraceSegments\n                  - xray:PutTelemetryRecords\n                  - xray:GetSamplingRules\n                  - xray:GetSamplingTargets\n                Resource: \"*\"\n              - Sid: CloudWatchMetrics\n                Effect: Allow\n                Resource: \"*\"\n                Action: cloudwatch:PutMetricData\n                Condition:\n                  StringEquals:\n                    cloudwatch:namespace: bedrock-agentcore\n              - Sid: GetAgentAccessToken\n                Effect: Allow\n                Action:\n                  - bedrock-agentcore:GetWorkloadAccessToken\n                  - bedrock-agentcore:GetWorkloadAccessTokenForJWT\n                  - bedrock-agentcore:GetWorkloadAccessTokenForUserId\n                Resource:\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default\"\n                  - !Sub \"arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/default/workload-identity/*\"\n              - Sid: BedrockModelInvocation\n                Effect: Allow\n                Action:\n                  - bedrock:InvokeModel\n                  - bedrock:InvokeModelWithResponseStream\n                Resource: \"*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-agent2-execution-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # CodeBuild Service Role\n  CodeBuildRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-codebuild-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: codebuild.amazonaws.com\n            Action: sts:AssumeRole\n      Policies:\n        - PolicyName: CodeBuildPolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: CloudWatchLogs\n                Effect: Allow\n                Action:\n                  - logs:CreateLogGroup\n                  - logs:CreateLogStream\n                  - logs:PutLogEvents\n                Resource: !Sub \"arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*\"\n              - Sid: ECRAccess\n                Effect: Allow\n                Action:\n                  - ecr:BatchCheckLayerAvailability\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:BatchGetImage\n                  - ecr:GetAuthorizationToken\n                  - ecr:PutImage\n                  - ecr:InitiateLayerUpload\n                  - ecr:UploadLayerPart\n                  - ecr:CompleteLayerUpload\n                Resource:\n                  - !GetAtt ECRRepositoryAgent1.Arn\n                  - !GetAtt ECRRepositoryAgent2.Arn\n                  - \"*\"\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # Lambda Custom Resource Role\n  CustomResourceRole:\n    Type: AWS::IAM::Role\n    Properties:\n      RoleName: !Sub \"${AWS::StackName}-custom-resource-role\"\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n            Action: sts:AssumeRole\n      ManagedPolicyArns:\n        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole\n      Policies:\n        - PolicyName: CustomResourcePolicy\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ECRAccess\n                Effect: Allow\n                Action:\n                  - ecr:ListImages\n                  - ecr:BatchDeleteImage\n                  - ecr:GetAuthorizationToken\n                  - ecr:BatchGetImage\n                  - ecr:GetDownloadUrlForLayer\n                  - ecr:PutImage\n                  - ecr:InitiateLayerUpload\n                  - ecr:UploadLayerPart\n                  - ecr:CompleteLayerUpload\n                Resource:\n                  - !GetAtt ECRRepositoryAgent1.Arn\n                  - !GetAtt ECRRepositoryAgent2.Arn\n              - Sid: CodeBuildAccess\n                Effect: Allow\n                Action:\n                  - codebuild:StartBuild\n                  - codebuild:BatchGetBuilds\n                  - codebuild:BatchGetProjects\n                Resource:\n                  - !GetAtt Agent1ImageBuildProject.Arn\n                  - !GetAtt Agent2ImageBuildProject.Arn\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-custom-resource-role\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: IAM\n\n  # ========================================================================\n  # LAMBDA MODULE - Custom Resources\n  # ========================================================================\n\n  CodeBuildTriggerFunction:\n    Type: AWS::Lambda::Function\n    Properties:\n      FunctionName: !Sub \"${AWS::StackName}-codebuild-trigger\"\n      Description: \"Triggers CodeBuild projects as CloudFormation custom resource\"\n      Handler: index.handler\n      Role: !GetAtt CustomResourceRole.Arn\n      Runtime: python3.9\n      Timeout: 900\n      Code:\n        ZipFile: |\n          import boto3\n          import cfnresponse\n          import json\n          import logging\n          import time\n\n          logger = logging.getLogger()\n          logger.setLevel(logging.INFO)\n\n          def handler(event, context):\n              logger.info('Received event: %s', json.dumps(event))\n\n              try:\n                  if event['RequestType'] == 'Delete':\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})\n                      return\n\n                  project_name = event['ResourceProperties']['ProjectName']\n                  wait_for_completion = event['ResourceProperties'].get('WaitForCompletion', 'true').lower() == 'true'\n\n                  logger.info(f\"Attempting to start CodeBuild project: {project_name}\")\n                  logger.info(f\"Wait for completion: {wait_for_completion}\")\n\n                  # Start the CodeBuild project\n                  codebuild = boto3.client('codebuild')\n\n                  # First, verify the project exists\n                  try:\n                      project_info = codebuild.batch_get_projects(names=[project_name])\n                      if not project_info['projects']:\n                          raise Exception(f\"CodeBuild project '{project_name}' not found\")\n                      logger.info(f\"CodeBuild project '{project_name}' found\")\n                  except Exception as e:\n                      logger.error(f\"Error checking project existence: {str(e)}\")\n                      raise\n\n                  response = codebuild.start_build(projectName=project_name)\n                  build_id = response['build']['id']\n\n                  logger.info(f\"Successfully started build: {build_id}\")\n\n                  if not wait_for_completion:\n                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                          'BuildId': build_id,\n                          'Status': 'STARTED'\n                      })\n                      return\n\n                  # Wait for the build to complete\n                  max_wait_time = context.get_remaining_time_in_millis() / 1000 - 30  # Leave 30s buffer\n                  start_time = time.time()\n\n                  while True:\n                      if time.time() - start_time &gt; max_wait_time:\n                          error_message = f\"Build {build_id} timed out\"\n                          logger.error(error_message)\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': error_message})\n                          return\n\n                      build_response = codebuild.batch_get_builds(ids=[build_id])\n                      build_status = build_response['builds'][0]['buildStatus']\n\n                      if build_status == 'SUCCEEDED':\n                          logger.info(f\"Build {build_id} succeeded\")\n                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {\n                              'BuildId': build_id,\n                              'Status': build_status\n                          })\n                          return\n                      elif build_status in ['FAILED', 'FAULT', 'STOPPED', 'TIMED_OUT']:\n                          error_message = f\"Build {build_id} failed with status: {build_status}\"\n                          logger.error(error_message)\n\n                          # Get build logs for debugging\n                          try:\n                              logs_info = build_response['builds'][0].get('logs', {})\n                              if logs_info.get('groupName') and logs_info.get('streamName'):\n                                  logger.info(f\"Build logs available in CloudWatch\")\n                          except Exception as log_error:\n                              logger.warning(f\"Could not get log information: {log_error}\")\n\n                          cfnresponse.send(event, context, cfnresponse.FAILED, {\n                              'Error': error_message,\n                              'BuildId': build_id\n                          })\n                          return\n\n                      logger.info(f\"Build {build_id} status: {build_status}\")\n                      time.sleep(30)  # Check every 30 seconds\n\n              except Exception as e:\n                  logger.error('Error: %s', str(e))\n                  cfnresponse.send(event, context, cfnresponse.FAILED, {\n                      'Error': str(e)\n                  })\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-codebuild-trigger\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: Lambda\n\n  # ========================================================================\n  # CODEBUILD MODULE - Container Image Building\n  # ========================================================================\n\n  # Agent2 Build Project (build first as it's independent)\n  Agent2ImageBuildProject:\n    Type: AWS::CodeBuild::Project\n    Properties:\n      Name: !Sub \"${AWS::StackName}-agent2-build\"\n      Description: !Sub \"Build agent2 Docker image for ${AWS::StackName}\"\n      ServiceRole: !GetAtt CodeBuildRole.Arn\n      Artifacts:\n        Type: NO_ARTIFACTS\n      Environment:\n        Type: ARM_CONTAINER\n        ComputeType: BUILD_GENERAL1_LARGE\n        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0\n        PrivilegedMode: true\n        EnvironmentVariables:\n          - Name: AWS_DEFAULT_REGION\n            Value: !Ref AWS::Region\n          - Name: AWS_ACCOUNT_ID\n            Value: !Ref AWS::AccountId\n          - Name: IMAGE_REPO_NAME\n            Value: !Ref ECRRepositoryAgent2\n          - Name: IMAGE_TAG\n            Value: !Ref ImageTag\n          - Name: STACK_NAME\n            Value: !Ref AWS::StackName\n      Source:\n        Type: NO_SOURCE\n        BuildSpec: |\n          version: 0.2\n          phases:\n            pre_build:\n              commands:\n                - echo Logging in to Amazon ECR...\n                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com\n            build:\n              commands:\n                - echo Build started on `date`\n                - echo Building the Docker image for agent2 ARM64...\n\n                # Create requirements.txt\n                - |\n                  cat &gt; requirements.txt &lt;&lt; 'EOF'\n                  strands-agents\n                  boto3&gt;=1.40.0\n                  botocore&gt;=1.40.0\n                  bedrock-agentcore\n                  EOF\n\n                # Create agent2.py - specialist agent that handles specific tasks\n                - |\n                  cat &gt; agent2.py &lt;&lt; 'EOF'\n                  from strands import Agent\n                  import os\n                  from bedrock_agentcore.runtime import BedrockAgentCoreApp\n\n                  app = BedrockAgentCoreApp()\n\n                  def create_specialist_agent() -&gt; Agent:\n                      \"\"\"Create a specialist agent that handles specific analytical tasks\"\"\"\n                      system_prompt = \"\"\"You are a specialist analytical agent.\n                      You are an expert at analyzing data and providing detailed insights.\n                      When asked questions, provide thorough, well-reasoned responses with specific details.\n                      Focus on accuracy and completeness in your answers.\"\"\"\n\n                      return Agent(\n                          system_prompt=system_prompt,\n                          name=\"SpecialistAgent\"\n                      )\n\n                  @app.entrypoint\n                  async def invoke(payload=None):\n                      \"\"\"Main entrypoint for agent2\"\"\"\n                      try:\n                          # Get the query from payload\n                          query = payload.get(\"prompt\", \"Hello\") if payload else \"Hello\"\n\n                          # Create and use the specialist agent\n                          agent = create_specialist_agent()\n                          response = agent(query)\n\n                          return {\n                              \"status\": \"success\",\n                              \"agent\": \"agent2\",\n                              \"response\": response.message['content'][0]['text']\n                          }\n\n                      except Exception as e:\n                          return {\n                              \"status\": \"error\",\n                              \"agent\": \"agent2\",\n                              \"error\": str(e)\n                          }\n\n                  if __name__ == \"__main__\":\n                      app.run()\n                  EOF\n\n                # Create Dockerfile\n                - |\n                  cat &gt; Dockerfile &lt;&lt; 'EOF'\n                  FROM public.ecr.aws/docker/library/python:3.11-slim\n                  WORKDIR /app\n\n                  COPY requirements.txt requirements.txt\n                  RUN pip install -r requirements.txt\n                  RUN pip install aws-opentelemetry-distro&gt;=0.10.1\n\n                  # Region will be set by AgentCore runtime environment automatically\n\n                  # Create non-root user\n                  RUN useradd -m -u 1000 bedrock_agentcore\n                  USER bedrock_agentcore\n\n                  EXPOSE 8080\n                  EXPOSE 8000\n\n                  COPY . .\n\n                  CMD [\"opentelemetry-instrument\", \"python\", \"-m\", \"agent2\"]\n                  EOF\n\n                # Build the image\n                - echo Building ARM64 image...\n                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .\n                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n\n            post_build:\n              commands:\n                - echo Build completed on `date`\n                - echo Pushing the Docker image...\n                - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n                - echo ARM64 Docker image pushed successfully\n\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-agent2-build\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: CodeBuild\n\n  # Agent1 Build Project (orchestrator that calls agent2)\n  Agent1ImageBuildProject:\n    Type: AWS::CodeBuild::Project\n    Properties:\n      Name: !Sub \"${AWS::StackName}-agent1-build\"\n      Description: !Sub \"Build agent1 Docker image for ${AWS::StackName}\"\n      ServiceRole: !GetAtt CodeBuildRole.Arn\n      Artifacts:\n        Type: NO_ARTIFACTS\n      Environment:\n        Type: ARM_CONTAINER\n        ComputeType: BUILD_GENERAL1_LARGE\n        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0\n        PrivilegedMode: true\n        EnvironmentVariables:\n          - Name: AWS_DEFAULT_REGION\n            Value: !Ref AWS::Region\n          - Name: AWS_ACCOUNT_ID\n            Value: !Ref AWS::AccountId\n          - Name: IMAGE_REPO_NAME\n            Value: !Ref ECRRepositoryAgent1\n          - Name: IMAGE_TAG\n            Value: !Ref ImageTag\n          - Name: STACK_NAME\n            Value: !Ref AWS::StackName\n      Source:\n        Type: NO_SOURCE\n        BuildSpec: |\n          version: 0.2\n          phases:\n            pre_build:\n              commands:\n                - echo Logging in to Amazon ECR...\n                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com\n            build:\n              commands:\n                - echo Build started on `date`\n                - echo Building the Docker image for agent1 ARM64...\n\n                # Create requirements.txt\n                - |\n                  cat &gt; requirements.txt &lt;&lt; 'EOF'\n                  strands-agents\n                  boto3&gt;=1.40.0\n                  botocore&gt;=1.40.0\n                  bedrock-agentcore\n                  EOF\n\n                # Create agent1.py - orchestrator agent with tool to call agent2\n                - |\n                  cat &gt; agent1.py &lt;&lt; 'EOF'\n                  from strands import Agent, tool\n                  from typing import Dict, Any\n                  import boto3\n                  import json\n                  import os\n                  from bedrock_agentcore.runtime import BedrockAgentCoreApp\n\n                  app = BedrockAgentCoreApp()\n\n                  # Environment variable for Agent2 ARN (will be set by CloudFormation)\n                  AGENT2_ARN = os.getenv('AGENT2_ARN', '')\n\n                  def invoke_agent2(query: str) -&gt; str:\n                      \"\"\"Helper function to invoke agent2 using boto3\"\"\"\n                      import uuid\n                      try:\n                          # Get region from environment or use default\n                          region = os.getenv('AWS_REGION', 'us-west-2')\n                          agentcore_client = boto3.client('bedrock-agentcore', region_name=region)\n\n                          # Invoke agent2 runtime (using AWS sample format)\n                          response = agentcore_client.invoke_agent_runtime(\n                              agentRuntimeArn=AGENT2_ARN,\n                              qualifier=\"DEFAULT\",\n                              payload=json.dumps({\"prompt\": query})\n                          )\n\n                          # Handle streaming response (text/event-stream)\n                          if \"text/event-stream\" in response.get(\"contentType\", \"\"):\n                              result = \"\"\n                              for line in response[\"response\"].iter_lines(chunk_size=10):\n                                  if line:\n                                      line = line.decode(\"utf-8\")\n                                      # Remove 'data: ' prefix if present\n                                      if line.startswith(\"data: \"):\n                                          line = line[6:]\n                                      result += line\n                              return result\n\n                          # Handle JSON response\n                          elif response.get(\"contentType\") == \"application/json\":\n                              content = []\n                              for chunk in response.get(\"response\", []):\n                                  content.append(chunk.decode('utf-8'))\n                              response_data = json.loads(''.join(content))\n                              return json.dumps(response_data)\n\n                          # Handle other response types\n                          else:\n                              response_body = response['response'].read()\n                              return response_body.decode('utf-8')\n\n                      except Exception as e:\n                          import traceback\n                          error_details = traceback.format_exc()\n                          return f\"Error invoking agent2: {str(e)}\\nDetails: {error_details}\"\n\n                  @tool\n                  def call_specialist_agent(query: str) -&gt; Dict[str, Any]:\n                      \"\"\"\n                      Call the specialist agent (agent2) for detailed analysis or complex tasks.\n                      Use this tool when you need expert analysis or detailed information.\n\n                      Args:\n                          query: The question or task to send to the specialist agent\n\n                      Returns:\n                          The specialist agent's response\n                      \"\"\"\n                      result = invoke_agent2(query)\n                      return {\n                          \"status\": \"success\",\n                          \"content\": [{\"text\": result}]\n                      }\n\n                  def create_orchestrator_agent() -&gt; Agent:\n                      \"\"\"Create the orchestrator agent with the tool to call agent2\"\"\"\n                      system_prompt = \"\"\"You are an orchestrator agent.\n                      You can handle simple queries directly, but for complex analytical tasks,\n                      you should delegate to the specialist agent using the call_specialist_agent tool.\n\n                      Use the specialist agent when:\n                      - The query requires detailed analysis\n                      - The query is about complex topics\n                      - The user explicitly asks for expert analysis\n\n                      Handle simple queries (greetings, basic questions) yourself.\"\"\"\n\n                      return Agent(\n                          tools=[call_specialist_agent],\n                          system_prompt=system_prompt,\n                          name=\"OrchestratorAgent\"\n                      )\n\n                  @app.entrypoint\n                  async def invoke(payload=None):\n                      \"\"\"Main entrypoint for agent1\"\"\"\n                      try:\n                          # Get the query from payload\n                          query = payload.get(\"prompt\", \"Hello, how are you?\") if payload else \"Hello, how are you?\"\n\n                          # Create and use the orchestrator agent\n                          agent = create_orchestrator_agent()\n                          response = agent(query)\n\n                          return {\n                              \"status\": \"success\",\n                              \"agent\": \"agent1\",\n                              \"response\": response.message['content'][0]['text']\n                          }\n\n                      except Exception as e:\n                          return {\n                              \"status\": \"error\",\n                              \"agent\": \"agent1\",\n                              \"error\": str(e)\n                          }\n\n                  if __name__ == \"__main__\":\n                      app.run()\n                  EOF\n\n                # Create Dockerfile\n                - |\n                  cat &gt; Dockerfile &lt;&lt; 'EOF'\n                  FROM public.ecr.aws/docker/library/python:3.11-slim\n                  WORKDIR /app\n\n                  COPY requirements.txt requirements.txt\n                  RUN pip install -r requirements.txt\n                  RUN pip install aws-opentelemetry-distro&gt;=0.10.1\n\n                  # Region will be set by AgentCore runtime environment automatically\n\n                  # Create non-root user\n                  RUN useradd -m -u 1000 bedrock_agentcore\n                  USER bedrock_agentcore\n\n                  EXPOSE 8080\n                  EXPOSE 8000\n\n                  COPY . .\n\n                  CMD [\"opentelemetry-instrument\", \"python\", \"-m\", \"agent1\"]\n                  EOF\n\n                # Build the image\n                - echo Building ARM64 image...\n                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .\n                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n\n            post_build:\n              commands:\n                - echo Build completed on `date`\n                - echo Pushing the Docker image...\n                - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\n                - echo ARM64 Docker image pushed successfully\n\n      Tags:\n        - Key: Name\n          Value: !Sub \"${AWS::StackName}-agent1-build\"\n        - Key: StackName\n          Value: !Ref AWS::StackName\n        - Key: Module\n          Value: CodeBuild\n\n  # CUSTOM RESOURCE - Trigger Agent2 Image Build\n  TriggerAgent2ImageBuild:\n    Type: Custom::CodeBuildTrigger\n    DependsOn:\n      - ECRRepositoryAgent2\n      - Agent2ImageBuildProject\n      - CodeBuildTriggerFunction\n    Properties:\n      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn\n      ProjectName: !Ref Agent2ImageBuildProject\n      WaitForCompletion: \"true\"\n\n  # CUSTOM RESOURCE - Trigger Agent1 Image Build\n  TriggerAgent1ImageBuild:\n    Type: Custom::CodeBuildTrigger\n    DependsOn:\n      - ECRRepositoryAgent1\n      - Agent1ImageBuildProject\n      - CodeBuildTriggerFunction\n    Properties:\n      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn\n      ProjectName: !Ref Agent1ImageBuildProject\n      WaitForCompletion: \"true\"\n\n  # ========================================================================\n  # AGENTCORE MODULE - Runtime Resources\n  # ========================================================================\n\n  # Agent2 Runtime (deploy first as agent1 depends on it)\n  Agent2Runtime:\n    Type: AWS::BedrockAgentCore::Runtime\n    DependsOn:\n      - TriggerAgent2ImageBuild\n    Properties:\n      AgentRuntimeName: !Sub\n        - \"${StackNameUnderscore}_${Agent2Name}\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      AgentRuntimeArtifact:\n        ContainerConfiguration:\n          ContainerUri: !Sub \"${ECRRepositoryAgent2.RepositoryUri}:${ImageTag}\"\n      RoleArn: !GetAtt Agent2ExecutionRole.Arn\n      NetworkConfiguration:\n        NetworkMode: !Ref NetworkMode\n      Description: !Sub \"Specialist agent runtime for ${AWS::StackName}\"\n\n  # Agent1 Runtime (orchestrator with agent2 ARN as environment variable)\n  Agent1Runtime:\n    Type: AWS::BedrockAgentCore::Runtime\n    DependsOn:\n      - TriggerAgent1ImageBuild\n      - Agent2Runtime\n    Properties:\n      AgentRuntimeName: !Sub\n        - \"${StackNameUnderscore}_${Agent1Name}\"\n        - StackNameUnderscore: !Join [\"_\", !Split [\"-\", !Ref \"AWS::StackName\"]]\n      AgentRuntimeArtifact:\n        ContainerConfiguration:\n          ContainerUri: !Sub \"${ECRRepositoryAgent1.RepositoryUri}:${ImageTag}\"\n      RoleArn: !GetAtt Agent1ExecutionRole.Arn\n      NetworkConfiguration:\n        NetworkMode: !Ref NetworkMode\n      Description: !Sub \"Orchestrator agent runtime for ${AWS::StackName}\"\n      EnvironmentVariables:\n        AGENT2_ARN: !GetAtt Agent2Runtime.AgentRuntimeArn\n\n# ============================================================================\n# OUTPUTS SECTION\n# ============================================================================\nOutputs:\n  # AGENT1 (ORCHESTRATOR) OUTPUTS\n  Agent1RuntimeId:\n    Description: \"ID of agent1 (orchestrator) runtime\"\n    Value: !GetAtt Agent1Runtime.AgentRuntimeId\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent1RuntimeId\"\n\n  Agent1RuntimeArn:\n    Description: \"ARN of agent1 (orchestrator) runtime\"\n    Value: !GetAtt Agent1Runtime.AgentRuntimeArn\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent1RuntimeArn\"\n\n  Agent1ECRRepositoryUri:\n    Description: \"URI of the ECR repository for agent1\"\n    Value: !GetAtt ECRRepositoryAgent1.RepositoryUri\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent1ECRRepositoryUri\"\n\n  Agent1ExecutionRoleArn:\n    Description: \"ARN of agent1 execution role\"\n    Value: !GetAtt Agent1ExecutionRole.Arn\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent1ExecutionRoleArn\"\n\n  # AGENT2 (SPECIALIST) OUTPUTS\n  Agent2RuntimeId:\n    Description: \"ID of agent2 (specialist) runtime\"\n    Value: !GetAtt Agent2Runtime.AgentRuntimeId\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent2RuntimeId\"\n\n  Agent2RuntimeArn:\n    Description: \"ARN of agent2 (specialist) runtime\"\n    Value: !GetAtt Agent2Runtime.AgentRuntimeArn\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent2RuntimeArn\"\n\n  Agent2ECRRepositoryUri:\n    Description: \"URI of the ECR repository for agent2\"\n    Value: !GetAtt ECRRepositoryAgent2.RepositoryUri\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent2ECRRepositoryUri\"\n\n  Agent2ExecutionRoleArn:\n    Description: \"ARN of agent2 execution role\"\n    Value: !GetAtt Agent2ExecutionRole.Arn\n    Export:\n      Name: !Sub \"${AWS::StackName}-Agent2ExecutionRoleArn\"\n</code></pre>"},{"location":"examples/infrastructure-as-code/cloudformation/multi-agent-runtime/multi-agent-runtime-deploy-bash-script.html","title":"Multi agent runtime deploy bash script","text":"<pre><code>#!/bin/bash\n\n# Deploy script for Multi-Agent Runtime CloudFormation stack\n# This script deploys two AgentCore Runtimes where Agent1 can invoke Agent2\n\nset -e\n\n# Configuration\nSTACK_NAME=\"${1:-multi-agent-demo}\"\nREGION=\"${2:-us-west-2}\"\nTEMPLATE_FILE=\"template.yaml\"\n\necho \"==========================================\"\necho \"Deploying Multi-Agent Runtime\"\necho \"==========================================\"\necho \"Stack Name: $STACK_NAME\"\necho \"Region: $REGION\"\necho \"==========================================\"\n\n# Check if template file exists\nif [ ! -f \"$TEMPLATE_FILE\" ]; then\n    echo \"Error: Template file '$TEMPLATE_FILE' not found!\"\n    exit 1\nfi\n\n# Deploy the CloudFormation stack\necho \"\"\necho \"Creating CloudFormation stack...\"\naws cloudformation create-stack \\\n    --stack-name \"$STACK_NAME\" \\\n    --template-body file://\"$TEMPLATE_FILE\" \\\n    --capabilities CAPABILITY_NAMED_IAM \\\n    --region \"$REGION\"\n\nif [ $? -eq 0 ]; then\n    echo \"\"\n    echo \"\u2713 Stack creation initiated successfully!\"\n    echo \"\"\n    echo \"Waiting for stack creation to complete...\"\n    echo \"This will take approximately 15-20 minutes...\"\n    echo \"(Building two Docker images and deploying two agents)\"\n    echo \"\"\n\n    aws cloudformation wait stack-create-complete \\\n        --stack-name \"$STACK_NAME\" \\\n        --region \"$REGION\"\n\n    if [ $? -eq 0 ]; then\n        echo \"\"\n        echo \"==========================================\"\n        echo \"\u2713 Stack deployed successfully!\"\n        echo \"==========================================\"\n        echo \"\"\n        echo \"Stack Outputs:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs' \\\n            --output table \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Agent1 (Orchestrator) Runtime ARN:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`Agent1RuntimeArn`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"Agent2 (Specialist) Runtime ARN:\"\n        aws cloudformation describe-stacks \\\n            --stack-name \"$STACK_NAME\" \\\n            --query 'Stacks[0].Outputs[?OutputKey==`Agent2RuntimeArn`].OutputValue' \\\n            --output text \\\n            --region \"$REGION\"\n        echo \"\"\n        echo \"To delete this stack, run:\"\n        echo \"  ./cleanup.sh $STACK_NAME $REGION\"\n        echo \"\"\n    else\n        echo \"\"\n        echo \"\u2717 Stack creation failed or timed out\"\n        echo \"Check the CloudFormation console for details\"\n        exit 1\n    fi\nelse\n    echo \"\"\n    echo \"\u2717 Failed to initiate stack creation\"\n    exit 1\nfi\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/adk/adk-agent.html","title":"Adk agent","text":"<pre><code>from google.adk.agents import Agent\nfrom google.adk.runners import Runner\nfrom google.adk.sessions import InMemorySessionService\nfrom google.adk.tools import google_search\nfrom google.genai import types\nimport asyncio\nimport os\n\n# adapted form https://google.github.io/adk-docs/tools/built-in-tools/#google-search\n\nAPP_NAME=\"google_search_agent\"\nUSER_ID=\"user1234\"\n\n# Agent Definition\n# Add your GEMINI_API_KEY \nroot_agent = Agent(\n    model=\"gemini-2.0-flash\", \n    name=\"openai_agent\",\n    description=\"Agent to answer questions using Google Search.\",\n    instruction=\"I can answer your questions by searching the internet. Just ask me anything!\",\n    # google_search is a pre-built tool which allows the agent to perform Google searches.\n    tools=[google_search]\n)\n\n# Session and Runner\nasync def setup_session_and_runner(user_id, session_id):\n    session_service = InMemorySessionService()\n    session = await session_service.create_session(app_name=APP_NAME, user_id=user_id, session_id=session_id)\n    runner = Runner(agent=root_agent, app_name=APP_NAME, session_service=session_service)\n    return session, runner\n\n# Agent Interaction\nasync def call_agent_async(query, user_id, session_id):\n    content = types.Content(role='user', parts=[types.Part(text=query)])\n    session, runner = await setup_session_and_runner(user_id, session_id)\n    events = runner.run_async(user_id=user_id, session_id=session_id, new_message=content)\n\n    async for event in events:\n        if event.is_final_response():\n            final_response = event.content.parts[0].text\n            print(\"Agent Response: \", final_response)\n\n    return final_response\n\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef agent_invocation(payload, context):\n    return asyncio.run(call_agent_async(payload.get(\"prompt\", \"what is Bedrock Agentcore Runtime?\"), payload.get(\"user_id\",USER_ID), context.session_id))\n\napp.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/autogen/autogen-agent.html","title":"Autogen agent","text":"<pre><code>from autogen_agentchat.agents import AssistantAgent\nfrom autogen_agentchat.ui import Console\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\nimport asyncio\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(\"autogen_agent\")\n\nprint(1)\n# Adapted from https://microsoft.github.io/autogen/stable/user-guide/agentchat-user-guide/quickstart.html\n# Define a model client. You can use other model client that implements\n# the `ChatCompletionClient` interface.\nfrom autogen_agentchat.agents import AssistantAgent\nfrom autogen_agentchat.ui import Console\nfrom autogen_ext.models.openai import OpenAIChatCompletionClient\n\n# Define a model client. You can use other model client that implements\n# the `ChatCompletionClient` interface.\nmodel_client = OpenAIChatCompletionClient(\n    model=\"gpt-4o\",\n)\n\nprint(2)\n\n# Define a simple function tool that the agent can use.\n# For this example, we use a fake weather tool for demonstration purposes.\nasync def get_weather(city: str) -&gt; str:\n    \"\"\"Get the weather for a given city.\"\"\"\n    print(\"tool\")\n    return f\"The weather in {city} is 73 degrees and Sunny.\"\n\n\n# Define an AssistantAgent with the model, tool, system message, and reflection enabled.\n# The system message instructs the agent via natural language.\nagent = AssistantAgent(\n    name=\"weather_agent\",\n    model_client=model_client,\n    tools=[get_weather],\n    system_message=\"You are a helpful assistant.\",\n    reflect_on_tool_use=True,\n    model_client_stream=True,  # Enable streaming tokens from the model client.\n)\n\nprint(4)\n\n# Run the agent and stream the messages to the console.\n\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\nasync def main(payload):\n    logger.debug(\"Starting agent execution\")\n    print(5)\n\n    try:\n        # Get prompt from payload or use default\n        prompt = payload.get(\"prompt\", \"Hello! What can you help me with?\")\n        logger.debug(f\"Processing prompt: {prompt}\")\n\n        # Run the agent\n        result = await Console(agent.run_stream(task=prompt))\n        logger.debug(f\"Agent result type: {type(result)}\")\n        print(result)\n\n        # Extract the last message content for JSON serialization\n        if result and hasattr(result, 'messages') and result.messages:\n            last_message = result.messages[-1]\n            logger.debug(f\"Last message: {last_message}\")\n            if hasattr(last_message, 'content'):\n                response = {\"result\": last_message.content}\n                logger.debug(f\"Returning response: {response}\")\n                return response\n\n        # Fallback if we can't extract content\n        logger.warning(\"Could not extract content from result\")\n        return {\"result\": \"No response generated\"}\n    except Exception as e:\n        logger.error(f\"Error in main handler: {e}\", exc_info=True)\n        return {\"result\": f\"Error: {str(e)}\"}\n    finally:\n        # Always close the connection to the model client\n        logger.debug(\"Closing model client connection\")\n        # await model_client.close() ## Do not close client with sticky sessions on runtime, otherwise you will get `RuntimeError: Cannot send a request, as the client has been closed.` \n\napp.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/langgraph/langgraph-agent.html","title":"Langgraph agent","text":"<pre><code>from typing import Annotated\n\nfrom langchain.chat_models import init_chat_model\nfrom typing_extensions import TypedDict\n\nfrom langgraph.graph import StateGraph, START\nfrom langgraph.graph.message import add_messages\nfrom langgraph.prebuilt import ToolNode, tools_condition\n\n\nimport logging\nlangchain_logger = logging.getLogger(\"langchain\")\nlangchain_logger.setLevel(logging.DEBUG)\nimport os\nprint(\"Starting up...\")\nos.environ[\"LANGSMITH_OTEL_ENABLED\"]= \"true\"\n\nllm = init_chat_model(\n    \"us.anthropic.claude-3-5-haiku-20241022-v1:0\",\n    model_provider=\"bedrock_converse\",\n)\n\n## Define search tool\nfrom langchain_community.tools import DuckDuckGoSearchRun\nsearch = DuckDuckGoSearchRun()\ntools = [search]\nllm_with_tools = llm.bind_tools(tools)\n\nprint(\"Defining state...\")\n## Define state\nclass State(TypedDict):\n    messages: Annotated[list, add_messages]\n\n\ngraph_builder = StateGraph(State)\n\n\ndef chatbot(state: State):\n    return {\"messages\": [llm_with_tools.invoke(state[\"messages\"])]}\n\nprint(\"Configuring graph...\")\ngraph_builder.add_node(\"chatbot\", chatbot)\n\ntool_node = ToolNode(tools=tools)\n\ngraph_builder.add_node(\"tools\", tool_node)\n\ngraph_builder.add_conditional_edges(\n    \"chatbot\",\n    tools_condition,\n)\n# Any time a tool is called, we return to the chatbot to decide the next step\ngraph_builder.add_edge(\"tools\", \"chatbot\")\ngraph_builder.add_edge(START, \"chatbot\")\ngraph = graph_builder.compile()\ngraph_configured = True\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef agent_invocation(payload, context):\n\n    print(\"received payload\")\n    print(payload)\n\n    tmp_msg = {\"messages\": [{\"role\": \"user\", \"content\": payload.get(\"prompt\", \"No prompt found in input, please guide customer as to what tools can be used\")}]}\n    tmp_output = graph.invoke(tmp_msg)\n    print(tmp_output)\n\n    return {\"result\": tmp_output['messages'][-1].content}\n\napp.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/llamaindex/llama-agent.html","title":"Llama agent","text":"<pre><code>import asyncio\nfrom llama_index.core.agent.workflow import FunctionAgent\nfrom llama_index.llms.openai import OpenAI\nfrom llama_index.tools.yahoo_finance import YahooFinanceToolSpec\n\n# Define custom function tools\n\ndef multiply(a: float, b: float) -&gt; float:\n    \"\"\"Multiply two numbers and returns the product\"\"\"\n    return a * b\n\n\ndef add(a: float, b: float) -&gt; float:\n    \"\"\"Add two numbers and returns the sum\"\"\"\n    return a + b\n\n# Add other predefined tools\nfinance_tools = YahooFinanceToolSpec().to_tool_list()\n\nfinance_tools.extend([multiply, add])\n\n# Create an agent workflow with our calculator tool\nagent = FunctionAgent(\n    tools=finance_tools,\n    llm=OpenAI(model=\"gpt-4o-mini\"),\n    system_prompt=\"You are a helpful assistant.\",\n)\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\nasync def main(payload):\n    # Run the agent\n    response = await agent.run(payload.get(\"prompt\",\"What is the current stock price of AMZN?\"))\n    print(response)\n    return response.response.content\n\n\n# Run the agent\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/openai/openai-agent-basic-example.html","title":"Openai agent basic example","text":"<pre><code>from agents import Agent, Runner, WebSearchTool\nimport logging\nimport asyncio\nimport sys\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.StreamHandler(sys.stdout)\n    ]\n)\nlogger = logging.getLogger(\"openai_agents\")\n\n# Configure OpenAI library logging\nlogging.getLogger(\"openai\").setLevel(logging.DEBUG)\n\nlogger.debug(\"Initializing OpenAI agent with tools\")\nagent = Agent(\n    name=\"Assistant\",\n    tools=[\n        WebSearchTool(),\n    ],\n)\n\nasync def main(query=None):\n    if query is None:\n        query = \"Which coffee shop should I go to, taking into account my preferences and the weather today in SF?\"\n\n    logger.debug(f\"Running agent with query: {query}\")\n\n    try:\n        logger.debug(\"Starting agent execution\")\n        result = await Runner.run(agent, query)\n        logger.debug(f\"Agent execution completed with result type: {type(result)}\")\n        return result\n    except Exception as e:\n        logger.error(f\"Error during agent execution: {e}\", exc_info=True)\n        raise\n\n# Integration with Bedrock AgentCore\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\nasync def agent_invocation(payload, context):\n    logger.debug(f\"Received payload: {payload}\")\n    query = payload.get(\"prompt\", \"How can I help you today?\")\n\n    try:\n        result = await main(query)\n        logger.debug(\"Agent execution completed successfully\")\n        return {\"result\": result.final_output}\n    except Exception as e:\n        logger.error(f\"Error during agent execution: {e}\", exc_info=True)\n        return {\"result\": f\"Error: {str(e)}\"}\n\n# Run the app when imported\nif __name__== \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/openai/openai-agent-handoff-example.html","title":"Openai agent handoff example","text":"<pre><code>import logging\nimport sys\nimport asyncio\nfrom agents import Agent, WebSearchTool, Runner\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.StreamHandler(sys.stdout)\n    ]\n)\nlogger = logging.getLogger(\"openai_agents_handoff\")\n\n# Configure OpenAI library logging\nlogging.getLogger(\"openai\").setLevel(logging.DEBUG)\n\n# Create specialized agents for different tasks\ntravel_agent = Agent(\n    name=\"Travel Expert\",\n    instructions=(\n        \"You are a travel expert who helps users plan their trips. \"\n        \"Use web search to find up-to-date information about destinations, \"\n        \"flights, accommodations, and travel requirements. \"\n        \"Provide specific recommendations based on the user's preferences.\"\n    ),\n    tools=[WebSearchTool()]\n)\n\nfood_agent = Agent(\n    name=\"Food Expert\",\n    instructions=(\n        \"You are a food expert who helps users find great dining options. \"\n        \"Use web search to find information about restaurants, local cuisine, \"\n        \"food tours, and dietary accommodations. \"\n        \"Provide specific recommendations based on the user's preferences and location.\"\n    ),\n    tools=[WebSearchTool()]\n)\n\n# Create the main triage agent that can hand off to specialized agents\ntriage_agent = Agent(\n    name=\"Travel Assistant\",\n    instructions=(\n        \"You are a helpful travel assistant. \"\n        \"If the user asks about travel planning, destinations, flights, or accommodations, \"\n        \"hand off to the Travel Expert. \"\n        \"If the user asks about food, restaurants, or dining options, \"\n        \"hand off to the Food Expert. \"\n        \"For general questions, answer directly.\"\n    ),\n    handoffs=[travel_agent, food_agent]\n)\n\nasync def main():\n    # Example queries to demonstrate handoffs\n    queries = [\n        \"I'm planning a trip to Japan next month. What should I know?\",\n        \"What are some good restaurants to try in Tokyo?\",\n        \"What's the weather like in San Francisco today?\"\n    ]\n\n    for query in queries:\n        logger.debug(f\"Processing query: {query}\")\n        print(f\"\\n\\n--- QUERY: {query} ---\\n\")\n\n        try:\n            result = await Runner.run(triage_agent, query)\n            logger.debug(f\"Agent execution completed for query: {query}\")\n            print(f\"FINAL RESPONSE:\\n{result.final_output}\")\n\n            # Log which agent handled the query\n            if hasattr(result, 'thread') and result.thread:\n                messages = result.thread.messages\n                for message in messages:\n                    if hasattr(message, 'role') and message.role == 'assistant':\n                        if hasattr(message, 'name') and message.name:\n                            logger.debug(f\"Message from agent: {message.name}\")\n\n        except Exception as e:\n            logger.error(f\"Error processing query '{query}': {e}\", exc_info=True)\n            print(f\"Error: {str(e)}\")\n\n\n# Integration with Bedrock AgentCore\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\nasync def agent_invocation(payload, context):\n    logger.debug(f\"Received payload: {payload}\")\n    query = payload.get(\"prompt\", \"How can I help you with your travel plans?\")\n\n    try:\n        result = await Runner.run(triage_agent, query)\n        logger.debug(\"Agent execution completed successfully\")\n        return {\"result\": result.final_output}\n    except Exception as e:\n        logger.error(f\"Error during agent execution: {e}\", exc_info=True)\n        return {\"result\": f\"Error: {str(e)}\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/pydanticai/pydanticai-agent.html","title":"Pydanticai agent","text":"<pre><code>from pydantic_ai.agent import Agent, RunContext\n\nfrom datetime import datetime\nimport json\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom pydantic_ai.models.bedrock import BedrockConverseModel\n\napp = BedrockAgentCoreApp()\n\nmodel = BedrockConverseModel('us.anthropic.claude-sonnet-4-20250514-v1:0')\ndummy_agent = Agent(\n    model=model,\n    system_prompt=\"You're a helpful assistant. Use the tools available for you to answer questions.\"\n\n)\n\n@dummy_agent.tool  \ndef get_current_date(ctx: RunContext[datetime]):\n  print(\"Getting current date...\")\n  current_date = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n  return current_date\n\n\n@dummy_agent.tool\ndef get_weather(ctx: RunContext[str]):\n        # Simulated weather data\n  return f\"Sunny\"\n\n@app.entrypoint\ndef pydantic_bedrock_claude_main(payload):\n  \"\"\"\n   Invoke the agent with a payload\n  \"\"\"\n  user_input = payload.get(\"prompt\")\n  result = dummy_agent.run_sync(user_input)\n  print(result.output)\n  return result.output\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/strands/strands-agent-basic-example.html","title":"Strands agent basic example","text":"<pre><code>import os\nos.environ[\"BYPASS_TOOL_CONSENT\"]=\"true\"\n\nfrom strands import Agent\nfrom strands_tools import file_read, file_write, editor\n\nagent = Agent(tools=[file_read, file_write, editor])\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef agent_invocation(payload, context):\n    \"\"\"Handler for agent invocation\"\"\"\n    user_message = payload.get(\"prompt\", \"No prompt found in input, please guide customer to create a json payload with prompt key\")\n    result = agent(user_message)\n    print(\"context:\\n-------\\n\", context)\n    print(\"result:\\n*******\\n\", result)\n    return {\"result\": result.message}\n\napp.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/strands/strands-agent-openai-identity-example.html","title":"Strands agent openai identity example","text":"<pre><code>import asyncio\nimport os\nfrom bedrock_agentcore.identity.auth import requires_api_key\nfrom strands import Agent\nfrom strands.models.openai import OpenAIModel\nfrom strands_tools import calculator\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\n\n# Global agent variable\nagent = None\n\n@requires_api_key(\n    provider_name=\"openai-apikey-provider\" # replace with your own credential provider name\n)\nasync def need_api_key(*, api_key: str):\n    print(\"received api key for async func\")\n    os.environ[\"OPENAI_API_KEY\"] = api_key\n\ndef create_model():\n    \"\"\"Create the OpenAI model with the API key\"\"\"\n    return OpenAIModel(\n        client_args={\n            \"api_key\": os.environ.get(\"OPENAI_API_KEY\"), \n        },\n        model_id=\"gpt-4o\",\n        params={\n            \"max_tokens\": 1000,\n            \"temperature\": 0.7,\n        }\n    )\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\nasync def strands_agent_open_ai(payload):\n    \"\"\"\n    Invoke the agent with a payload\n    \"\"\"\n    global agent\n\n    print(f\"Entrypoint called\")\n\n    # Get API key if not already set in environment\n    if not os.environ.get(\"OPENAI_API_KEY\"):\n        print(\"Attempting to retrieve API key...\")\n        try:\n            await need_api_key(api_key=\"\")\n            print(\"API key retrieved and set in environment\")\n        except Exception as e:\n            print(f\"Error retrieving API key: {e}\")\n            raise\n    else:\n        print(\"API key already available in environment\")\n\n    # Initialize agent after API key is set\n    if agent is None:\n        print(\"Initializing agent with API key...\")\n        model = create_model()\n        agent = Agent(model=model, tools=[calculator])\n    user_input = payload.get(\"prompt\")\n    print(f\"User input: {user_input}\")\n\n    try:\n        response = agent(user_input)\n        print(f\"Agent response: {response}\")\n        return response.message['content'][0]['text']\n    except Exception as e:\n        print(f\"Error in agent processing: {e}\")\n        raise\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/integrations/agentic-frameworks/strands/strands-agent-streaming-example.html","title":"Strands agent streaming example","text":"<pre><code>import asyncio\nimport os\nos.environ[\"BYPASS_TOOL_CONSENT\"]=\"true\"\n\nfrom strands import Agent\nfrom strands_tools import calculator\n\n# Initialize our agent without a callback handler\nagent = Agent(\n    tools=[calculator],\n    callback_handler=None\n)\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\nasync def agent_invocation(payload, context):\n    \"\"\"Handler for agent invocation with streaming support\"\"\"\n    user_message = payload.get(\"prompt\", \"No prompt found in input, please guide customer to create a json payload with prompt key\")\n\n    print(\"context:\\n-------\\n\", context)\n    print(\"processing message:\\n*******\\n\", user_message)\n\n    # Get the agent stream\n    agent_stream = agent.stream_async(user_message)\n\n    async for event in agent_stream:\n        yield event\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/observability/dynatrace/observability-agent-and-dynatrace-init.html","title":"Observability agent and dynatrace init","text":"<pre><code>from dynatrace import init\n\ninit()\n\nfrom travel_agent import app\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"examples/observability/dynatrace/observability-basic-agent.html","title":"Observability basic agent","text":"<pre><code>import os\nfrom strands import Agent, tool\nfrom strands_tools import calculator  # Import the calculator tool\nfrom strands.models import BedrockModel\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n# Create a custom tool\n@tool\ndef weather():\n    \"\"\"Get weather\"\"\"  # Dummy implementation\n    return \"sunny\"\n\n\nmodel_id = os.getenv(\"BEDROCK_MODEL_ID\", \"eu.anthropic.claude-3-7-sonnet-20250219-v1:0\")\nmodel = BedrockModel(\n    model_id=model_id,\n)\nagent = Agent(\n    model=model,\n    tools=[calculator, weather],\n    system_prompt=\"You're a helpful assistant. You can do simple math calculation, and tell the weather.\",\n)\n\n@app.entrypoint\ndef strands_agent_bedrock(payload):\n    \"\"\"\n    Invoke the agent with a payload\n    \"\"\"\n    user_input = payload.get(\"prompt\")\n    response = agent(user_input)\n    return response.message[\"content\"][0][\"text\"]\n</code></pre>"},{"location":"examples/observability/dynatrace/observability-dynatrace.html","title":"Observability dynatrace","text":"<pre><code>import os\n\n\ndef read_secret(secret: str):\n    try:\n        with open(f\"/etc/secrets/{secret}\", \"r\") as f:\n            return f.read().rstrip()\n    except Exception as e:\n        print(\"No token was provided as secret\")\n        return os.environ.get(\"DT_TOKEN\", \"\")\n\n\ndef init():\n    os.environ[\"OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE\"] = \"delta\"\n    token = read_secret(\"dynatrace_otel\")\n    headers = {\"Authorization\": f\"Api-Token {token}\"}\n    OTEL_ENDPOINT = os.environ.get(\n        \"OTEL_ENDPOINT\",\n        \"https://wkf10640.live.dynatrace.com/api/v2/otlp\",  # manually configure your DT tenant here or a OTel collector endpoint\n    )\n    from opentelemetry import trace, metrics\n    from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter\n    from opentelemetry.exporter.otlp.proto.http.metric_exporter import (\n        OTLPMetricExporter,\n    )\n    from opentelemetry.sdk.metrics import MeterProvider\n    from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader\n    from opentelemetry.sdk.trace import TracerProvider\n    from opentelemetry.sdk.trace.export import SimpleSpanProcessor\n    from opentelemetry.sdk.resources import Resource\n\n    resource = Resource.create(\n        {\n            \"service.name\": \"agent-core-samples\",\n        }\n    )\n\n    provider = TracerProvider(resource=resource)\n    processor = SimpleSpanProcessor(\n        OTLPSpanExporter(endpoint=f\"{OTEL_ENDPOINT}/v1/traces\", headers=headers)\n    )\n    provider.add_span_processor(processor)\n    trace.set_tracer_provider(provider)\n\n    reader = PeriodicExportingMetricReader(\n        OTLPMetricExporter(endpoint=f\"{OTEL_ENDPOINT}/v1/metrics\", headers=headers)\n    )\n    provider = MeterProvider(\n        metric_readers=[reader],\n        resource=resource,\n    )\n    metrics.set_meter_provider(provider)\n</code></pre>"},{"location":"mcp/agentcore_runtime_deployment.html","title":"Agentcore runtime deployment","text":""},{"location":"mcp/agentcore_runtime_deployment.html#build-your-first-agent-or-transform-existing-code","title":"Build your first agent or transform existing code","text":""},{"location":"mcp/agentcore_runtime_deployment.html#prerequisites-environment-setup","title":"Prerequisites &amp; Environment Setup","text":"<ul> <li>Environment: Set up Python 3.10+ and virtual environment - Environment Setup</li> </ul>"},{"location":"mcp/agentcore_runtime_deployment.html#step-1-install-dependencies-create-agent-code","title":"Step 1: Install Dependencies &amp; Create Agent Code","text":"<ul> <li>New Agents: Install AgentCore packages and create your agent using hello world strands agents  Installation &amp; Creation Guide</li> <li>Existing Agents: Transform your current agent code to work with AgentCore - Framework Integration Examples</li> </ul>"},{"location":"mcp/agentcore_runtime_deployment.html#step-11-for-strands-refer-to-following-documentation","title":"Step 1.1: For strands refer to following documentation","text":"<ul> <li>Welcome</li> <li>Amazon Bedrock</li> <li>Amazon Bedrock AgentCore</li> <li>Import strands agent - <code>from strands import Agent</code></li> <li>Create an agent with default settings - agent = Agent()</li> <li>Ask the agent a question - agent(\"Tell me about agentic AI\")</li> </ul>"},{"location":"mcp/agentcore_runtime_deployment.html#step-12-transforming-agent-code-for-agentcore","title":"Step 1.2 - Transforming agent code for agentcore","text":"<ul> <li>Agent code: Always use these code patterns for agent code.</li> <li>AgentCore Wrapper: Use  bedrock-agentcore wrappers to implement runtime service contract.</li> <li>Import the Runtime App with from bedrock_agentcore.runtime import BedrockAgentCoreApp</li> <li>Initialize the App in your code with app = BedrockAgentCoreApp()</li> <li>Decorate the invocation function with the @app.entrypoint decorator</li> <li>Create a requirements.txt file with needed packages. Note: if strands-tools is detected, the correct library to add is strands-agents-tools</li> <li>Let AgentCore Runtime control the running of the agent with app.run()</li> </ul>"},{"location":"mcp/agentcore_runtime_deployment.html#step-2-local-development-testing-optional","title":"Step 2: Local Development &amp; Testing (Optional)","text":"<ul> <li>Local Testing: Run and test your agent locally before deployment - Local Testing Guide</li> <li>Start the agent using python  <li> </li> <li>Stop the agent.</li>"},{"location":"mcp/agentcore_runtime_deployment.html#test-it-in-another-terminal","title":"Test it (in another terminal)","text":"<p>curl -X POST http://localhost:8080/invocations \\ -H \"Content-Type: application/json\" \\ -d '{\"prompt\": \"Hello!\"}'</p>"},{"location":"mcp/agentcore_runtime_deployment.html#step-3-deploy-to-agentcore-using-cli","title":"Step 3: Deploy to AgentCore using CLI","text":"<p>Refer to https://aws.github.io/bedrock-agentcore-starter-toolkit/api-reference/cli.html 1. Install cli with 'pip install bedrock-agentcore-starter-toolkit' 2. Configuration: Use AgentCore CLI to configure your agent for deployment.     <code>agentcore configure --entrypoint converted_agentcore_file.py --non-interactive</code> 3. Deployment: Launch your agent to AWS with automatic resource creation.     <code>agentcore launch</code> 4. Invocation: agentcore invoke '{\"prompt\": \"Hello\"}' Test your deployed agent using the CLI or API calls</p>"},{"location":"mcp/agentcore_runtime_deployment.html#step-4-troubleshooting-enhancement","title":"Step 4: Troubleshooting &amp; Enhancement","text":"<ul> <li>Common Issues: Resolve deployment and runtime issues - Troubleshooting Guide</li> <li>Advanced Features: Add memory, authentication, and gateway integrations - Next Steps</li> <li>Monitoring: Set up observability and monitoring for production agents</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html","title":"AgentCore Browser Quickstart","text":"<p>AgentCore Browser enables your agents to interact with web pages through a managed Chrome browser. The agent can navigate websites, search for information, extract content, and interact with web elements in a secure, managed environment.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#prerequisites","title":"Prerequisites","text":"<p>Before you start, ensure you have:</p> <ul> <li>AWS Account with credentials configured. See instructions below.</li> <li>Python 3.10+ installed</li> <li>Boto3 installed</li> <li>IAM Execution Role with the required permissions (see below)</li> <li>Model access: Anthropic Claude Sonnet 4.0 enabled in the Amazon Bedrock console. For information about using a different model with the Strands Agents see the Model Providers section in the Strands Agents SDK documentation.</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#credentials-configuration-if-not-already-configured","title":"Credentials configuration (if not already configured)","text":"<p>Confirm your AWS credentials are configured:</p> <pre><code>aws sts get-caller-identity\n</code></pre> <p>If this command fails, configure your credentials. See Configuration and credential file settings in the AWS CLI documentation.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#attach-required-permissions","title":"Attach Required Permissions","text":"<p>Your IAM user or role needs permissions to use Browser. Attach this policy to your IAM identity:</p> <pre><code>{\n    \"Version\":\"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"BedrockAgentCoreBrowserFullAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock-agentcore:CreateBrowser\",\n                \"bedrock-agentcore:ListBrowsers\",\n                \"bedrock-agentcore:GetBrowser\",\n                \"bedrock-agentcore:DeleteBrowser\",\n                \"bedrock-agentcore:StartBrowserSession\",\n                \"bedrock-agentcore:ListBrowserSessions\",\n                \"bedrock-agentcore:GetBrowserSession\",\n                \"bedrock-agentcore:StopBrowserSession\",\n                \"bedrock-agentcore:UpdateBrowserStream\",\n                \"bedrock-agentcore:ConnectBrowserAutomationStream\",\n                \"bedrock-agentcore:ConnectBrowserLiveViewStream\"\n            ],\n            \"Resource\": \"arn:aws:bedrock-agentcore:&lt;region&gt;:&lt;account_id&gt;:browser/*\"\n        },\n        {\n            \"Sid\": \"BedrockModelAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:InvokeModelWithResponseStream\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        }\n    ]\n}\n</code></pre> <p>To attach this policy:</p> <ol> <li>Navigate to the IAM Console</li> <li>Find your user or role (the one returned by <code>aws sts get-caller-identity</code>)</li> <li>Click \"Add permissions\" \u2192 \"Create inline policy\"</li> <li>Switch to JSON view and paste the policy above</li> <li>Name it <code>AgentCoreBrowserAccess</code> and save</li> </ol> <p>Note: If you're deploying agents to AgentCore Runtime (not covered in this guide), you'll also need to create an IAM execution role with a service trust policy. See the AgentCore Runtime QuickStart Guide for those requirements.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#using-agentcore-browser-via-aws-strands","title":"Using AgentCore Browser via AWS Strands","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-1-install-dependencies","title":"Step 1: Install Dependencies","text":"<p>Create a project folder and install the required packages:</p> <pre><code>mkdir agentcore-browser-quickstart\ncd agentcore-browser-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>On Windows, use: <code>.venv\\Scripts\\activate</code></p> <p>Install the required packages:</p> <pre><code>pip install bedrock-agentcore strands-agents strands-agents-tools playwright nest-asyncio\n</code></pre> <p>These packages provide:</p> <ul> <li><code>bedrock-agentcore</code>: The SDK for AgentCore tools including Browser</li> <li><code>strands-agents</code>: The Strands agent framework</li> <li><code>strands-agents-tools</code>: The tools that the Strands agent framework offers including Browser tool</li> <li><code>playwright</code>: Python library for browser automation. Strands uses playwright for browser automation</li> <li><code>nest-asyncio</code>: Allows running asyncio event loops within existing event loops</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-2-create-your-agent-with-browser","title":"Step 2: Create Your Agent with Browser","text":"<p>Create a file named <code>browser_agent.py</code> and add the following code:</p> <pre><code>from strands import Agent\nfrom strands_tools.browser import AgentCoreBrowser\n\n# Initialize the Browser tool\nbrowser_tool = AgentCoreBrowser(region=\"us-west-2\")\n\n# Create an agent with the Browser tool\nagent = Agent(tools=[browser_tool.browser])\n\n# Test the agent with a web search prompt\nprompt = \"what are the services offered by Bedrock AgentCore? Use the documentaiton link if needed: https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/what-is-bedrock-agentcore.html\"\nprint(f\"\\\\nPrompt: {prompt}\\\\n\")\n\nresponse = agent(prompt)\nprint(\"\\\\nAgent Response:\")\nprint(response.message[\"content\"][0][\"text\"])\n</code></pre> <p>This code:</p> <ul> <li>Initializes the Browser tool for the <code>us-west-2</code> region</li> <li>Creates an agent that can use the browser to interact with websites</li> <li>Sends a prompt asking the agent to search AgentCore documentation and answer question</li> <li>Prints the agent's response with the response</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-3-run-the-agent","title":"Step 3: Run the Agent","text":"<p>Execute the script:</p> <pre><code>python browser_agent.py\n</code></pre> <p>Expected Output: You should see the agent's response containing details about the first MacBook search result on Amazon, such as the product name, price, and key specifications. The agent navigates the website, performs the search, and extracts the requested information.</p> <p>If you encounter errors, verify:</p> <ul> <li>Your IAM role/user has the correct permissions</li> <li>You have model access enabled in the Amazon Bedrock console</li> <li>Your AWS credentials are properly configured</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-4-view-the-browser-session-live","title":"Step 4: View the Browser Session Live","text":"<p>While your browser script is running, you can view the session in real-time through the AWS Console:</p> <ol> <li>Open the AgentCore Browser Console</li> <li>Navigate to Built-in tools in the left navigation</li> <li>Select the Browser tool (for example, <code>AgentCore Browser Tool</code>, or your custom browser)</li> <li>In the Browser sessions section, find your active session with status Ready</li> <li>In the Live view / recording column, click the provided \"View live session\" URL</li> <li>The live view opens in a new browser window, displaying the real-time browser session</li> </ol> <p>The live view interface provides:</p> <ul> <li>Real-time video stream of the browser session</li> <li>Interactive controls to take over or release control from automation</li> <li>Ability to terminate the session</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#session-recording-and-replay","title":"Session Recording and Replay","text":"<p>Session recording captures all browser interactions and allows you to replay sessions for debugging, analysis, and monitoring. This feature requires a custom browser tool with recording enabled.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#prerequisites-for-session-recording","title":"Prerequisites for Session Recording","text":"<p>To enable session recording, you need:</p> <ol> <li>An Amazon S3 bucket to store recording data</li> <li>An IAM execution role with permissions to write to your S3 bucket</li> <li>A custom browser tool configured with recording enabled</li> </ol>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-1-configure-iam-role-for-recording","title":"Step 1: Configure IAM Role for Recording","text":"<p>Step 1.1: Create the IAM Policy</p> <p>Create an IAM execution role with the following permissions. This role allows AgentCore Browser to write recording data to S3 and log activity to CloudWatch.</p> <ol> <li>Navigate to the IAM Console</li> <li>Go to Policies \u2192 Create Policy</li> <li>Click JSON and paste the below while replacing <code>your-recording-bucket</code> with your S3 bucket name:</li> </ol> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"BrowserPermissions\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock-agentcore:ConnectBrowserAutomationStream\",\n                \"bedrock-agentcore:ListBrowsers\",\n                \"bedrock-agentcore:GetBrowserSession\",\n                \"bedrock-agentcore:ListBrowserSessions\",\n                \"bedrock-agentcore:CreateBrowser\",\n                \"bedrock-agentcore:StartBrowserSession\",\n                \"bedrock-agentcore:StopBrowserSession\",\n                \"bedrock-agentcore:ConnectBrowserLiveViewStream\",\n                \"bedrock-agentcore:UpdateBrowserStream\",\n                \"bedrock-agentcore:DeleteBrowser\",\n                \"bedrock-agentcore:GetBrowser\"\n            ],\n            \"Resource\": \"*\"\n        },\n        {\n            \"Sid\": \"S3Permissions\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:PutObject\",\n                \"s3:GetObject\",\n                \"s3:ListBucket\",\n                \"s3:ListMultipartUploadParts\",\n                \"s3:AbortMultipartUpload\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::your-recording-bucket\",\n                \"arn:aws:s3:::your-recording-bucket/*\"\n            ]\n        },\n        {\n            \"Sid\": \"CloudWatchLogsPermissions\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:CreateLogGroup\",\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\",\n                \"logs:DescribeLogStreams\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre> <p>This policy includes:</p> <ul> <li>Browser Permissions: Allows the role to manage browser sessions and streams</li> <li>S3 Permissions: Allows writing and reading recording data, including multipart uploads for large recordings</li> <li> <p>CloudWatch Logs Permissions: Allows logging browser activity for debugging and monitoring</p> </li> <li> <p>Click Next</p> </li> <li>Name the policy <code>AgentCoreBrowserRecordingPolicy</code></li> <li>Click Create policy</li> </ul> <p>Step 1.2: Create the Role using the IAM Policy with Trust Policy</p> <ol> <li>Navigate to the IAM Console</li> <li>Click Roles \u2192 Create role</li> <li>Click Custom trust policy</li> <li>Paste the following trust policy (replace <code>123456789012</code> with your account ID and adjust region if needed):</li> </ol> <pre><code>{\n    \"Version\":\"2012-10-17\",\n    \"Statement\": [{\n        \"Sid\": \"BedrockAgentCoreBrowser\",\n        \"Effect\": \"Allow\",\n        \"Principal\": {\n            \"Service\": \"bedrock-agentcore.amazonaws.com\"\n        },\n        \"Action\": \"sts:AssumeRole\",\n        \"Condition\": {\n            \"StringEquals\": {\n                \"aws:SourceAccount\": \"123456789012\"\n            },\n            \"ArnLike\": {\n                \"aws:SourceArn\": \"arn:aws:bedrock-agentcore:us-west-2:123456789012:*\"\n            }\n        }\n    }]\n}\n</code></pre> <ol> <li>Click Next</li> <li>Select the policy <code>AgentCoreBrowserRecordingPolicy</code> and click Next</li> <li>Name the role <code>AgentCoreBrowserRecordingRole</code></li> <li>Click Create role</li> <li>Click on the newly created role and copy the ARN (for example, <code>arn:aws:iam::123456789012:role/AgentCoreBrowserRecordingRole</code>)</li> </ol> <p>You'll use this role ARN when creating a browser with recording enabled in the next step. Make sure to replace <code>123456789012</code> with your AWS account ID and adjust the region in <code>aws:SourceArn</code> if using a region other than <code>us-west-2</code>.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-2-create-a-browser-tool-with-recording","title":"Step 2: Create a Browser Tool with Recording","text":"<p>Create a file named <code>create_browser_with_recording.py</code> and add the following code:</p> <pre><code>import boto3\nimport uuid\n\nregion = \"us-west-2\"\nbucket = \"your-recording-bucket\" # Replace with your S3 bucket name\n\n# Initialize the Bedrock AgentCore CONTROL plane client\nclient = boto3.client(\n    \"bedrock-agentcore-control\",\n    region_name=region\n    )\n\n# Create a custom browser with recording enabled\nresponse = client.create_browser(\n    name=\"MyRecordingBrowser\",\n    description=\"Browser with session recording enabled\",\n    networkConfiguration={\n        \"networkMode\": \"PUBLIC\"\n    },\n    executionRoleArn=\"arn:aws:iam::123456789012:role/AgentCoreBrowserRecordingRole\",\n    clientToken=str(uuid.uuid4()),\n    recording={\n        \"enabled\": True,\n        \"s3Location\": {\n            \"bucket\": bucket,\n            \"prefix\": \"browser-recordings\"\n        }\n    }\n)\nbrowser_identifier = response.get(\"browserId\") or response.get(\"browserIdentifier\")\nprint(f\"Created browser with recording: {browser_identifier}\")\nprint(f\"Recordings will be stored at: s3://{bucket}/browser-recordings/\")\n</code></pre> <p>Replace the following values:</p> <ul> <li><code>123456789012</code>: Your AWS account ID</li> <li><code>AgentCoreBrowserRecordingRole</code>: Name of your IAM execution role</li> <li><code>your-recording-bucket</code>: Name of your S3 bucket for recordings. If you need to create a new bucket, follow this documentation</li> <li>region: Your region if needed</li> </ul> <p>This code:</p> <ul> <li>Creates a custom browser tool with recording enabled</li> <li>Configures the S3 location for storing recording data</li> <li>Associates an execution role that has permissions to write to S3</li> <li>Returns a browser identifier for use in subsequent sessions</li> </ul> <p>Run the script:</p> <pre><code>python create_browser_with_recording.py\n</code></pre> <p>Expected Output: You should see the browser identifier and the S3 location where recordings will be stored.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-3-use-the-recording-enabled-browser","title":"Step 3: Use the Recording-Enabled Browser","text":"<p>Create a file named <code>browser_with_recording.py</code>, add the following code, and replace <code>your-browser-identifier</code> with the identifier from Step 2. This is an AWS Strands based example but you can do the same with Playwright, or any other library.</p> <pre><code>import time\nfrom strands import Agent\nfrom strands_tools.browser import AgentCoreBrowser\n\n# Reuse the existing browser created with recording; ensure identifier is used\nbrowser_identifier = \"your-browser-identifier\"\nregion = \"us-west-2\"\nbrowser_tool = AgentCoreBrowser(region=region, identifier=browser_identifier)\n\ntry:\n    browser_tool.identifier = browser_identifier\nexcept Exception:\n    pass\nagent = Agent(tools=[browser_tool.browser])\nprompt = (\n    \"1) Open https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/what-is-bedrock-agentcore.html; \"\n    \"in the left navigation open 'Use Amazon Bedrock AgentCore built-in tools to interact with your applications', then 'AgentCore Browser: interact with web applications'; scroll down and up briefly. \"\n    \"2) Go to https://pypi.org, search 'bedrock-agentcore', open the project page, then click 'Release history'. \"\n    \"3) Go to https://github.com/awslabs/amazon-bedrock-agentcore-samples/tree/main, open 01-tutorials -&gt; 05-AgentCore-tools -&gt; 02-Agent-Core-browser-tool -&gt; 01-browser-with-NovaAct, \"\n    \"then open 'live_view_with_nova_act.py' (or 'basic_browser_with_nova_act.py') and scroll. Keep all actions in the active tab; be resilient to layout changes. Summarize visited pages.\"\n)\nprint(f\"\\nPrompt: {prompt}\\n\")\nresponse = agent(prompt)\nprint(\"\\nAgent Response:\")\nprint(response.message[\"content\"][0][\"text\"])\n</code></pre> <p>This code:</p> <ul> <li>Starts a browser session with your recording-enabled browser</li> <li>Performs several browser actions (navigate, fill form, click)</li> <li>All interactions are automatically recorded</li> <li>Stops the session, which triggers the final upload of recording data to S3</li> </ul> <p>Run the script:</p> <pre><code>python browser_with_recording.py\n</code></pre> <p>Expected Output: You should see confirmation messages for each action, and a final message indicating the recording has been saved to S3.</p> <p>Note: Session recording captures DOM mutations and reconstructs them during playback. The browser may make cross-origin HTTP requests to fetch external assets during replay.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-4-replay-and-inspect-recorded-sessions-in-the-aws-console","title":"Step 4: Replay and Inspect Recorded Sessions in the AWS Console","text":"<p>Once a browser session completes, the recording data is uploaded to your S3 bucket in chunks. Access recordings through the AWS Console:</p> <p>To access session replay in the console:</p> <ol> <li>Navigate to the AgentCore Browser Console and click Browser use tools</li> <li>Select your custom browser tool from the list (for example, <code>MyRecordingBrowser</code>)</li> <li>In the Browser sessions section, find a completed session with status Terminated (If there is no browser session with terminated status, manually terminate the session by clicking on the Terminate button)</li> <li>Click on the View Recording of the session ID that you are interested in to open the session details</li> <li>The session replay page displays with the title showing your browser name and session ID</li> </ol> <p>Session Analysis Features:</p> <p>The console provides multiple tabs for comprehensive session analysis:</p> <ul> <li>Video Player: Interactive playback with timeline scrubber for navigation</li> <li>Pages Navigation: Panel showing all visited pages with time ranges</li> <li>User Actions: All user interactions with timestamps, methods, and details</li> <li>Page DOM: DOM structure and HTML content for each page</li> <li>Console Logs: Browser console output, errors, and log messages</li> <li>CDP Events: Chrome DevTools Protocol events with parameters and results</li> <li>Network Events: HTTP requests, responses, status codes, and timing</li> </ul> <p>Navigate Recordings:</p> <ul> <li>Click on pages in the Pages panel to jump to specific moments</li> <li>Click on user actions to see where they occurred in the timeline</li> <li>Use the video timeline scrubber for precise navigation</li> <li>Choose View recording links in action tables to jump to specific interactions</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-5-access-recordings-programmatically","title":"Step 5: Access Recordings Programmatically","text":"<p>You can also access recording data directly from S3:</p> <pre><code>import boto3\n\ns3_client = boto3.client('s3', region_name='us-west-2')\n\n# List recordings in your bucket\nbucket_name = \"your-recording-bucket\"\nprefix = \"browser-recordings/\"\n\nresponse = s3_client.list_objects_v2(\n    Bucket=bucket_name,\n    Prefix=prefix\n)\n\nprint(f\"Recordings in s3://{bucket_name}/{prefix}:\\\\n\")\nfor obj in response.get('Contents', []):\n    print(f\"  {obj['Key']}\")\n    print(f\"    Size: {obj['Size']} bytes\")\n    print(f\"    Last Modified: {obj['LastModified']}\")\n    print()\n</code></pre> <p>Recording data is stored in your S3 bucket with the following structure:</p> <pre><code>s3://your-recording-bucket/browser-recordings/\n  \u2514\u2500\u2500 session-id/\n      \u251c\u2500\u2500 batch_1.ndjson.gz\n      \u251c\u2500\u2500 batch_2.ndjson.gz\n      \u2514\u2500\u2500 batch_3.ndjson.gz\n</code></pre> <p>Each session creates a folder with the session ID, and recording data is uploaded in chunks as the session progresses.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#using-agentcore-browser-with-other-browse-libraries-and-models","title":"Using AgentCore Browser with Other Browse Libraries and Models","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#agentcore-browser-with-amazon-nova-act","title":"AgentCore Browser with Amazon Nova Act","text":"<p>Amazon Nova Act is a new AI model trained to perform actions within a web browser, currently in research preview. In this section, you will learn how to use Nova Act SDK to send natural language instructions to AgentCore Browser and perform actions. Please follow the Prerequisites if you've not already done so to get setup. Additionally, there are some more dependencies to install.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-1-install-dependencies_1","title":"Step 1: Install Dependencies","text":"<p>Create a project folder (if you have not already):</p> <pre><code>mkdir agentcore-browser-quickstart\ncd agentcore-browser-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>On Windows, use: <code>.venv\\Scripts\\activate</code></p> <p>Install the required packages:</p> <pre><code>pip install bedrock-agentcore nova-act rich boto3\n</code></pre> <p>These packages provide:</p> <ul> <li><code>bedrock-agentcore</code>: The SDK for AgentCore tools including Browser</li> <li><code>nova-act</code>: The SDK for Nova Act which includes the model and orchestrator for browser automation</li> <li><code>rich</code>: Library for rich text and beautiful formatting in the terminal</li> <li><code>boto3</code>: AWS SDK for Python (Boto3) to create, configure, and manage AWS services</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-2-get-nova-act-api-key","title":"Step 2: Get Nova Act API Key","text":"<p>Navigate to Nova Act page and generate an API key using your amazon.com credentials. (Note this currently works only for US based amazon.com accounts)</p> <p>Create a file named <code>nova_act_browser_agent.py</code> and add the following code:</p> <pre><code>from bedrock_agentcore.tools.browser_client import browser_session\nfrom nova_act import NovaAct\nfrom rich.console import Console\nimport argparse\nimport json\nimport boto3\n\nconsole = Console()\n\nfrom boto3.session import Session\n\nboto_session = Session()\nregion = boto_session.region_name\nprint(\"using region\", region)\n\ndef browser_with_nova_act(prompt, starting_page, nova_act_key, region=\"us-west-2\"):\n    result = None\n    with browser_session(region) as client:\n        ws_url, headers = client.generate_ws_headers()\n        try:\n            with NovaAct(\n                cdp_endpoint_url=ws_url,\n                cdp_headers=headers,\n                nova_act_api_key=nova_act_key,\n                starting_page=starting_page,\n            ) as nova_act:\n                result = nova_act.act(prompt)\n        except Exception as e:\n            console.print(f\"NovaAct error: {e}\")\n        finally:\n            return result\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--prompt\", required=True, help=\"Browser Search instruction\")\n    parser.add_argument(\"--starting-page\", required=True, help=\"Starting URL\")\n    parser.add_argument(\"--nova-act-key\", required=True, help=\"Nova Act API key\")\n    parser.add_argument(\"--region\", default=\"us-west-2\", help=\"AWS region\")\n    args = parser.parse_args()\n\n    result = browser_with_nova_act(\n        args.prompt, args.starting_page, args.nova_act_key, args.region\n    )\n    console.print(f\"\\n[cyan] Response[/cyan] {result.response}\")\n    console.print(f\"\\n[bold green]Nova Act Result:[/bold green] {result}\")\n</code></pre> <p>This code:</p> <ul> <li>Initializes the Browser tool for the <code>us-west-2</code> region</li> <li>Creates a Nova Act agent that can use the browser to interact with websites</li> <li>Accepts a prompt, starting page and executes the actions on the browser</li> <li>Prints the agent's response with the response</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-3-run-the-agent_1","title":"Step 3: Run the Agent","text":"<p>Execute the script (Replace with your Nova Act API key in the command):</p> <pre><code>python nova_act_browser_agent.py --prompt \"What are the common usecases of Bedrock AgentCore?\" --starting-page \"https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/what-is-bedrock-agentcore.html\" --nova-act-key \"your-nova-act-API-key\"\n</code></pre> <p>Expected Output: You should see the agent's response containing details of the common usecases of Amazon Bedrock AgentCore. The agent navigates the website, performs the search, and extracts the requested information.</p> <p>If you encounter errors, verify:</p> <ul> <li>Your IAM role/user has the correct permissions</li> <li>Your Nova Act API key is correct</li> <li>Your AWS credentials are properly configured</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-4-view-the-browser-session-live_1","title":"Step 4: View the Browser Session Live","text":"<p>While your browser script is running, you can view the session in real-time through the AWS Console:</p> <ol> <li>Open the AgentCore Browser Console</li> <li>Navigate to Built-in tools in the left navigation</li> <li>Select the Browser tool (for example, <code>AgentCore Browser Tool</code>, or your custom browser)</li> <li>In the Browser sessions section, find your active session with status Ready</li> <li>In the Live view / recording column, click the provided \"View live session\" URL</li> <li>The live view opens in a new browser window, displaying the real-time browser session</li> </ol> <p>The live view interface provides:</p> <ul> <li>Real-time video stream of the browser session</li> <li>Interactive controls to take over or release control from automation</li> <li>Ability to terminate the session</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#agentcore-browser-with-playwright","title":"AgentCore Browser with Playwright","text":""},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-1-install-dependencies_2","title":"Step 1: Install Dependencies","text":"<p>You can use Browser directly without an agent framework or an LLM. This is useful when you want programmatic control over browser automation. AgentCore provides two ways to interact with Browser: using Playwright with the SDK client or with libraries like browser-use.</p> <p>SDK Client with Playwright: The <code>bedrock_agentcore</code> SDK provides integration with Playwright for browser automation. Use this approach for rich browser interactions with familiar Playwright APIs.</p> <p>Create a project folder (if you didn't create one before) and install the required packages:</p> <pre><code>mkdir agentcore-browser-quickstart\ncd agentcore-browser-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>On Windows, use: <code>.venv\\Scripts\\activate</code></p> <p>Install the required packages:</p> <pre><code>pip install bedrock-agentcore playwright boto3 nest-asyncio\n</code></pre> <p>These packages provide:</p> <ul> <li><code>bedrock-agentcore</code>: The SDK for AgentCore tools including Browser</li> <li><code>playwright</code>: Python library for browser automation</li> <li><code>boto3</code>: AWS SDK for Python (Boto3) to create, configure, and manage AWS services</li> <li><code>nest-asyncio</code>: Allows running asyncio event loops within existing event loops</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#step-2-control-browser-with-playwright","title":"Step 2: Control Browser with Playwright","text":"<p>Create a file named <code>direct_browser_playwright.py</code> and add the following code:</p> <pre><code>from playwright.async_api import async_playwright, Playwright, BrowserType\nfrom bedrock_agentcore.tools.browser_client import browser_session\nimport asyncio\n\nasync def run(playwright: Playwright):\n    # Create and maintain a browser session\n    with browser_session('us-west-2') as client:\n        # Get WebSocket URL and authentication headers\n        ws_url, headers = client.generate_ws_headers()\n\n        # Connect to the remote browser\n        chromium: BrowserType = playwright.chromium\n        browser = await chromium.connect_over_cdp(\n            ws_url,\n            headers=headers\n        )\n\n        # Get the browser context and page\n        context = browser.contexts[0]\n        page = context.pages[0]\n\n        try:\n            # Navigate to a website\n            await page.goto(\"https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/what-is-bedrock-agentcore.html\")\n\n            # Print the page title\n            title = await page.title()\n            print(f\"Page title: {title}\")\n\n            # Keep the session alive for 2 minutes to allow viewing\n            print(\"\\\\nBrowser session is active. Check the AWS Console for live view.\")\n            await asyncio.sleep(120)\n\n        finally:\n            # Clean up resources\n            await page.close()\n            await browser.close()\n\nasync def main():\n    async with async_playwright() as playwright:\n        await run(playwright)\n\n# Run the async function\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This code:</p> <ul> <li>Creates a managed browser session using AgentCore Browser</li> <li>Connects to the remote Chrome browser using Playwright's Chrome DevTools Protocol (CDP)</li> <li>Navigates to Agentcore documentation and prints the page title</li> <li>Keeps the session alive for 2 minutes, allowing you to view it in the AWS Console</li> <li>Properly closes the browser and cleans up resources</li> </ul> <p>Run the script:</p> <pre><code>python direct_browser_playwright.py\n</code></pre> <p>Expected Output: You should see the page title printed (for example, <code>Page title: What is Amazon Bedrock AgentCore? - Amazon Bedrock AgentCore</code>). The script keeps the browser session active for 2 minutes before closing.</p>"},{"location":"user-guide/builtin-tools/quickstart-browser.html#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"Permission denied errors  **Symptom**: Errors mentioning access denied or insufficient permissions.  **Solution**:  * Verify your IAM user or role has the required Browser permissions * Check your AWS credentials: `aws sts get-caller-identity` * For recording: Verify the execution role has S3 write permissions * For recording: Confirm the trust policy allows `bedrock-agentcore.amazonaws.com` to assume the role  Model access denied  **Symptom**: Errors about model access or authorization when running agents.  **Solution**:  * Navigate to the Amazon Bedrock console * Go to **Model access** in the left navigation * Enable **Anthropic Claude Sonnet 4** * Verify you're in the correct region (match the region in your code)  Browser session timeout  **Symptom**: Browser sessions end unexpectedly or timeout errors occur.  **Solution**:  * Check the `sessionTimeoutSeconds` parameter when starting sessions * Default timeout is 900 seconds (15 minutes) * Increase timeout for longer sessions: `sessionTimeoutSeconds=1800` * Sessions automatically stop after the timeout period  Recording not appearing in S3  **Symptom**: No recording files in your S3 bucket after session completes.  **Solution**:  * Verify the execution role has correct S3 permissions * Confirm the S3 bucket name and prefix are correct * Check the execution role trust policy includes bedrock-agentcore service * Review CloudWatch Logs for S3 upload errors * Ensure the session ran for at least a few seconds (very short sessions may not generate recordings)  Playwright connection errors  **Symptom**: Cannot connect to browser with Playwright or WebSocket errors.  **Solution**:  * Verify you installed playwright: `pip install playwright` * Confirm the browser session started successfully before connecting * Check that the session is still active (not timed out) * Verify your network allows WebSocket connections"},{"location":"user-guide/builtin-tools/quickstart-browser.html#find-your-resources","title":"Find Your Resources","text":"<p>After using AgentCore Browser, view your resources in the AWS Console:</p> Resource Location Live View Browser Console \u2192 Tool Name \u2192 Click View live session Session Recordings Browser Console \u2192 Tool Name \u2192 Click View recording Browser Logs CloudWatch \u2192 Log groups \u2192 <code>/aws/bedrock-agentcore/browser/</code> Recording Files S3 \u2192 Your bucket \u2192 <code>browser-recordings/</code> prefix Custom Browsers AgentCore Console \u2192 Built-in tools \u2192 Your custom browser IAM Roles IAM \u2192 Roles \u2192 Search for your execution role"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html","title":"AgentCore Code Interpreter Quickstart","text":"<p>AgentCore Code Interpreter enables your agents to execute Python code in a secure, managed environment. The agent can perform calculations, analyze data, generate visualizations, and validate answers through code execution.</p>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#prerequisites","title":"Prerequisites","text":"<p>Before you start, ensure you have:</p> <ul> <li>AWS Account with credentials configured. See instructions below.</li> <li>Python 3.10+ installed</li> <li>Boto3 installed</li> <li>IAM Execution Role with the required permissions (see below)</li> <li>Model access: Anthropic Claude Sonnet 4.0 enabled in the Amazon Bedrock console. For information about using a different model with the Strands Agents see the Model Providers section in the Strands Agents SDK documentation.</li> <li>AWS Region where AgentCore is available</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#credentials-configuration-if-not-already-configured","title":"Credentials configuration (if not already configured)","text":"<p>Verify your AWS Credentials</p> <p>Confirm your AWS credentials are configured:</p> <pre><code>aws sts get-caller-identity\n</code></pre> <p>If this command fails, configure your credentials. See Configuration and credential file settings in the AWS CLI documentation.</p> <p>Attach Required Permissions</p> <p>Your IAM user or role needs permissions to use Code Interpreter. Attach this policy to your IAM identity:</p> <p>Note: Replace <code>&lt;region&gt;</code> with your chosen region (e.g., <code>us-west-2</code>) and <code>&lt;account_id&gt;</code> with your AWS account ID in the policy below:</p> <pre><code>{\n    \"Version\":\"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"BedrockAgentCoreCodeInterpreterFullAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock-agentcore:CreateCodeInterpreter\",\n                \"bedrock-agentcore:StartCodeInterpreterSession\",\n                \"bedrock-agentcore:InvokeCodeInterpreter\",\n                \"bedrock-agentcore:StopCodeInterpreterSession\",\n                \"bedrock-agentcore:DeleteCodeInterpreter\",\n                \"bedrock-agentcore:ListCodeInterpreters\",\n                \"bedrock-agentcore:GetCodeInterpreter\",\n                \"bedrock-agentcore:GetCodeInterpreterSession\",\n                \"bedrock-agentcore:ListCodeInterpreterSessions\"\n            ],\n            \"Resource\": \"arn:aws:bedrock-agentcore:&lt;region&gt;:&lt;account_id&gt;:code-interpreter/*\"\n        }\n    ]\n}\n</code></pre> <p>To attach this policy:</p> <ol> <li>Navigate to the IAM Console</li> <li>Find your user or role (the one returned by <code>aws sts get-caller-identity</code>)</li> <li>Click \"Add permissions\" \u2192 \"Create inline policy\"</li> <li>Switch to JSON view and paste the policy above</li> <li>Name it <code>AgentCoreCodeInterpreterAccess</code> and save</li> </ol> <p>Note: If you're deploying agents to AgentCore Runtime (not covered in this guide), you'll also need to create an IAM execution role with a service trust policy. See the AgentCore Runtime QuickStart Guide for those requirements.</p>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#using-code-interpreter-via-aws-strands","title":"Using Code Interpreter via AWS Strands","text":""},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#step-1-install-dependencies","title":"Step 1: Install Dependencies","text":"<p>Create a project folder and install the required packages:</p> <pre><code>mkdir agentcore-tools-quickstart\ncd agentcore-tools-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>On Windows, use: <code>.venv\\Scripts\\activate</code></p> <p>Install the required packages:</p> <pre><code>pip install bedrock-agentcore strands-agents strands-agents-tools\n</code></pre> <p>These packages provide:</p> <ul> <li><code>bedrock-agentcore</code>: The SDK for AgentCore tools including Code Interpreter</li> <li><code>strands-agents</code>: The Strands agent framework</li> <li><code>strands-agents-tools</code>: The tools that the Strands agent framework offers</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#step-2-create-your-agent-with-code-interpreter","title":"Step 2: Create Your Agent with Code Interpreter","text":"<p>Create a file named <code>code_interpreter_agent.py</code> and add the following code:</p> <pre><code>from strands import Agent\nfrom strands_tools.code_interpreter import AgentCoreCodeInterpreter\n\n# Initialize the Code Interpreter tool\ncode_interpreter_tool = AgentCoreCodeInterpreter(region=\"us-west-2\")\n\n# Define the agent's system prompt\nSYSTEM_PROMPT = \"\"\"You are an AI assistant that validates answers through code execution.\nWhen asked about code, algorithms, or calculations, write Python code to verify your answers.\"\"\"\n\n# Create an agent with the Code Interpreter tool\nagent = Agent(\n    tools=[code_interpreter_tool.code_interpreter],\n    system_prompt=SYSTEM_PROMPT\n)\n\n# Test the agent with a sample prompt\nprompt = \"Calculate the first 10 Fibonacci numbers.\"\nprint(f\"\\\\nPrompt: {prompt}\\\\n\")\n\nresponse = agent(prompt)\nprint(response.message[\"content\"][0][\"text\"])\n</code></pre> <p>This code:</p> <ul> <li>Initializes the Code Interpreter tool for the <code>us-west-2</code> region</li> <li>Creates an agent configured to use code execution for validation</li> <li>Sends a prompt asking the agent to calculate Fibonacci numbers</li> <li>Prints the agent's response</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#step-3-run-the-agent","title":"Step 3: Run the Agent","text":"<p>Execute the script:</p> <pre><code>python code_interpreter_agent.py\n</code></pre> <p>Expected Output: You should see the agent's response containing the first 10 Fibonacci numbers. The agent will write Python code to calculate the sequence and return both the code and the results.</p> <p>If you encounter errors, verify:</p> <ul> <li>Your IAM role has the correct permissions and trust policy</li> <li>You have model access enabled in the Amazon Bedrock console</li> <li>Your AWS credentials are properly configured</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#using-code-interpreter-directly","title":"Using Code Interpreter Directly","text":""},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#step-1-choose-your-approach-install-dependencies","title":"Step 1: Choose Your Approach &amp; Install Dependencies","text":"<p>You can use Code Interpreter directly without an agent framework. This is useful when you want to execute specific code snippets programmatically. AgentCore provides two ways to interact with Code Interpreter: using the high-level SDK client or using boto3 directly.</p> <ul> <li>SDK Client: The <code>bedrock_agentcore</code> SDK provides a simplified interface that handles session management details. Use this approach for most applications.</li> <li>Boto3 Client: The AWS SDK gives you direct access to the Code Interpreter API operations. Use this approach when you need fine-grained control over session configuration or want to integrate with existing boto3-based applications.</li> </ul> <p>Create a project folder (if you didn't create one before) and install the required packages:</p> <pre><code>mkdir agentcore-tools-quickstart\ncd agentcore-tools-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>On Windows, use: <code>.venv\\Scripts\\activate</code></p> <p>Install the required packages:</p> <pre><code>pip install bedrock-agentcore boto3\n</code></pre> <p>These packages provide:</p> <ul> <li><code>bedrock-agentcore</code>: The SDK for AgentCore tools including Code Interpreter</li> <li><code>boto3</code>: AWS SDK for Python (Boto3) to create, configure, and manage AWS services</li> </ul>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#step-2-execute-code-with-the-sdk-client","title":"Step 2: Execute Code with the SDK Client","text":"<p>Create a file named <code>direct_code_execution_sdk.py</code> and add the following code:</p> <pre><code>from bedrock_agentcore.tools.code_interpreter_client import CodeInterpreter\nimport json\n\n# Initialize the Code Interpreter client for us-west-2\ncode_client = CodeInterpreter('us-west-2')\n\n# Start a Code Interpreter session\ncode_client.start()\n\ntry:\n    # Execute Python code\n    response = code_client.invoke(\"executeCode\", {\n        \"language\": \"python\",\n        \"code\": 'print(\"Hello World!!!\")'\n    })\n\n    # Process and print the response\n    for event in response[\"stream\"]:\n        print(json.dumps(event[\"result\"], indent=2))\n\nfinally:\n    # Always clean up the session\n    code_client.stop()\n</code></pre> <p>This code:</p> <ul> <li>Creates a Code Interpreter client for your region</li> <li>Starts a session (required before executing code)</li> <li>Executes Python code and streams the results with full event details</li> <li>Stops the session to clean up resources</li> </ul> <p>Run the script:</p> <pre><code>python direct_code_execution_sdk.py\n</code></pre> <p>Expected Output: You should see a JSON response containing the execution result with <code>Hello World!!!</code> in the output content.</p>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#step-3-execute-code-with-boto3","title":"Step 3: Execute Code with Boto3","text":"<p>Create a file named <code>direct_code_execution_boto3.py</code> and add the following code:</p> <pre><code>import boto3\nimport json\n\n# Code to execute\ncode_to_execute = \"\"\"\nprint(\"Hello World!!!\")\n\"\"\"\n\n# Initialize the bedrock-agentcore client\nclient = boto3.client(\n    \"bedrock-agentcore\",\n    region_name=\"us-west-2\"\n)\n\n# Start a Code Interpreter session\nsession_response = client.start_code_interpreter_session(\n    codeInterpreterIdentifier=\"aws.codeinterpreter.v1\",\n    name=\"my-code-session\",\n    sessionTimeoutSeconds=900\n)\nsession_id = session_response[\"sessionId\"]\n\nprint(f\"Started session: {session_id}\\\\n\")\n\ntry:\n    # Execute code in the session\n    execute_response = client.invoke_code_interpreter(\n        codeInterpreterIdentifier=\"aws.codeinterpreter.v1\",\n        sessionId=session_id,\n        name=\"executeCode\",\n        arguments={\n            \"language\": \"python\",\n            \"code\": code_to_execute\n        }\n    )\n\n    # Extract and print the text output from the stream\n    for event in execute_response['stream']:\n        if 'result' in event:\n            result = event['result']\n            if 'content' in result:\n                for content_item in result['content']:\n                    if content_item['type'] == 'text':\n                        print(content_item['text'])\n\nfinally:\n    # Stop the session when done\n    client.stop_code_interpreter_session(\n        codeInterpreterIdentifier=\"aws.codeinterpreter.v1\",\n        sessionId=session_id\n    )\n    print(f\"\\\\nStopped session: {session_id}\")\n</code></pre> <p>This code:</p> <ul> <li>Creates a boto3 client for the bedrock-agentcore service</li> <li>Starts a Code Interpreter session with a 900-second timeout</li> <li>Executes Python code using the session ID</li> <li>Parses the streaming response to extract text output</li> <li>Properly stops the session to release resources</li> </ul> <p>The boto3 approach requires explicit session management. You must call <code>start_code_interpreter_session</code> before executing code and <code>stop_code_interpreter_session</code> when finished.</p> <p>Run the script:</p> <pre><code>python direct_code_execution_boto3.py\n</code></pre> <p>Expected Output: You should see <code>Hello World!!!</code> printed as the result of the code execution, along with the session ID information.</p>"},{"location":"user-guide/builtin-tools/quickstart-code-interpreter.html#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"Permission denied errors  **Symptom**: Errors mentioning access denied or insufficient permissions when starting sessions or executing code.  **Solution**:  * Verify your IAM user or role has the required Code Interpreter permissions * Check your AWS credentials: `aws sts get-caller-identity` * Ensure the policy includes all necessary actions: `StartCodeInterpreterSession`, `InvokeCodeInterpreter`, `StopCodeInterpreterSession` * Verify the Resource ARN matches your region and account ID  Model access denied  **Symptom**: Errors about model access or authorization when running agents with Code Interpreter.  **Solution**:  * Navigate to the Amazon Bedrock console * Go to **Model access** in the left navigation * Enable **Anthropic Claude Sonnet 4** * Verify you're in the correct region (match the region in your code)  Code execution timeout  **Symptom**: Long-running code execution fails or sessions terminate unexpectedly.  **Solution**:  * Check the `sessionTimeoutSeconds` parameter when starting sessions * Default timeout is 900 seconds (15 minutes) * For long-running operations, increase timeout: `sessionTimeoutSeconds=3600` (1 hour) * Maximum timeout is 28,800 seconds (8 hours) * Sessions automatically terminate after the timeout period  Package/library not available  **Symptom**: ImportError when trying to use specific Python packages or libraries.  **Solution**:  * AgentCore Code Interpreter comes with pre-installed common libraries (numpy, pandas, matplotlib, etc.) * Check if the package you need is in the pre-built runtime * For custom packages, you may need to create a custom Code Interpreter with your own environment * Consider using built-in alternatives if your required package is not available * Review the Code Interpreter documentation for the list of available libraries"},{"location":"user-guide/gateway/quickstart.html","title":"QuickStart: A Fully Managed MCP Server in 5 Minutes! \ud83d\ude80","text":"<p>Amazon Bedrock AgentCore Gateway provides an easy and secure way for developers to build, deploy, discover, and connect to tools at scale. AI agents need tools to perform real-world tasks\u2014from querying databases to sending messages to analyzing documents. With Gateway, developers can convert APIs, Lambda functions, and existing services into Model Context Protocol (MCP)-compatible tools and make them available to agents through Gateway endpoints with just a few lines of code. Gateway supports OpenAPI, Smithy, and Lambda as input types, and is the only solution that provides both comprehensive ingress authentication and egress authentication in a fully-managed service. Gateway eliminates weeks of custom code development, infrastructure provisioning, and security implementation so developers can focus on building innovative agent applications.</p> <p>In this quick start guide you will learn how to set up a Gateway and integrate it into your agents using the AgentCore Starter Toolkit. You can find more comprehensive guides and examples here.</p> <p>Note: The AgentCore Starter Toolkit is intended to help developers get started quickly. The Boto3 Python library provides the most comprehensive set of operations for Gateways and Targets. You can find the Boto3 documentation here. For complete documentation see the developer guide</p>"},{"location":"user-guide/gateway/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>AWS Account with credentials configured (<code>aws configure</code>)</li> <li>Python 3.10+ installed</li> <li>IAM Permissions for creating roles, Lambda functions, and using Bedrock AgentCore</li> <li>Model Access - Enable Anthropic\u2019s Claude Sonnet 3.7 in the Bedrock console (or another model for the demo agent)</li> </ul>"},{"location":"user-guide/gateway/quickstart.html#step-1-setup-and-install","title":"Step 1: Setup and Install","text":"<pre><code>mkdir agentcore-gateway-quickstart\ncd agentcore-gateway-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre> <p>Install Dependencies</p> <pre><code>pip install boto3\npip install bedrock-agentcore-starter-toolkit\npip install strands-agents\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#step-2-create-gateway-setup-script","title":"Step 2: Create Gateway Setup Script","text":"<p>Create a new file called <code>setup_gateway.py</code> with the following complete code.</p> <pre><code>\"\"\"\nSetup script to create Gateway with Lambda target and save configuration\nRun this first: python setup_gateway.py\n\"\"\"\n\nfrom bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\nimport json\nimport logging\nimport time\n\ndef setup_gateway():\n    # Configuration\n    region = \"us-east-1\"  # Change to your preferred region\n\n    print(\"\ud83d\ude80 Setting up AgentCore Gateway...\")\n    print(f\"Region: {region}\\n\")\n\n    # Initialize client\n    client = GatewayClient(region_name=region)\n    client.logger.setLevel(logging.INFO)\n\n    # Step 2.1: Create OAuth authorizer\n    print(\"Step 2.1: Creating OAuth authorization server...\")\n    cognito_response = client.create_oauth_authorizer_with_cognito(\"TestGateway\")\n    print(\"\u2713 Authorization server created\\n\")\n\n    # Step 2.2: Create Gateway\n    print(\"Step 2.2: Creating Gateway...\")\n    gateway = client.create_mcp_gateway(\n        # the name of the Gateway - if you don't set one, one will be generated.\n        name=None,\n        # the role arn that the Gateway will use - if you don't set one, one will be created.\n        # NOTE: if you are using your own role make sure it has a trust policy that trusts bedrock-agentcore.amazonaws.com\n        role_arn=None,\n        # the OAuth authorization server details. If you are providing your own authorization server,\n        # then pass an input of the following form: {\"customJWTAuthorizer\": {\"allowedClients\": [\"&lt;INSERT CLIENT ID&gt;\"], \"discoveryUrl\": \"&lt;INSERT DISCOVERY URL\"&gt;}}\n        authorizer_config=cognito_response[\"authorizer_config\"],\n        # enable semantic search\n        enable_semantic_search=True,\n    )\n    print(f\"\u2713 Gateway created: {gateway['gatewayUrl']}\\n\")\n\n    # If role_arn was not provided, fix IAM permissions\n    # NOTE: This is handled internally by the toolkit when no role is provided\n    client.fix_iam_permissions(gateway)\n    print(\"\u23f3 Waiting 30s for IAM propagation...\")\n    time.sleep(30)\n    print(\"\u2713 IAM permissions configured\\n\")\n\n    # Step 2.3: Add Lambda target\n    print(\"Step 2.3: Adding Lambda target...\")\n    lambda_target = client.create_mcp_gateway_target(\n        # the gateway created in the previous step\n        gateway=gateway,\n        # the name of the Target - if you don't set one, one will be generated.\n        name=None,\n        # the type of the Target\n        target_type=\"lambda\",\n        # the target details - set this to define your own lambda if you pre-created one.\n        # Otherwise leave this None and one will be created for you.\n        target_payload=None,\n        # you will see later in the tutorial how to use this to connect to APIs using API keys and OAuth credentials.\n        credentials=None,\n    )\n    print(\"\u2713 Lambda target added\\n\")\n\n    # Step 2.4: Save configuration for agent\n    config = {\n        \"gateway_url\": gateway[\"gatewayUrl\"],\n        \"gateway_id\": gateway[\"gatewayId\"],\n        \"region\": region,\n        \"client_info\": cognito_response[\"client_info\"]\n    }\n\n    with open(\"gateway_config.json\", \"w\") as f:\n        json.dump(config, f, indent=2)\n\n    print(\"=\" * 60)\n    print(\"\u2705 Gateway setup complete!\")\n    print(f\"Gateway URL: {gateway['gatewayUrl']}\")\n    print(f\"Gateway ID: {gateway['gatewayId']}\")\n    print(\"\\nConfiguration saved to: gateway_config.json\")\n    print(\"\\nNext step: Run 'python run_agent.py' to test your Gateway\")\n    print(\"=\" * 60)\n\n    return config\n\nif __name__ == \"__main__\":\n    setup_gateway()\n</code></pre> <p>See below for step-by-step understanding of each component.</p> \ud83d\udcda Understanding the Setup Script - Step by Step Explanation   #### Import Required Libraries  First, import the necessary libraries for gateway creation and configuration.  <pre><code>from bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\nimport json\nimport logging\nimport time\n</code></pre>  #### Create the Setup Function  Initialize the setup function with your AWS region configuration.  <pre><code>def setup_gateway():\n    # Configuration\n    region = \"us-east-1\"  # Change to your preferred region\n\n    print(\"\ud83d\ude80 Setting up AgentCore Gateway...\")\n    print(f\"Region: {region}\\n\")\n\n    # Initialize client\n    client = GatewayClient(region_name=region)\n    client.logger.setLevel(logging.INFO)\n</code></pre>  ### Step 2.1: Creating an OAuth Authorization Server  \ud83d\udd11 Gateways are secured by OAuth authorization servers which ensure that only allowed users can access your Gateway. Let\u2019s create an OAuth authorization server using Amazon Cognito.  <pre><code>    # Step 2.1: Create OAuth authorizer\n    print(\"Step 2.1: Creating OAuth authorization server...\")\n    cognito_response = client.create_oauth_authorizer_with_cognito(\"TestGateway\")\n    print(\"\u2713 Authorization server created\\n\")\n</code></pre>  **What happens here**: This creates a Cognito user pool with OAuth 2.0 client credentials flow configured. You\u2019ll get a client ID and secret that can be used to obtain access tokens.  ### Step 2.2: Creating a Gateway  \ud83c\udf09 Now, let\u2019s create a Gateway. The Gateway acts as your MCP server endpoint that agents will connect to.  <pre><code>    # Step 2.2: Create Gateway\n    print(\"Step 2.2: Creating Gateway...\")\n    gateway = client.create_mcp_gateway(\n        # the name of the Gateway - if you don't set one, one will be generated.\n        name=None,\n        # the role arn that the Gateway will use - if you don't set one, one will be created.\n        # NOTE: if you are using your own role make sure it has a trust policy that trusts bedrock-agentcore.amazonaws.com\n        role_arn=None,\n        # the OAuth authorization server details. If you are providing your own authorization server,\n        # then pass an input of the following form: {\"customJWTAuthorizer\": {\"allowedClients\": [\"&lt;INSERT CLIENT ID&gt;\"], \"discoveryUrl\": \"&lt;INSERT DISCOVERY URL\"&gt;}}\n        authorizer_config=cognito_response[\"authorizer_config\"],\n        # enable semantic search\n        enable_semantic_search=True,\n    )\n    print(f\"\u2713 Gateway created: {gateway['gatewayUrl']}\\n\")\n\n    # If role_arn was not provided, fix IAM permissions\n    # NOTE: This is handled internally by the toolkit when no role is provided\n    client.fix_iam_permissions(gateway)\n    print(\"\u23f3 Waiting 30s for IAM propagation...\")\n    time.sleep(30)\n    print(\"\u2713 IAM permissions configured\\n\")\n</code></pre>  **What happens here**: Creates a Gateway with MCP protocol support, configures OAuth authorization, and enables semantic search for tool discovery. If you don\u2019t provide a role, one is created and configured automatically.  ### Step 2.3: Adding Lambda Targets  \ud83d\udee0\ufe0f Let\u2019s add a Lambda function target. This code will automatically create a Lambda function with weather and time tools.  <pre><code>    # Step 2.3: Add Lambda target\n    print(\"Step 2.3: Adding Lambda target...\")\n    lambda_target = client.create_mcp_gateway_target(\n        # the gateway created in the previous step\n        gateway=gateway,\n        # the name of the Target - if you don't set one, one will be generated.\n        name=None,\n        # the type of the Target\n        target_type=\"lambda\",\n        # the target details - set this to define your own lambda if you pre-created one.\n        # Otherwise leave this None and one will be created for you.\n        target_payload=None,\n        # you will see later in the tutorial how to use this to connect to APIs using API keys and OAuth credentials.\n        credentials=None,\n    )\n    print(\"\u2713 Lambda target added\\n\")\n</code></pre>  **What happens here**: Creates a test Lambda function with two tools (get_weather and get_time) and registers it as a target in your Gateway.  ### Step 2.4: Save Configuration  Save the gateway configuration to a file for use by the agent.  <pre><code>    # Step 2.4: Save configuration for agent\n    config = {\n        \"gateway_url\": gateway[\"gatewayUrl\"],\n        \"gateway_id\": gateway[\"gatewayId\"],\n        \"region\": region,\n        \"client_info\": cognito_response[\"client_info\"]\n    }\n\n    with open(\"gateway_config.json\", \"w\") as f:\n        json.dump(config, f, indent=2)\n\n    print(\"=\" * 60)\n    print(\"\u2705 Gateway setup complete!\")\n    print(f\"Gateway URL: {gateway['gatewayUrl']}\")\n    print(f\"Gateway ID: {gateway['gatewayId']}\")\n    print(\"\\nConfiguration saved to: gateway_config.json\")\n    print(\"\\nNext step: Run 'python run_agent.py' to test your Gateway\")\n    print(\"=\" * 60)\n\n    return config\n\nif __name__ == \"__main__\":\n    setup_gateway()\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#run-the-setup","title":"Run the Setup","text":"<p>Execute the setup script to create your Gateway and Lambda target.</p> <pre><code>python setup_gateway.py\n</code></pre> <p>What to expect: The script will take about 2-3 minutes to complete. You\u2019ll see progress messages for each step.</p>"},{"location":"user-guide/gateway/quickstart.html#step-3-using-the-gateway-with-an-agent","title":"Step 3: Using the Gateway with an Agent","text":"<p>Create a new file called <code>run_agent.py</code> with the following code:</p> <pre><code>\"\"\"\nAgent script to test the Gateway\nRun this after setup: python run_agent.py\n\"\"\"\n\nfrom strands import Agent\nfrom strands.models import BedrockModel\nfrom strands.tools.mcp.mcp_client import MCPClient\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\nimport json\nimport sys\n\ndef create_streamable_http_transport(mcp_url: str, access_token: str):\n    return streamablehttp_client(mcp_url, headers={\"Authorization\": f\"Bearer {access_token}\"})\n\ndef get_full_tools_list(client):\n    \"\"\"Get all tools with pagination support\"\"\"\n    more_tools = True\n    tools = []\n    pagination_token = None\n    while more_tools:\n        tmp_tools = client.list_tools_sync(pagination_token=pagination_token)\n        tools.extend(tmp_tools)\n        if tmp_tools.pagination_token is None:\n            more_tools = False\n        else:\n            more_tools = True\n            pagination_token = tmp_tools.pagination_token\n    return tools\n\ndef run_agent():\n    # Load configuration\n    try:\n        with open(\"gateway_config.json\", \"r\") as f:\n            config = json.load(f)\n    except FileNotFoundError:\n        print(\"\u274c Error: gateway_config.json not found!\")\n        print(\"Please run 'python setup_gateway.py' first to create the Gateway.\")\n        sys.exit(1)\n\n    gateway_url = config[\"gateway_url\"]\n    client_info = config[\"client_info\"]\n\n    # Get access token for the agent\n    print(\"Getting access token...\")\n    client = GatewayClient(region_name=config[\"region\"])\n    access_token = client.get_access_token_for_cognito(client_info)\n    print(\"\u2713 Access token obtained\\n\")\n\n    # Model configuration - change if needed\n    model_id = \"anthropic.claude-3-7-sonnet-20250219-v1:0\"\n\n    print(\"\ud83e\udd16 Starting AgentCore Gateway Test Agent\")\n    print(f\"Gateway URL: {gateway_url}\")\n    print(f\"Model: {model_id}\")\n    print(\"-\" * 60)\n\n    # Setup Bedrock model\n    bedrockmodel = BedrockModel(\n        inference_profile_id=model_id,\n        streaming=True,\n    )\n\n    # Setup MCP client\n    mcp_client = MCPClient(lambda: create_streamable_http_transport(gateway_url, access_token))\n\n    with mcp_client:\n        # List available tools\n        tools = get_full_tools_list(mcp_client)\n        print(f\"\\n\ud83d\udccb Available tools: {[tool.tool_name for tool in tools]}\")\n        print(\"-\" * 60)\n\n        # Create agent\n        agent = Agent(model=bedrockmodel, tools=tools)\n\n        # Interactive loop\n        print(\"\\n\ud83d\udcac Interactive Agent Ready!\")\n        print(\"Try asking: 'What's the weather in Seattle?'\")\n        print(\"Type 'exit', 'quit', or 'bye' to end.\\n\")\n\n        while True:\n            user_input = input(\"You: \")\n            if user_input.lower() in [\"exit\", \"quit\", \"bye\"]:\n                print(\"\ud83d\udc4b Goodbye!\")\n                break\n\n            print(\"\\n\ud83e\udd14 Thinking...\\n\")\n            response = agent(user_input)\n            print(f\"\\nAgent: {response.message.get('content', response)}\\n\")\n\nif __name__ == \"__main__\":\n    run_agent()\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#run-your-agent","title":"Run Your Agent","text":"<p>Test your Gateway by running the agent and interacting with the tools.</p> <pre><code>python run_agent.py\n</code></pre> <p>That\u2019s it! The agent will start and you can ask questions like:</p> <ul> <li>\u201cWhat\u2019s the weather in Seattle?\u201d</li> <li>\u201cWhat time is it in New York?\u201d</li> </ul>"},{"location":"user-guide/gateway/quickstart.html#what-youve-built","title":"What You\u2019ve Built","text":"<ul> <li>MCP Server (Gateway): A managed endpoint at <code>https://gateway-id.gateway.bedrock-agentcore.region.amazonaws.com/mcp</code></li> <li>Lambda Tools: Mock functions that return test data (weather: \u201c72\u00b0F, Sunny\u201d, time: \u201c2:30 PM\u201d)</li> <li>OAuth Authentication: Secure access using Cognito tokens</li> <li>AI Agent: Claude-powered assistant that can discover and use your tools</li> </ul>"},{"location":"user-guide/gateway/quickstart.html#congratulations-you-successfully-built-an-agent-with-mcp-tools-powered-by-agentcore-gateway","title":"\ud83e\udd73\ud83e\udd73\ud83e\udd73 Congratulations - you successfully built an agent with MCP tools powered by AgentCore Gateway!","text":""},{"location":"user-guide/gateway/quickstart.html#troubleshooting","title":"Troubleshooting","text":"Issue Solution \u201cNo module named \u2018strands\u2019\u201d Run: <code>pip install strands-agents</code> \u201cModel not enabled\u201d Enable Claude Sonnet 3.7 in Bedrock console \u2192 Model access \u201cAccessDeniedException\u201d Check IAM permissions for <code>bedrock-agentcore:*</code> Gateway not responding Wait 30-60 seconds after creation for DNS propagation OAuth token expired Tokens expire after 1 hour, get new one with <code>get_access_token_for_cognito()</code>"},{"location":"user-guide/gateway/quickstart.html#quick-validation","title":"Quick Validation","text":"<pre><code># Check your Gateway is working\ncurl -X POST YOUR_GATEWAY_URL \\\n  -H \"Authorization: Bearer YOUR_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/list\",\"params\":{}}'\n\n# Watch live logs\naws logs tail /aws/bedrock-agentcore/gateways/YOUR_GATEWAY_ID --follow\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#cleanup","title":"Cleanup","text":"<p>Create <code>cleanup_gateway.py</code>:</p> <pre><code>from bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\nimport json\n\nwith open(\"gateway_config.json\", \"r\") as f:\n    config = json.load(f)\n\nclient = GatewayClient(region_name=config[\"region\"])\nclient.cleanup_gateway(config[\"gateway_id\"], config[\"client_info\"])\nprint(\"\u2705 Cleanup complete!\")\n</code></pre> <p>Run: <code>python cleanup_gateway.py</code></p>"},{"location":"user-guide/gateway/quickstart.html#next-steps","title":"Next Steps","text":"<ul> <li>Custom Lambda Tools: Create Lambda functions with your business logic</li> <li>Add Your Own APIs: Extend your Gateway with OpenAPI specifications for real services</li> <li>Production Setup: Configure VPC endpoints, custom domains, and monitoring</li> </ul>"},{"location":"user-guide/gateway/quickstart.html#custom-lambda-tools","title":"Custom Lambda Tools","text":"<p>Create your own Lambda functions with custom business logic and add them as Gateway targets. Lambda targets allow you to implement any custom tool logic in Python, Node.js, or other supported runtimes.</p>  \u27a1\ufe0f Creating Custom Lambda Tools   Create a file `create_custom_lambda.py`:  <pre><code>\"\"\"Create a custom Lambda function and add it as a Gateway target\"\"\"\n\nimport boto3\nimport json\nimport io\nimport zipfile\nimport time\nfrom bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\n\ndef create_custom_lambda(region, gateway_role_arn):\n    lambda_client = boto3.client('lambda', region_name=region)\n    iam = boto3.client('iam')\n\n    # Lambda code\n    lambda_code = '''\nimport json\n\ndef lambda_handler(event, context):\n    tool_name = context.client_context.custom.get('bedrockAgentCoreToolName', 'unknown')\n\n    if 'calculate_sum' in tool_name:\n        a = event.get('a', 0)\n        b = event.get('b', 0)\n        return {\n            'statusCode': 200,\n            'body': json.dumps({'result': a + b})\n        }\n    elif 'multiply' in tool_name:\n        x = event.get('x', 0)\n        y = event.get('y', 0)\n        return {\n            'statusCode': 200,\n            'body': json.dumps({'result': x * y})\n        }\n\n    return {'statusCode': 200, 'body': json.dumps({'error': 'Unknown tool'})}\n'''\n\n    # Create zip\n    zip_buffer = io.BytesIO()\n    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n        zip_file.writestr('lambda_function.py', lambda_code)\n    zip_buffer.seek(0)\n\n    # Create execution role\n    role_name = 'CustomCalculatorLambdaRole'\n    try:\n        role = iam.create_role(\n            RoleName=role_name,\n            AssumeRolePolicyDocument=json.dumps({\n                \"Version\": \"2012-10-17\",\n                \"Statement\": [{\n                    \"Effect\": \"Allow\",\n                    \"Principal\": {\"Service\": \"lambda.amazonaws.com\"},\n                    \"Action\": \"sts:AssumeRole\"\n                }]\n            })\n        )\n        iam.attach_role_policy(\n            RoleName=role_name,\n            PolicyArn='arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'\n        )\n        role_arn = role['Role']['Arn']\n        print(f\"Created Lambda execution role: {role_arn}\")\n        time.sleep(10)\n    except iam.exceptions.EntityAlreadyExistsException:\n        role = iam.get_role(RoleName=role_name)\n        role_arn = role['Role']['Arn']\n\n    # Create Lambda\n    function_name = 'CustomCalculatorFunction'\n    try:\n        response = lambda_client.create_function(\n            FunctionName=function_name,\n            Runtime='python3.9',\n            Role=role_arn,\n            Handler='lambda_function.lambda_handler',\n            Code={'ZipFile': zip_buffer.read()},\n            Description='Custom calculator for AgentCore Gateway'\n        )\n        lambda_arn = response['FunctionArn']\n        print(f\"Created Lambda: {lambda_arn}\")\n\n        lambda_client.add_permission(\n            FunctionName=function_name,\n            StatementId='AllowAgentCoreInvoke',\n            Action='lambda:InvokeFunction',\n            Principal=gateway_role_arn\n        )\n    except lambda_client.exceptions.ResourceConflictException:\n        response = lambda_client.get_function(FunctionName=function_name)\n        lambda_arn = response['Configuration']['FunctionArn']\n        print(f\"Lambda already exists: {lambda_arn}\")\n\n    return lambda_arn\n\n# Main execution\nwith open(\"gateway_config.json\", \"r\") as f:\n    config = json.load(f)\n\nclient = GatewayClient(region_name=config[\"region\"])\ngateway = client.client.get_gateway(gatewayIdentifier=config[\"gateway_id\"])\n\nprint(\"Creating custom Lambda function...\")\nlambda_arn = create_custom_lambda(config[\"region\"], gateway[\"roleArn\"])\n\n# Add as target\ntarget_payload = {\n    \"lambdaArn\": lambda_arn,\n    \"toolSchema\": {\n        \"inlinePayload\": [\n            {\n                \"name\": \"calculate_sum\",\n                \"description\": \"Add two numbers\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"a\": {\"type\": \"number\", \"description\": \"First number\"},\n                        \"b\": {\"type\": \"number\", \"description\": \"Second number\"}\n                    },\n                    \"required\": [\"a\", \"b\"]\n                }\n            },\n            {\n                \"name\": \"multiply\",\n                \"description\": \"Multiply two numbers\",\n                \"inputSchema\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"x\": {\"type\": \"number\", \"description\": \"First number\"},\n                        \"y\": {\"type\": \"number\", \"description\": \"Second number\"}\n                    },\n                    \"required\": [\"x\", \"y\"]\n                }\n            }\n        ]\n    }\n}\n\ntarget = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=\"CustomCalculator\",\n    target_type=\"lambda\",\n    target_payload=target_payload\n)\n\nprint(f\"\u2713 Custom Lambda target added: {target['targetId']}\")\nprint(\"\\nRun 'python run_agent.py' and try: 'Calculate the sum of 42 and 58'\")\n</code></pre>  Run: `python create_custom_lambda.py` then `python run_agent.py` to test.   <p>If you're excited and want to learn more about Gateways and the other Target types. Continue through this guide.</p>"},{"location":"user-guide/gateway/quickstart.html#adding-your-own-apis","title":"Adding Your Own APIs","text":""},{"location":"user-guide/gateway/quickstart.html#nasa-api-integration","title":"NASA API Integration","text":"<p>Integrate real APIs like NASA\u2019s Astronomy Picture of the Day. Get your API key from https://api.nasa.gov/ (instant via email), then create <code>add_nasa_api.py</code>:</p> <p>This example shows how to add external REST APIs to your Gateway, making them available as tools for your agent.</p> <pre><code>from bedrock_agentcore_starter_toolkit.operations.gateway.client import GatewayClient\nimport json\n\nwith open(\"gateway_config.json\", \"r\") as f:\n    config = json.load(f)\n\nclient = GatewayClient(region_name=config[\"region\"])\n\nnasa_spec = {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\"title\": \"NASA API\", \"version\": \"1.0.0\"},\n    \"servers\": [{\"url\": \"https://api.nasa.gov\"}],\n    \"paths\": {\n        \"/planetary/apod\": {\n            \"get\": {\n                \"operationId\": \"getAstronomyPictureOfDay\",\n                \"summary\": \"Get NASA's Astronomy Picture of the Day\",\n                \"parameters\": [\n                    {\n                        \"name\": \"date\",\n                        \"in\": \"query\",\n                        \"required\": False,\n                        \"schema\": {\"type\": \"string\"},\n                        \"description\": \"Date in YYYY-MM-DD format\"\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Success\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"title\": {\"type\": \"string\"},\n                                        \"explanation\": {\"type\": \"string\"},\n                                        \"url\": {\"type\": \"string\"}\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\ngateway = client.client.get_gateway(gatewayIdentifier=config[\"gateway_id\"])\n\nnasa_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=\"NasaApi\",\n    target_type=\"openApiSchema\",\n    target_payload={\"inlinePayload\": json.dumps(nasa_spec)},\n    credentials={\n        \"api_key\": \"YOUR_NASA_API_KEY\",  # Replace with your key\n        \"credential_location\": \"QUERY_PARAMETER\",\n        \"credential_parameter_name\": \"api_key\"\n    }\n)\n\nprint(f\"\u2713 NASA API added! Try: 'Get NASA's astronomy picture for 2024-12-25'\")\nprint(\"Run 'python run_agent.py' and try: 'Get NASA's astronomy picture for 2024-12-25'\")\n</code></pre>"},{"location":"user-guide/gateway/quickstart.html#adding-openapi-targets","title":"Adding OpenAPI Targets","text":"<p>Let's add an OpenAPI target. This code uses the OpenAPI schema for a NASA API that provides Mars weather information. You can get an API key sent to your email in a minute by filling out the form here: https://api.nasa.gov/.</p> <p>Open API Spec for NASA Mars weather API</p> <pre><code>nasa_open_api_payload = {\n  \"openapi\": \"3.0.3\",\n  \"info\": {\n    \"title\": \"NASA InSight Mars Weather API\",\n    \"description\": \"Returns per\u2011Sol weather summaries from the InSight lander for the seven most recent Martian sols.\",\n    \"version\": \"1.0.0\"\n  },\n  \"servers\": [\n    {\n      \"url\": \"https://api.nasa.gov\"\n    }\n  ],\n  \"paths\": {\n    \"/insight_weather/\": {\n      \"get\": {\n        \"summary\": \"Retrieve latest InSight Mars weather data\",\n        \"operationId\": \"getInsightWeather\",\n        \"parameters\": [\n          {\n            \"name\": \"feedtype\",\n            \"in\": \"query\",\n            \"required\": true,\n            \"description\": \"Response format (only \\\"json\\\" is supported).\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"json\"\n              ]\n            }\n          },\n          {\n            \"name\": \"ver\",\n            \"in\": \"query\",\n            \"required\": true,\n            \"description\": \"API version string. (only \\\"1.0\\\" supported)\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"enum\": [\n                \"1.0\"\n              ]\n            }\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Successful response \u2013 weather data per Martian sol.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/InsightWeatherResponse\"\n                }\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"Bad request \u2013 missing or invalid parameters.\"\n          },\n          \"429\": {\n            \"description\": \"Too many requests \u2013 hourly rate limit exceeded (2\u202f000 hits/IP).\"\n          },\n          \"500\": {\n            \"description\": \"Internal server error.\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"InsightWeatherResponse\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"sol_keys\"\n        ],\n        \"description\": \"Top\u2011level object keyed by sol numbers plus metadata.\",\n        \"properties\": {\n          \"sol_keys\": {\n            \"type\": \"array\",\n            \"description\": \"List of sols (as strings) included in this payload.\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          },\n          \"validity_checks\": {\n            \"type\": \"object\",\n            \"additionalProperties\": {\n              \"$ref\": \"#/components/schemas/ValidityCheckPerSol\"\n            },\n            \"description\": \"Data\u2011quality provenance per sol and sensor.\"\n          }\n        },\n        \"additionalProperties\": {\n          \"oneOf\": [\n            {\n              \"$ref\": \"#/components/schemas/SolWeather\"\n            }\n          ]\n        }\n      },\n      \"SolWeather\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"AT\": {\n            \"$ref\": \"#/components/schemas/SensorData\"\n          },\n          \"HWS\": {\n            \"$ref\": \"#/components/schemas/SensorData\"\n          },\n          \"PRE\": {\n            \"$ref\": \"#/components/schemas/SensorData\"\n          },\n          \"WD\": {\n            \"$ref\": \"#/components/schemas/WindDirection\"\n          },\n          \"Season\": {\n            \"type\": \"string\",\n            \"enum\": [\n              \"winter\",\n              \"spring\",\n              \"summer\",\n              \"fall\"\n            ]\n          },\n          \"First_UTC\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          },\n          \"Last_UTC\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\"\n          }\n        }\n      },\n      \"SensorData\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"av\": {\n            \"type\": \"number\"\n          },\n          \"ct\": {\n            \"type\": \"number\"\n          },\n          \"mn\": {\n            \"type\": \"number\"\n          },\n          \"mx\": {\n            \"type\": \"number\"\n          }\n        }\n      },\n      \"WindDirection\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"most_common\": {\n            \"$ref\": \"#/components/schemas/WindCompassPoint\"\n          }\n        },\n        \"additionalProperties\": {\n          \"$ref\": \"#/components/schemas/WindCompassPoint\"\n        }\n      },\n      \"WindCompassPoint\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"compass_degrees\": {\n            \"type\": \"number\"\n          },\n          \"compass_point\": {\n            \"type\": \"string\"\n          },\n          \"compass_right\": {\n            \"type\": \"number\"\n          },\n          \"compass_up\": {\n            \"type\": \"number\"\n          },\n          \"ct\": {\n            \"type\": \"number\"\n          }\n        }\n      },\n      \"ValidityCheckPerSol\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"AT\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          },\n          \"HWS\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          },\n          \"PRE\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          },\n          \"WD\": {\n            \"$ref\": \"#/components/schemas/SensorValidity\"\n          }\n        }\n      },\n      \"SensorValidity\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sol_hours_with_data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"integer\",\n              \"minimum\": 0,\n              \"maximum\": 23\n            }\n          },\n          \"valid\": {\n            \"type\": \"boolean\"\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p></p> <p>Use the following code to add an Open API target. Note: don't forget to add your api_key below. <pre><code>open_api_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=None,\n    target_type=\"openApiSchema\",\n    # the API spec to use (note don't forget to )\n    target_payload={\n        \"inlinePayload\": json.dumps(nasa_open_api_payload)\n    },\n    # the credentials to use when interacting with this API\n    credentials={\n        \"api_key\": \"&lt;INSERT KEY&gt;\",\n        \"credential_location\": \"QUERY_PARAMETER\",\n        \"credential_parameter_name\": \"api_key\"\n    }\n)\n</code></pre></p>  \u27a1\ufe0f Advanced OpenAPI Configurations (Import API specs from S3 + set up APIs with OAuth)   You can also use an OpenAPI specification stored in S3 buckets by passing the following `target_payload` field. **\u26a0\ufe0f Note don't forget to fill in the S3 URI below.** <pre><code>{\n    \"s3\": {\n        \"uri\": \"&lt;INSERT S3 URI&gt;\"\n    }\n}\n</code></pre>  If you have an API that uses a key stored in a header value you can set the `credentials` field to the following. **Note don't forget to fill in the api key and parameter name below.** <pre><code>{\n    \"api_key\": \"&lt;INSERT KEY&gt;\",\n    \"credential_location\": \"HEADER\",\n    \"credential_parameter_name\": \"&lt;INSERT HEADER VALUE&gt;\"\n}\n</code></pre>  Alternatively if you have an API that uses OAuth, set the `credentials` field to the following. **\u26a0\ufe0f Note don't forget to fill in all of the information below.** <pre><code>{\n  \"oauth2_provider_config\": {\n    \"customOauth2ProviderConfig\": {\n      \"oauthDiscovery\": {\n        \"authorizationServerMetadata\": {\n          \"issuer\": \"&lt;INSERT ISSUER URL&gt;\",\n          \"authorizationEndpoint\": \"&lt;INSERT AUTHORIZATION ENDPOINT&gt;\",\n          \"tokenEndpoint\": \"&lt;INSERT TOKEN ENDPOINT&gt;\"\n        }\n      },\n      \"clientId\": \"&lt;INSERT CLIENT ID&gt;\",\n      \"clientSecret\": \"&lt;INSERT CLIENT SECRET&gt;\"\n    }\n  }\n}\n</code></pre> There are other supported `oauth_2_provider` types including Microsoft, GitHub, Google, Salesforce, and Slack. For information on the structure of those provider configs see the [identity documentation](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/identity-idps.html)."},{"location":"user-guide/gateway/quickstart.html#adding-smithy-api-model-targets","title":"Adding Smithy API Model Targets","text":"<p>Let's add a Smithy API model target. Many AWS services use Smithy API models to describe their APIs. This AWS-maintained GitHub repository has over the models of 350+ AWS services for download. For quick testing, we've made it possible to use a few of these models in the AgentCore Gateway without downloading them or storing them in S3. To create a Smithy API model target for DynamoDB simply run:</p> <pre><code># create a Smithy API model target for DynamoDB\nsmithy_target = client.create_mcp_gateway_target(gateway=gateway, name=None, target_type=\"smithyModel\")\n</code></pre>  \u27a1\ufe0f Add more Smithy API model targets   Create a Smithy API model target from a Smithy API model stored in S3. **\u26a0\ufe0f Note don't forget to fill in the S3 URI below.** <pre><code># create a Smithy API model target from a Smithy API model stored in S3\nopen_api_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=None,\n    target_type=\"smithyModel\",\n    target_payload={\n        \"s3\": {\n            \"uri\": \"&lt;INSERT S3 URI&gt;\"\n        }\n    },\n)\n</code></pre>  Create a Smithy API model target from a Smithy API model inline. **\u26a0\ufe0f Note don't forget to load the Smithy model JSON into the smithy_model_json variable.** <pre><code># create a Smithy API model target from a Smithy API model stored in S3\nopen_api_target = client.create_mcp_gateway_target(\n    gateway=gateway,\n    name=None,\n    target_type=\"smithyModel\",\n    target_payload={\n        \"inlinePayload\": json.dumps(smithy_model_json)\n    },\n)\n</code></pre> <p></p> \u27a1\ufe0f More Operations on Gateways and Targets (Create, Read, Update, Delete, List)  Advanced: AWS PrivateLink for VPC Connectivity  Create private connection between your VPC and Gateway:  <pre><code>aws ec2 create-vpc-endpoint \\\n    --vpc-id vpc-12345678 \\\n    --service-name com.amazonaws.region.bedrock-agentcore.gateway\n</code></pre>   While the Starter Toolkit makes it easy to get started, the Boto3 Python client has a more complete set of operations including those for creating, reading, updating, deleting, and listing Gateways and Targets. Let's see how to use Boto3 to carry out these operations on Gateways and Targets.  ### Setup  Instantiate the client <pre><code>import boto3\n\nboto_client = boto3.client(\"bedrock-agentcore-control\",\n                           region_name=\"us-east-1\")\n</code></pre>  ### Listing Gateways/Targets Run the below code to list all of the Gateways in your account. <pre><code># list gateawys\ngateways = boto_client.list_gateways()\n</code></pre> Run the below code to list all of the Gateway Targets for a specific Gateway. <pre><code># list targets\ngateway_targets = boto_client.list_gateway_targets(gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\")\n</code></pre>  ### Getting Gateways/Targets Run the below code to get the details of a Gateway <pre><code># get a gateway\ngateway_details = boto_client.get_gateway(gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\")\n</code></pre> Run the below code to get the details of a Gateway Target. <pre><code># get a target\ntarget_details = boto_client.get_gateway_target(gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\", targetId=\"INSERT TARGET ID\")\n</code></pre>  ### Creating / Updating Gateways  Let's see how to create a Gateway. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of a create request for a Gateway: <pre><code># the schema of a create request for a Gateway\ncreate_gw_request = {\n    \"name\": \"string\", # required - name of your gateway\n    \"description\": \"string\", # optional - description of your gateway\n    \"clientToken\": \"string\", # optional - used for idempotency\n    \"roleArn\": \"string\", # required - execution role arn that Gateway will use when interacting with AWS resources\n    \"protocolType\": \"string\", # required - must be MCP\n    \"protocolConfiguration\": { # optional\n        \"mcp\": {\n            \"supportedVersions\": [\"enum_string\"], # optional - e.g. 2025-06-18\n            \"instructions\": \"string\", # optional - instructions for agents using this MCP server\n            \"searchType\": \"enum_string\" # optional - must be SEMANTIC if specified. This enables the tool search tool\n        }\n    },\n    \"authorizerType\": \"string\", # required - must be CUSTOM_JWT\n    \"authorizerConfiguration\": { # required - the configuration for your authorizer\n        \"customJWTAuthorizer\": { # required the custom JWT authorizer setup\n            \"allowedAudience\": [], # optional\n            \"allowedClients\": [], # optional\n            \"discoveryUrl\": \"string\" # required - the URL of the authorization server\n        },\n    },\n    \"kmsKeyArn\": \"string\", # optional - an encryption key to use for encrypting your tool metadata stored on Gateway\n    \"exceptionLevel\": \"string\", # optional - must be DEBUG if specified. Gateway will return verbose error messages when DEBUG is specified.\n}\n</code></pre>  Let's take a look at a simpler example: <pre><code># an example of a create request\nexample_create_gw_request = {\n    \"name\": \"TestGateway\",\n    \"roleArn\": \"&lt;INSERT ROLE ARN e.g. arn:aws:iam::123456789012:role/Admin&gt;\",\n    \"protocolType\": \"MCP\",\n    \"authorizerType\": \"CUSTOM_JWT\",\n    \"authorizerConfiguration\":  {\n        \"customJWTAuthorizer\": {\n            \"discoveryUrl\": \"&lt;INSERT DISCOVERY URL e.g. https://cognito-idp.{region}.amazonaws.com/{user_pool_id}/.well-known/openid-configuration&gt;\",\n            \"allowedClients\": [\"&lt;INSERT CLIENT ID&gt;\"]\n        }\n    }\n}\n</code></pre> Once you have filled in your request details, you can create a Gateway from that request with the following command: <pre><code># create the gateway\ngateway = boto_client.create_gateway(**example_create_gw_request)\n</code></pre>  Now let's see how to update a Gateway that we've already created. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of an update request for a Gateway: <pre><code># the schema of an update request for a Gateway\nupdate_gw_request = {\n    \"gatewayIdentifier\": \"string\", # required - the ID of the existing gateway\n    \"name\": \"string\", # required - name of your gateway\n    \"description\": \"string\", # optional - description of your gateway\n    \"roleArn\": \"string\", # required - execution role arn that Gateway will use when interacting with AWS resources\n    \"protocolType\": \"string\", # required - must be MCP\n    \"protocolConfiguration\": { # optional\n        \"mcp\": {\n            \"supportedVersions\": [\"enum_string\"], # optional - e.g. 2025-06-18\n            \"instructions\": \"string\", # optional - instructions for agents using this MCP server\n            \"searchType\": \"enum_string\" # optional - must be SEMANTIC if specified. This enables the tool search tool\n        }\n    },\n    \"authorizerType\": \"string\", # required - must be CUSTOM_JWT\n    \"authorizerConfiguration\": { # required - the configuration for your authorizer\n        \"customJWTAuthorizer\": { # required the custom JWT authorizer setup\n            \"allowedAudience\": [], # optional\n            \"allowedClients\": [], # optional\n            \"discoveryUrl\": \"string\" # required - the URL of the authorization server\n        },\n    },\n    \"kmsKeyArn\": \"string\", # optional - an encryption key to use for encrypting your tool metadata stored on Gateway\n}\n</code></pre>  Let's take a look at a simpler example: <pre><code># an example of an update request\nexample_update_gw_request = {\n    \"gatewayIdentifier\": \"&lt;INSERT ID OF CREATED GATEWAY&gt;\",\n    \"name\": \"TestGateway\",\n    \"roleArn\": \"&lt;INSERT ROLE ARN e.g. arn:aws:iam::123456789012:role/Admin&gt;\",\n    \"protocolType\": \"MCP\",\n    \"authorizerType\": \"CUSTOM_JWT\",\n    \"authorizerConfiguration\":  {\n        \"customJWTAuthorizer\": {\n            \"discoveryUrl\": \"&lt;INSERT DISCOVERY URL e.g. https://cognito-idp.{region}.amazonaws.com/{user_pool_id}/.well-known/openid-configuration&gt;\",\n            \"allowedClients\": [\"&lt;INSERT CLIENT ID&gt;\"]\n        }\n    }\n}\n</code></pre>  Once you've filled in you request details you can update a Gateway using that request with the following command: <pre><code># update the gateway\ngateway = boto_client.update_gateway(**example_update_gw_request)\n</code></pre>  ### Creating / Updating Targets  Let's see how to create a Gateway Target. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of a create request for a Gateway Target: <pre><code># the schema of a create request for a Gateway Target\ncreate_target_request = {\n    \"gatewayIdentifier\": \"string\", # required - the ID of the Gateway to create this target on\n    \"name\": \"string\", # required\n    \"description\": \"string\", # optional - description of your target\n    \"clientToken\": \"string\", # optional - used for idempotency\n    \"targetConfiguration\": { # required\n        \"mcp\": { # required - union - choose one of openApiSchema | smithyModel | lambda\n            \"openApiSchema\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"smithyModel\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"lambda\": {\n                \"lambdaArn\": \"string\",\n                \"toolSchema\": { # union - choose one of either s3 or inlinePayload\n                    \"s3\": {\n                        \"uri\": \"string\",\n                        \"bucketOwnerAccountId\": \"string\"\n                     },\n                    \"inlinePayload\": [\n                        # &lt;inline tool here&gt;\n                    ]\n                }\n            }\n        }\n    },\n    \"credentialProviderConfigurations\": [\n        {\n            \"credentialProviderType\": \"enum_string\", # required - choose one of OAUTH | API_KEY | GATEWAY_IAM_ROLE\n            \"credentialProvider\": { # optional (required if you choose OAUTH or API_KEY) - union - choose either apiKeyCredentialProvider | oauthCredentialProvider\n                \"oauthCredentialProvider\": {\n                    \"providerArn\": \"string\", # required - the ARN of the credential provider\n                    \"scopes\": [\"string\"], # required - can be empty list in some cases\n                },\n                \"apiKeyCredentialProvider\": {\n                    \"providerArn\": \"string\", # required - the ARN of the credential provider\n                    \"credentialLocation\": \"enum_string\", # required - the location where the credential goes - choose HEADER | QUERY_PARAMETER\n                    \"credentialParameterName\": \"string\", # required - the header key or parameter name e.g., \u201cAuthorization\u201d, \u201cX-API-KEY\u201d\n                    \"credentialPrefix\": \"string\"  # optional - the prefix the auth token needs e.g. \u201cBearer\u201d\n                }\n            }\n        }\n    ]\n}\n</code></pre>  Let's take a look at a simpler example: <pre><code># example of a target creation request\nexample_create_target_request = {\n    \"gatewayIdentifier\": \"&lt;INSERT GATEWAY ID\",\n    \"name\": \"TestLambdaTarget\",\n    \"targetConfiguration\": {\n        \"mcp\": {\n            \"lambda\": {\n                \"lambdaArn\": \"&lt;INSERT LAMBDA ARN e.g. arn:aws:lambda:us-west-2:123456789012:function:TestLambda&gt;\",\n                \"toolSchema\": {\n                    \"s3\": {\n                        \"uri\": \"&lt;INSERT S3 URI&gt;\"\n                    }\n                }\n            }\n        }\n    },\n    \"credentialProvider\": [\n        {\n            \"credentialProviderType\": \"GATEWAY_IAM_ROLE\"\n        }\n    ]\n}\n</code></pre> Once you've filled in you request details you can create a Gateway Target using that request with the following command: <pre><code># create the target\ntarget = boto_client.create_gateway_target(**example_create_target_request)\n</code></pre>  Now let's see how to update a Gateway Target. **\u26a0\ufe0f Note don't forget to fill in the required fields with appropriate values.**  Below is the structure of an update request for a Target: <pre><code># create a target\nupdate_target_request = {\n    \"gatewayIdentifier\": \"string\", # required - the ID of the Gateway to update this target on\n    \"targetId\": \"string\", # required - the ID of the target to update\n    \"name\": \"string\", # required\n    \"description\": \"string\", # optional - description of your target\n    \"targetConfiguration\": { # required\n        \"mcp\": { # required - union - choose one of openApiSchema | smithyModel | lambda\n            \"openApiSchema\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"smithyModel\": { # union - choose one of either s3 or inlinePayload\n                \"s3\": {\n                    \"uri\": \"string\",\n                    \"bucketOwnerAccountId\": \"string\"\n                },\n                \"inlinePayload\": \"string\"\n            },\n            \"lambda\": {\n                \"lambdaArn\": \"string\",\n                \"toolSchema\": { # union - choose one of either s3 or inlinePayload\n                    \"s3\": {\n                        \"uri\": \"string\",\n                        \"bucketOwnerAccountId\": \"string\"\n                     },\n                    \"inlinePayload\": [\n                        # &lt;inline tool here&gt;\n                    ]\n                }\n            }\n        }\n    },\n    \"credentialProviderConfigurations\": [\n        {\n            \"credentialProviderType\": \"enum_string\", # required - choose one of OAUTH | API_KEY | GATEWAY_IAM_ROLE\n            \"credentialProvider\": { # optional (required if you choose OAUTH or API_KEY) - union - choose either apiKeyCredentialProvider | oauthCredentialProvider\n                \"oauthCredentialProvider\": {\n                    \"providerArn\": \"string\", # required\n                    \"scopes\": [\"string\"], # required - can be empty list in some cases\n                },\n                \"apiKeyCredentialProvider\": {\n                    \"providerArn\": \"string\", # required\n                    \"credentialLocation\": \"enum_string\", # required - the location where the credential goes - choose HEADER | QUERY_PARAMETER\n                    \"credentialParameterName\": \"string\", # required - the header key or parameter name e.g., \u201cAuthorization\u201d, \u201cX-API-KEY\u201d\n                    \"credentialPrefix\": \"string\"  # optional - the prefix the auth token needs e.g. \u201cBearer\u201d\n                }\n            }\n        }\n    ]\n}\n</code></pre> Let's take a look at a simpler example: <pre><code>example_update_target_request = {\n    \"gatewayIdentifier\": \"&lt;INSERT GATEWAY ID\",\n    \"targetId\": \"&lt;INSERT TARGET ID&gt;\",\n    \"name\": \"TestLambdaTarget\",\n    \"targetConfiguration\": {\n        \"mcp\": {\n            \"lambda\": {\n                \"lambdaArn\": \"&lt;INSERT LAMBDA ARN e.g. arn:aws:lambda:us-west-2:123456789012:function:TestLambda&gt;\",\n                \"toolSchema\": {\n                    \"s3\": {\n                        \"uri\": \"&lt;INSERT S3 URI&gt;\"\n                    }\n                }\n            }\n        }\n    },\n    \"credentialProvider\": [\n        {\n            \"credentialProviderType\": \"GATEWAY_IAM_ROLE\"\n        }\n    ]\n}\n</code></pre> Once you've filled in you request details you can create a Target using that request with the following command: <pre><code># update a target\ntarget = boto_client.update_gateway_target(**example_update_target_request)\n</code></pre>   ### Deleting Gateways / Targets Run the below code to delete a Gateway. <pre><code># delete a gateway\ndelete_gateway_response = boto_client.delete_gateway(\n    gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\"\n)\n</code></pre>  Run the below code to delete a Gateway Target. <pre><code># delete a target\ndelete_target_response = boto_client.delete_gateway_target(\n    gatewayIdentifier=\"&lt;INSERT GATEWAY ID&gt;\",\n    targetId=\"&lt;INSERT TARGET ID&gt;\"\n)\n</code></pre>"},{"location":"user-guide/identity/quickstart.html","title":"Getting Started with AgentCore Identity","text":"<p>Amazon Bedrock AgentCore Identity provides a secure way to manage identities for your AI agents and enable authenticated access to external services. This guide will help you get started with implementing identity features in your agent applications.</p>"},{"location":"user-guide/identity/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>An AWS account with appropriate permissions</li> <li>Python 3.10+ installed</li> <li>The latest AWS CLI installed</li> <li>AWS credentials and region configured (<code>aws configure</code>)</li> </ul> <p>This quickstart requires that you have an OAuth 2.0 authorization server. If you do not have one, Step 0.5 will create one for you using Amazon Cognito user pools. If you have an OAuth 2.0 authorization server with a client id, client secret, and a user configured, you may proceed to step 1. This authorization server will act as a resource credential provider, representing the authority that grants the agent an outbound OAuth 2.0 access token.</p>"},{"location":"user-guide/identity/quickstart.html#install-the-sdk-and-dependencies","title":"Install the SDK and dependencies","text":"<p>Make a folder for this guide, create a Python virtual environment, and install the AgentCore SDK and the aws Python SDK (boto3)</p> <pre><code>mkdir agentcore-identity-quickstart\ncd agentcore-identity-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\npip install bedrock-agentcore boto3 strands-agents bedrock-agentcore-starter-toolkit pyjwt\n</code></pre> <p>Also create the <code>requirements.txt</code> file with the following content. This will be used later by the AgentCore deployment tool.</p> <pre><code>bedrock-agentcore\nboto3\npyjwt\nstrands-agents\nbedrock-agentcore-starter-toolkit\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#step-05-create-a-cognito-user-pool","title":"Step 0.5: Create a Cognito user pool","text":"<p>This quickstart requires an OAuth 2.0 authorization server. If you do not have one available for testing, or if you want to keep your test separate from your authorization server, this script will use your AWS credentials to set up an Amazon Cognito instance for you to use as an authorization server. The script will create:</p> <ul> <li>A Cognito user pool</li> <li>An OAuth 2.0 client, and client secret for that user pool</li> <li>A test user and password in that Cognito user pool</li> </ul> <p>Deleting the Cognito user pool AgentCoreIdentityQuickStartPool will delete the associated client_id and user as well.</p> <p>You may choose to save this script as create_cognito.sh and execute it from your command line, or paste the script into your command line.</p> <pre><code>#!/bin/bash\n\nREGION=$(aws configure get region)\n\n# Create user pool\nUSER_POOL_ID=$(aws cognito-idp create-user-pool \\\n  --pool-name AgentCoreIdentityQuickStartPool \\\n  --query 'UserPool.Id' \\\n  --no-cli-pager \\\n  --output text)\n\n# Create user pool domain\nDOMAIN_NAME=\"agentcore-quickstart-$(LC_ALL=C tr -dc 'a-z0-9' &lt; /dev/urandom | head -c 5)\"\naws cognito-idp create-user-pool-domain \\\n  --domain $DOMAIN_NAME \\\n  --no-cli-pager \\\n  --user-pool-id $USER_POOL_ID &gt; /dev/null\n\n# Create user pool client with secret and hosted UI settings\nCLIENT_RESPONSE=$(aws cognito-idp create-user-pool-client \\\n  --user-pool-id $USER_POOL_ID \\\n  --client-name AgentCoreQuickStart \\\n  --generate-secret \\\n  --callback-urls \"https://bedrock-agentcore.$REGION.amazonaws.com/identities/oauth2/callback\" \\\n  --allowed-o-auth-flows \"code\" \\\n  --allowed-o-auth-scopes \"openid\" \"profile\" \"email\" \\\n  --allowed-o-auth-flows-user-pool-client \\\n  --supported-identity-providers \"COGNITO\" \\\n  --query 'UserPoolClient.{ClientId:ClientId,ClientSecret:ClientSecret}' \\\n  --output json)\n\nCLIENT_ID=$(echo $CLIENT_RESPONSE | jq -r '.ClientId')\nCLIENT_SECRET=$(echo $CLIENT_RESPONSE | jq -r '.ClientSecret')\n\n# Generate random username and password\nUSERNAME=\"AgentCoreTestUser$(printf \"%04d\" $((RANDOM % 10000)))\"\nPASSWORD=\"$(LC_ALL=C tr -dc 'A-Za-z0-9!@#$%^&amp;*()_+-=[]{}|;:,.&lt;&gt;?' &lt; /dev/urandom | head -c 16)\"\n\n# Create user with permanent password\naws cognito-idp admin-create-user \\\n  --user-pool-id $USER_POOL_ID \\\n  --username $USERNAME \\\n  --output text &gt; /dev/null\n\naws cognito-idp admin-set-user-password \\\n  --user-pool-id $USER_POOL_ID \\\n  --username $USERNAME \\\n  --password $PASSWORD \\\n  --output text &gt; /dev/null \\\n  --permanent\n\n# Get region\n\nISSUER_URL=\"https://cognito-idp.$REGION.amazonaws.com/$USER_POOL_ID/.well-known/openid-configuration\"\nHOSTED_UI_URL=\"https://$DOMAIN_NAME.auth.$REGION.amazoncognito.com\"\n\n# Output results\necho \"User Pool ID: $USER_POOL_ID\"\necho \"Client ID: $CLIENT_ID\"\necho \"Client Secret: $CLIENT_SECRET\"\necho \"Issuer URL: $ISSUER_URL\"\necho \"Hosted UI URL: $HOSTED_UI_URL\"\necho \"Test User: $USERNAME\"\necho \"Test Password: $PASSWORD\"\n\necho \"\"\necho \"# Copy and paste these exports to set environment variables for later use:\"\necho \"export USER_POOL_ID='$USER_POOL_ID'\"\necho \"export CLIENT_ID='$CLIENT_ID'\"\necho \"export CLIENT_SECRET='$CLIENT_SECRET'\"\necho \"export ISSUER_URL='$ISSUER_URL'\"\necho \"export HOSTED_UI_URL='$HOSTED_UI_URL'\"\necho \"export COGNITO_USERNAME='$USERNAME'\"\necho \"export COGNITO_PASSWORD='$PASSWORD'\"\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#step-1-create-a-credential-provider","title":"Step 1: Create a credential provider","text":"<p>Credential providers are how your agent accesses external services. Create a credential provider and configure it with an OAuth 2.0 client for your authorization server.</p> <p>If you are using your own authorization server, set the environment variables <code>ISSUER_URL</code>, <code>CLIENT_ID</code>, and <code>CLIENT_SECRET</code> with their appropriate values from your authorization server. If you are using the previous script to create an authorization server for you with Cognito, copy the EXPORT statements from the output into your terminal to set the environment variables.</p> <p>This credential provider will be used by your agent's code to get access tokens to act on behalf of your user.</p> <pre><code>#!/bin/bash\n# please note the expected ISSUER_URL format for Bedrock AgentCore is the full url, including .well-known/openid-configuration\naws bedrock-agentcore-control create-oauth2-credential-provider \\\n  --name \"AgentCoreIdentityQuickStartProvider\" \\\n  --credential-provider-vendor \"CustomOauth2\" \\\n  --no-cli-pager \\\n  --oauth2-provider-config-input '{\n    \"customOauth2ProviderConfig\": {\n      \"oauthDiscovery\": {\n        \"discoveryUrl\": \"'$ISSUER_URL'\"\n      },\n      \"clientId\": \"'$CLIENT_ID'\",\n      \"clientSecret\": \"'$CLIENT_SECRET'\"\n    }\n  }'\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#step-2-create-a-sample-agent-that-initiates-an-oauth-20-flow","title":"Step 2: Create a sample agent that initiates an OAuth 2.0 flow","text":"<p>In this step, we will create an agent that initiates an OAuth 2.0 authorization flow to get tokens to act on behalf of the user. For simplicity, the agent will not make actual calls to external services on behalf of a user, but will prove to us that it has obtained consent to act on behalf of our test user.</p>"},{"location":"user-guide/identity/quickstart.html#agent-code","title":"Agent code","text":"<p>Create a file named <code>agentcoreidentityquickstart.py</code>, and save this code.</p> <pre><code>\"\"\"\nAgentCore Identity Outbound Token Agent\n\nThis agent demonstrates the USER_FEDERATION OAuth 2.0 flow.\n\nIt handles the OAuth 2.0 user consent flow and inspects the resulting OAuth 2.0 access token.\n\"\"\"\n\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom bedrock_agentcore.identity import requires_access_token\nimport asyncio\nimport jwt\nimport logging\n\napp = BedrockAgentCoreApp()\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef decode_jwt(token):\n    try:\n        decoded = jwt.decode(token, options={\"verify_signature\": False})\n        return decoded\n    except Exception as e:\n        return {\"error\": f\"Error decoding JWT: {str(e)}\"}\n\nclass StreamingQueue:\n    def __init__(self):\n        self.finished = False\n        self.queue = asyncio.Queue()\n\n    async def put(self, item):\n        await self.queue.put(item)\n\n    async def finish(self):\n        self.finished = True\n        await self.queue.put(None)\n\n    async def stream(self):\n        while True:\n            item = await self.queue.get()\n            if item is None and self.finished:\n                break\n            yield item\n\nqueue = StreamingQueue()\n\nasync def handle_auth_url(url):\n    await queue.put(f\"Authorization URL, please copy to your preferred browser: {url}\")\n\n@requires_access_token(\n    provider_name=\"AgentCoreIdentityQuickStartProvider\",\n    scopes=[\"openid\"],\n    auth_flow=\"USER_FEDERATION\",\n    on_auth_url=handle_auth_url, # streams authorization URL to client\n    force_authentication=True\n)\nasync def introspect_with_decorator(*, access_token: str):\n    \"\"\"Introspect token using decorator\"\"\"\n    logger.info(\"Inside introspect_with_decorator - decorator succeeded\")\n    await queue.put({\n        \"message\": \"Successfully received an access token to act on behalf of your user!\",\n        \"token_claims\": decode_jwt(access_token),\n        \"token_length\": len(access_token),\n        \"token_preview\": f\"{access_token[:50]}...{access_token[-10:]}\"\n    })\n    await queue.finish()\n\n@app.entrypoint\nasync def agent_invocation(payload, context):\n    \"\"\"Handler that uses only the decorator approach\"\"\"\n    logger.info(\"Agent invocation started\")\n\n    # Start the agent task and immediately begin streaming\n    task = asyncio.create_task(introspect_with_decorator())\n\n    # Stream items as they come in\n    async for item in queue.stream():\n        yield item\n\n    # Wait for task completion\n    await task\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#step-3-deploy-the-agent-to-agentcore-runtime","title":"Step 3:  Deploy the agent to AgentCore Runtime","text":"<p>We will host this agent on AgentCore Runtime. We can do this easily with the AgentCore SDK we installed earlier.</p> <p>From your terminal, run <code>agentcore configure -e agentcoreidentityquickstart.py</code> and <code>agentcore launch</code> . The deployment will work with the defaults set by <code>agentcore configure</code>, but you may customize them. Ensure that you select \"No\" for the <code>Configure OAuth authorizer instead</code> step. We want to use IAM authorization for this guide.</p>"},{"location":"user-guide/identity/quickstart.html#update-the-iam-policy-of-the-agent-to-be-able-to-access-the-token-vault-and-client-secret","title":"Update the IAM policy of the agent to be able to access the token vault, and client secret","text":"<p>You will need to update the IAM policy of your agent that was created by or used with <code>agentcore configure</code>. This script will read your agent's configuration YAML and append the appropriate policy. You can copy and paste this script, or save it to a file and execute it.</p> <pre><code>#!/bin/bash\n\n# Parse values from .bedrock_agentcore.yaml\nEXECUTION_ROLE=$(grep \"execution_role:\" .bedrock_agentcore.yaml | head -1 | awk '{print $2}')\nAWS_ACCOUNT=$(grep \"account:\" .bedrock_agentcore.yaml | head -1 | awk '{print $2}' | tr -d \"'\")\nREGION=$(grep \"region:\" .bedrock_agentcore.yaml | awk '{print $2}')\n\necho \"Parsed values:\"\necho \"Execution Role: $EXECUTION_ROLE\"\necho \"Account: $AWS_ACCOUNT\"\necho \"Region: $REGION\"\n\n# Create the policy document with proper variable substitution\ncat &gt; agentcore-identity-policy.json &lt;&lt; EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"AccessTokenVault\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"bedrock-agentcore:GetResourceOauth2Token\",\n        \"secretsmanager:GetSecretValue\"\n      ],\n      \"Resource\": [\"arn:aws:bedrock-agentcore:${REGION}:${AWS_ACCOUNT}:workload-identity-directory/default/workload-identity/*\",\n        \"arn:aws:bedrock-agentcore:${REGION}:${AWS_ACCOUNT}:token-vault/default/oauth2credentialprovider/AgentCoreIdentityQuickStartProvider\",\n        \"arn:aws:bedrock-agentcore:${REGION}:${AWS_ACCOUNT}:workload-identity-directory/default\",\n        \"arn:aws:bedrock-agentcore:${REGION}:${AWS_ACCOUNT}:token-vault/default\",\n        \"arn:aws:secretsmanager:${REGION}:${AWS_ACCOUNT}:secret:bedrock-agentcore-identity!default/oauth2/AgentCoreIdentityQuickStartProvider*\"\n      ]\n    }\n  ]\n}\nEOF\n\n# Create the policy\nPOLICY_ARN=$(aws iam create-policy \\\n    --policy-name AgentCoreIdentityQuickStartPolicy$(LC_ALL=C tr -dc '0-9' &lt; /dev/urandom | head -c 4) \\\n    --policy-document file://agentcore-identity-policy.json \\\n    --query 'Policy.Arn' \\\n    --output text)\n\n# Extract role name from ARN and attach policy\nROLE_NAME=$(echo $EXECUTION_ROLE | awk -F'/' '{print $NF}')\naws iam attach-role-policy \\\n    --role-name $ROLE_NAME \\\n    --policy-arn $POLICY_ARN\n\necho \"Policy created and attached: $POLICY_ARN\"\n\n# Cleanup\nrm agentcore-identity-policy.json\n</code></pre>"},{"location":"user-guide/identity/quickstart.html#step-4-invoke-the-agent","title":"Step 4: Invoke the agent!","text":"<p>Now that this is all set up, you can invoke the agent. For this demo, we will use the <code>agentcore invoke</code> command and our IAM credentials. We will need to pass the <code>--user-id</code> and <code>--session-id</code> arguments when using IAM authentication.</p> <p><code>agentcore invoke \"TestPayload\" --agent agentcoreidentityquickstart --user-id \"SampleUserID\" --session-id \"ALongThirtyThreeCharacterMinimumSessionIdYouCanChangeThisAsYouNeed\"</code></p> <p>The agent will then return a URL to your <code>agentcore invoke</code> command. Copy and paste that URL into your preferred browser, and you will then be redirected to your authorization server's login page. The <code>--user-id</code> parameter is the user ID you are presenting to AgentCore Identity. The <code>--session-id</code> parameter is the session ID, which must be at least 33 characters long.</p> <p>Enter the username and password for your user on your authorization server when prompted on your browser, or use your preferred authentication method you have configured. If you used the script from Step 0.5 to create a Cognito instance, you can retrieve this from your terminal history.</p> <p>Your browser should redirect you to the AgentCore Identity Success Page, and you should have a success message in your terminal</p> <p>Note that if you interrupt an invocation without completing authorization, you may need to request a new URL using a new session ID (<code>--session-id</code> parameter).</p>"},{"location":"user-guide/identity/quickstart.html#debugging","title":"Debugging","text":"<p>Should you encounter any errors or unexpected behaviors, the output of the agent is captured in CloudWatch logs. A log tailing command is provided after you run <code>agentcore launch</code></p>"},{"location":"user-guide/identity/quickstart.html#clean-up","title":"Clean Up","text":"<p>After you're done, you can delete the Cognito user pool, Amazon ECR repo, CodeBuild Project, IAM roles for the agent and CodeBuild project, and finally delete the agent, and credential provider.</p>"},{"location":"user-guide/identity/quickstart.html#security-best-practices","title":"Security Best Practices","text":"<p>When working with identity information:</p> <ol> <li>Never hardcode credentials in your agent code</li> <li>Use environment variables or AWS Secrets Manager for sensitive information</li> <li>Apply least privilege principle when configuring IAM permissions</li> <li>Regularly rotate credentials for external services</li> <li>Audit access logs to monitor agent activity</li> <li>Implement proper error handling for authentication failures</li> </ol>"},{"location":"user-guide/import-agent/configuration.html","title":"Import Agent Configuration Reference","text":"<p>This document provides detailed information about all configuration options available for the <code>import-agent</code> utility.</p>"},{"location":"user-guide/import-agent/configuration.html#command-syntax","title":"Command Syntax","text":"<pre><code>agentcore import-agent [OPTIONS]\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#configuration-options","title":"Configuration Options","text":""},{"location":"user-guide/import-agent/configuration.html#required-parameters","title":"Required Parameters","text":"<p>These parameters are required for the import process. If not provided via command line flags, the utility will prompt you interactively.</p>"},{"location":"user-guide/import-agent/configuration.html#-agent-id","title":"<code>--agent-id</code>","text":"<ul> <li>Type: String</li> <li>Description: ID of the Bedrock Agent to import</li> <li>Example: <code>--agent-id ABCD1234EFGH</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-agent-alias-id","title":"<code>--agent-alias-id</code>","text":"<ul> <li>Type: String</li> <li>Description: ID of the Agent Alias to use</li> <li>Example: <code>--agent-alias-id TSTALIASID</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-target-platform","title":"<code>--target-platform</code>","text":"<ul> <li>Type: String</li> <li>Options: <code>langchain</code>, <code>strands</code></li> <li>Description: Target platform for code generation</li> <li>Example: <code>--target-platform strands</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#optional-parameters","title":"Optional Parameters","text":""},{"location":"user-guide/import-agent/configuration.html#aws-configuration","title":"AWS Configuration","text":""},{"location":"user-guide/import-agent/configuration.html#-region","title":"<code>--region</code>","text":"<ul> <li>Type: String</li> <li>Description: AWS Region to use when fetching Bedrock Agents</li> <li>Default: Uses your default AWS configuration</li> <li>Example: <code>--region us-east-1</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#output-configuration","title":"Output Configuration","text":""},{"location":"user-guide/import-agent/configuration.html#-output-dir","title":"<code>--output-dir</code>","text":"<ul> <li>Type: String</li> <li>Description: Output directory for generated code</li> <li>Default: <code>./output/</code></li> <li>Example: <code>--output-dir ./my-agent</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#agentcore-primitives","title":"AgentCore Primitives","text":""},{"location":"user-guide/import-agent/configuration.html#-disable-memory","title":"<code>--disable-memory</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Memory primitive integration</li> <li>Default: <code>false</code> (Memory is enabled by default)</li> <li>Usage: <code>--disable-memory</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-disable-code-interpreter","title":"<code>--disable-code-interpreter</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Code Interpreter primitive integration</li> <li>Default: <code>false</code> (Code Interpreter is enabled by default)</li> <li>Usage: <code>--disable-code-interpreter</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-disable-observability","title":"<code>--disable-observability</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Observability primitive integration</li> <li>Default: <code>false</code> (Observability is enabled by default)</li> <li>Usage: <code>--disable-observability</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-disable-gateway","title":"<code>--disable-gateway</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Disable AgentCore Gateway primitive integration</li> <li>Default: <code>false</code> (Gateway is enabled by default)</li> <li>Usage: <code>--disable-gateway</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#deployment-options","title":"Deployment Options","text":""},{"location":"user-guide/import-agent/configuration.html#-deploy-runtime","title":"<code>--deploy-runtime</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Deploy the generated agent to AgentCore Runtime</li> <li>Default: <code>false</code></li> <li>Usage: <code>--deploy-runtime</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#-run-option","title":"<code>--run-option</code>","text":"<ul> <li>Type: String</li> <li>Options: <code>locally</code>, <code>runtime</code>, <code>none</code></li> <li>Description: How to run the agent after generation</li> <li>Default: Interactive prompt if not specified</li> <li>Examples:</li> <li><code>--run-option locally</code> - Run the agent on your local machine</li> <li><code>--run-option runtime</code> - Run on AgentCore Runtime (requires <code>--deploy-runtime</code>)</li> <li><code>--run-option none</code> - Generate code only, don't run</li> </ul>"},{"location":"user-guide/import-agent/configuration.html#debugging-options","title":"Debugging Options","text":""},{"location":"user-guide/import-agent/configuration.html#-verbose","title":"<code>--verbose</code>","text":"<ul> <li>Type: Boolean flag</li> <li>Description: Enable verbose output mode</li> <li>Default: <code>false</code></li> <li>Usage: <code>--verbose</code></li> </ul>"},{"location":"user-guide/import-agent/configuration.html#configuration-examples","title":"Configuration Examples","text":""},{"location":"user-guide/import-agent/configuration.html#basic-import","title":"Basic Import","text":"<pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#full-configuration-with-deployment","title":"Full Configuration with Deployment","text":"<pre><code>agentcore import-agent \\\n  --region us-west-2 \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id PRODALIASID \\\n  --target-platform langchain \\\n  --output-dir ./production-agent \\\n  --deploy-runtime \\\n  --run-option runtime \\\n  --verbose\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#minimal-setup-without-primitives","title":"Minimal Setup without Primitives","text":"<pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --disable-memory \\\n  --disable-code-interpreter \\\n  --disable-observability \\\n  --run-option none\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#debug-mode-for-troubleshooting","title":"Debug Mode for Troubleshooting","text":"<pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --output-dir ./debug-output\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#interactive-vs-non-interactive-mode","title":"Interactive vs Non-Interactive Mode","text":""},{"location":"user-guide/import-agent/configuration.html#interactive-mode","title":"Interactive Mode","text":"<p>When required parameters are missing, the utility enters interactive mode:</p> <pre><code>agentcore import-agent\n</code></pre> <p>This will prompt you for: - AWS Region selection - Agent selection from your available Bedrock Agents - Agent alias selection - Target platform choice - AgentCore primitives configuration - Deployment and run options</p>"},{"location":"user-guide/import-agent/configuration.html#non-interactive-mode","title":"Non-Interactive Mode","text":"<p>Provide all required parameters to run without prompts:</p> <pre><code>agentcore import-agent \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --deploy-runtime \\\n  --run-option runtime\n</code></pre>"},{"location":"user-guide/import-agent/configuration.html#default-behavior","title":"Default Behavior","text":"Option Default Value Behavior Memory Enabled AgentCore Memory primitive is integrated Code Interpreter Enabled AgentCore Code Interpreter primitive is integrated Observability Enabled AgentCore Observability primitive is integrated Gateway Enabled AgentCore Gateway is not used as a proxy to AG Lambdas Deployment Disabled Generated code is not deployed to runtime Output Directory <code>./output/</code> Code is generated in this directory Verbose Mode Disabled Standard output level"},{"location":"user-guide/import-agent/configuration.html#environment-variables","title":"Environment Variables","text":"<p>The utility respects standard AWS environment variables:</p> <ul> <li><code>AWS_REGION</code> - Default region for AWS operations</li> <li><code>AWS_PROFILE</code> - AWS profile to use</li> <li><code>AWS_ACCESS_KEY_ID</code> / <code>AWS_SECRET_ACCESS_KEY</code> - AWS credentials</li> </ul>"},{"location":"user-guide/import-agent/configuration.html#configuration-file-support","title":"Configuration File Support","text":"<p>Currently, the import-agent utility does not support configuration files. All options must be provided via command line flags or interactive prompts.</p>"},{"location":"user-guide/import-agent/configuration.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/import-agent/configuration.html#common-issues","title":"Common Issues","text":"<p>Missing AWS Permissions Use ADA or the AWS CLI to authenticate. Ensure that you have environment variables for your AWS credentials and these can be used by Boto3 appropriately.</p> <p>Agent Not Found <pre><code># Verify your agent ID and region\nagentcore import-agent --region us-east-1 --agent-id YOUR_AGENT_ID\n</code></pre></p> <p>Output Directory Issues <pre><code># Specify a custom output directory\nagentcore import-agent --output-dir ./custom-path\n</code></pre></p>"},{"location":"user-guide/import-agent/design.html","title":"Import Agent Design","text":"<p>Design overview for the import-agent utility, explaining the choices behind the generated agent.</p>"},{"location":"user-guide/import-agent/design.html#utility-feature-support","title":"Utility Feature Support","text":"<p>Below is each feature of Bedrock Agents and which of the features this utility successfully maps to each target framework. We also describe which AgentCore Primitive is used to enhance each feature mapping.</p> Bedrock Agent Feature AgentCore + Langchain AgentCore + Strands Notes Action Groups SUPPORTED SUPPORTED Uses AgentCore Gateway Orchestration SUPPORTED SUPPORTED Guardrails SUPPORTED SUPPORTED Knowledge Bases SUPPORTED SUPPORTED Code Interpreter SUPPORTED SUPPORTED Uses AgentCore Code Interpreter Short Term Memory SUPPORTED SUPPORTED Long Term Memory SUPPORTED SUPPORTED Uses AgentCore Memory Pre/Post Processing Step SUPPORTED SUPPORTED User Input SUPPORTED SUPPORTED Traces SUPPORTED SUPPORTED Uses AgentCore Observability Multi-Agent Collaboration SUPPORTED SUPPORTED"},{"location":"user-guide/import-agent/design.html#action-groups-agentcore-gateway-target","title":"Action Groups \u2192 AgentCore Gateway Target","text":"<p>In Bedrock Agents, users can define Action Groups for their agents. An Action Group is a collection of tools that are either executed via AWS Lambda or through a local callback (Return of Control). These tools are defined using either an OpenAPI specification or a structured function schema. At runtime, Bedrock Agents call your Lambda function with an event formatted according to the schema you selected. The structure of this event is documented here: AWS Bedrock Lambda integration.</p> <p>In AgentCore Gateway, we create one gateway per generated agent. Each Action Group in Bedrock Agents maps to a target in the gateway. Within each target, every function or path/method becomes a tool. To ensure compatibility with existing Action Group Lambda functions, we use a proxy Lambda function as the executor for all tools in the gateway. This proxy:</p> <ol> <li>Receives tool calls in the Gateway's format.</li> <li>Identifies the correct Action Group Lambda to invoke.</li> <li>Reformats the request object to match the expected format.</li> <li>Calls the appropriate Lambda and returns the result in a Gateway-compatible format.</li> </ol> <p>If AgentCore Gateway is disabled, the system generates local tools instead:</p> <ul> <li>Each function or path/method becomes a separate tool.</li> <li>The tool\u2019s argument schema is exposed to the agent via Pydantic model generation.</li> <li>Each tool formats its request correctly and calls the corresponding Action Group Lambda directly.</li> </ul> <p>This approach also applies to Return of Control (ROC) action groups, where the tool prompts the user for input locally before proceeding with execution.</p>"},{"location":"user-guide/import-agent/design.html#orchestration","title":"Orchestration","text":"<p>For orchestration, the Bedrock Agents prompt are constructed at runtime, by substituting in template fixtures (ie. variables in the prompt). For example, the orchestration prompt may have the fixture called knowledge_base_guidelines. This variable is filled in depending on the model provider and model version in use.</p> <p>To approximate the same behavior and deliver translated agents that are functionally equivalent, the utility uses ONE collection of template fixtures (<code>template_fixtures_merged.json</code>) and substitutes them in to build the correct prompts. As for orchestration strategy, for both Langchain and Strands, the utility uses the standard ReAcT orchestration pattern.</p>"},{"location":"user-guide/import-agent/design.html#guardrails","title":"Guardrails","text":"<p>In Bedrock Agents, users can add Bedrock Guardrails to their agent. This applies the guardrail on the model level and Bedrock Agents will have defined behavior for when a guardrail is invoked to redact or block an input. Equivalently, the utility applies the same guardrail on Bedrock models, as there is support for this in both Langchain and Strands.</p>"},{"location":"user-guide/import-agent/design.html#knowledge-bases","title":"Knowledge Bases","text":"<p>In Bedrock Agents, users can add existing Knowledge Bases (defined via Bedrock Knowledge Bases) to their agent via the Console or SDK. The AgentCore + Langchain/Strands equivalent of this feature is to use each of those KBs to define a KB retrieval tool for an agent to use. This tool uses the AWS SDK to retrieve from connected knowledge bases using a query decided by the agent and then returns the document results for the agent to use.</p>"},{"location":"user-guide/import-agent/design.html#code-interpreter-agentcore-code-interpreter","title":"Code Interpreter \u2192 AgentCore Code Interpreter","text":"<p>In Bedrock Agents, users can enable Code Interpreter. This gives a Bedrock Agent access to a sandbox for it to write, troubleshoot, and return the output of code.</p> <p>We use AgentCore Code Interpreter for an equivalent experience. The utility defines a <code>code_tool</code> which creates a code sandbox session and defines a sub-agent with access to code interpreter operations (as tools). These operations include executing code, writing/removing files, and more. This sub-agent is fed the code tool's input query and runs in a loop using the sandbox operations to accomplish the coding task and return the output.</p> <p>When AgentCore Code Interpreter is opted-out, we use open-interpreter, an open source and local code interpreter that can write, execute, and troubleshoot code.</p>"},{"location":"user-guide/import-agent/design.html#short-term-memory","title":"Short Term Memory","text":"<p>In Bedrock Agents, by default, agents have short term memory of an entire session\u2019s messages. This means that the user can ask any number of questions within a session, with the agent keeping earlier messages from that session in its context.</p> <p>The utility will use an in-memory saver as a solution for this. In Langchain, we use an in-memory store to save the session\u2019s messages in a thread for that session. In Strands, we use a Sliding Conversation Manager, which can maintain in-memory context of any number of earlier messages in a session.</p>"},{"location":"user-guide/import-agent/design.html#long-term-memory-agentcore-memory","title":"Long Term Memory \u2192 AgentCore Memory","text":"<p>In Bedrock Agents, users can enable Long Term Memory for their agent. This is based on session summarization, where BR Agents uses an LLM to summarize the conversation\u2019s discussion topics based on a session\u2019s messages. This occurs on the end of each session, and customers can configure a max number of sessions and max days threshold to keep the summaries. In the orchestration prompt in BR agents, a synopsis of the long-term memory, consisting of multiple of these session summaries, is injected.</p> <p>In Bedrock Agents, users can enable Long-Term Memory for their agents. This system is based on session summarization, where Bedrock Agents use an LLM to summarize discussion topics from each session\u2019s messages.</p> <ul> <li>Summarization happens at the end of each session.</li> <li>Customers can configure:<ul> <li>The maximum number of sessions to retain.</li> <li>A maximum age (in days) for how long to keep the summaries.</li> </ul> </li> <li>During orchestration, Bedrock Agents inject a synopsis of long-term memory\u2014which consists of multiple session summaries\u2014into the system prompt.</li> </ul> <p>In AgentCore Memory, the utility implements a similar memory model using a summarization strategy with a dedicated memory store:</p> <pre><code>{\n    \"summaryMemoryStrategy\": {\n        \"name\": \"SessionSummarizer\",\n        \"namespaces\": [\"/summaries/{actorId}/{sessionId}\"],\n    }\n}\n</code></pre> <p>On each entrypoint invocation, formatted messages are saved to this memory store by generating an event that includes the correct <code>userId</code> and <code>sessionId</code> (both provided to the entrypoint). During agent initialization (inside the <code>get_agent</code> loop in the output code), the top session summaries are retrieved from the memory store and formatted to match the Bedrock Agents' memory style. These formatted summaries are then injected into the agent's system prompt as a memory synopsis.</p> <p>If AgentCore Memory is opted out, then we replicate the behavior with a local long term memory manager, which uses a memory summarization LLM and the memory summarization BR agents prompt to create and manage session summaries. The generated summaries are saved and maintained in a local session summaries JSON file.</p>"},{"location":"user-guide/import-agent/design.html#prepost-processing-step","title":"Pre/Post-Processing Step","text":"<p>In Bedrock Agents, customers can enable and override pre-processing and post-processing steps in their agents. These steps are meant to be taken at the start and end, respectively, of agent invocation.</p> <p>If the pre-processing step is enabled, then within the <code>invoke_agent</code> function, the utility will use the pre-processing prompt on the user query and append the output to the query before passing this on to the orchestration loop. If the post-processing step is enabled, then the post-processing prompt is used on the orchestration loop output, and this result is returned as the output of <code>invoke_agent</code>.</p>"},{"location":"user-guide/import-agent/design.html#user-input","title":"User Input","text":"<p>In Bedrock Agents, an agent can ask for human input. This may be for clarification or to ask for missing parameters for a tool call. If enabled, the utility will create a human input tool, which can be invoked with a question by the agent and asks the user for CLI input on that question. This answer is then returned to the agent as the tool\u2019s output.</p>"},{"location":"user-guide/import-agent/design.html#traces-agentcore-observability","title":"Traces \u2192 AgentCore Observability","text":"<p>In Bedrock Agents, users can view traces that describe pre/post processing steps, routing classifier steps, guardrail invocation, agent orchestration, and other information. These traces are in a format specific to Bedrock Agents, and can be viewed either in the console or as output of an invoke_agent call to a BR agent.</p> <p>The equivalent for this with AgentCore is to use AgentCore Observability (if not opted-out). For both Langchain and Strands, the agent will output OTEL logs on a session, trace, and span level. These logs are captured by AgentCore Observability when the agent is deployed to AgentCore Runtime, and the logs will be visible in CloudWatch under the GenAI Observability section.</p>"},{"location":"user-guide/import-agent/design.html#multi-agent-collaboration","title":"Multi-Agent Collaboration","text":"<p>In Bedrock Agents, users can promote an agent and add collaborators to it. This hierarchy can be up to 5 levels deep. A collaborator can receive shared conversation history from the parent, and can be invoked with routing mode (parent uses a routing classifier prompt to find a relevant collaborator for a user query) or supervisor mode (an agents-as-tools approach).</p> <p>The utility's approach to this is to recursively translate a parent agent and its children, and then orchestrate them together via an Agents-as-Tools approach by default. If conversation sharing is enabled, then the parent will inject its state into the child's via these collaboration tools. If routing mode is enabled for the parent, then the parent agent uses a routing classifier prompt, before orchestration, to invoke a relevant child agent. In AgentCore Runtime, the code for a parent agent and its children are packaged together, in the same container image, to enable this setup.</p>"},{"location":"user-guide/import-agent/overview.html","title":"Import Agent Overview","text":"<p>The <code>import-agent</code> utility enables you to migrate existing Amazon Bedrock Agents to Bedrock AgentCore, converting them into framework-specific implementations while leveraging AgentCore's enterprise-grade primitives.</p> <p>Note Use the output agent definition as a starting point for your custom agent implementation. Review the generated code, evaluate agent behavior, and make necessary changes before deploying. Extend the agent with additional tools, memory, and other features as required.</p> <p>Note Use the output agent definition as a starting point for your custom agent implementation. Review the generated code, evaluate agent behavior, and make necessary changes before deploying. Extend the agent with additional tools, memory, and other features as required.</p>"},{"location":"user-guide/import-agent/overview.html#what-is-import-agent","title":"What is Import Agent?","text":"<p>The import-agent utility automates the process of:</p> <ol> <li>Fetching your existing Bedrock Agent configuration</li> <li>Converting it to LangChain/LangGraph or Strands framework code</li> <li>Integrating AgentCore primitives (Memory, Code Interpreter, Observability, Gateway)</li> <li>Integrating AgentCore primitives (Memory, Code Interpreter, Observability, Gateway)</li> <li>Deploying to AgentCore Runtime (optional)</li> </ol>"},{"location":"user-guide/import-agent/overview.html#key-benefits","title":"Key Benefits","text":"<ul> <li>Framework Flexibility: Convert to LangChain/LangGraph or Strands</li> <li>Zero Infrastructure: Leverage AgentCore's serverless platform</li> <li>Enhanced Capabilities: Add Memory, Code Interpreter, and Observability</li> <li>Production Ready: Deploy directly to AgentCore Runtime</li> <li>Preserved Logic: Maintains your agent's core functionality</li> </ul>"},{"location":"user-guide/import-agent/overview.html#supported-target-platforms","title":"Supported Target Platforms","text":""},{"location":"user-guide/import-agent/overview.html#langchain-langgraph","title":"LangChain + LangGraph","text":"<p>Perfect for teams already using the LangChain ecosystem or those looking for extensive third-party integrations.</p>"},{"location":"user-guide/import-agent/overview.html#strands","title":"Strands","text":"<p>Ideal for teams wanting AWS-native agent development with streamlined patterns.</p>"},{"location":"user-guide/import-agent/overview.html#generated-output","title":"Generated Output","text":"<p>The utility generates an agent implementation including:</p> <ul> <li>Agent Code: Framework-specific implementation of your Bedrock Agent</li> <li>Dependencies: All required packages and versions</li> <li>Configuration: Environment setup and deployment configuration</li> <li>AgentCore Integration: Memory, Code Interpreter, and Observability primitives</li> </ul>"},{"location":"user-guide/import-agent/overview.html#migration-workflow","title":"Migration Workflow","text":"<pre><code>flowchart TD\n    A[Existing Bedrock Agent] --&gt; B[Import Agent Utility]\n    B --&gt; C{Select Target Platform}\n    C --&gt; D[LangChain/LangGraph]\n    C --&gt; E[Strands]\n    D --&gt; F[Generate Agent Code]\n    E --&gt; F\n    F --&gt; G{Deploy to Runtime?}\n    G --&gt;|Yes| H[AgentCore Runtime]\n    G --&gt;|No| I[Local Development]</code></pre>"},{"location":"user-guide/import-agent/overview.html#feature-support","title":"Feature Support","text":"Bedrock Agent Feature Langchain Strands AgentCore Guardrails SUPPORTED SUPPORTED Orchestration (via reAct) SUPPORTED SUPPORTED Knowledge Bases SUPPORTED SUPPORTED Code Interpreter SUPPORTED SUPPORTED SUPPORTED: 1P Code Interpreter Lambda Function Definitions SUPPORTED SUPPORTED SUPPORTED: AgentCore Gateway Lambda OpenAPI Definitions SUPPORTED SUPPORTED SUPPORTED: AgentCore Gateway Return of Control SUPPORTED SUPPORTED Short Term (Conversational) Memory SUPPORTED SUPPORTED Long Term (Cross-Session) Memory SUPPORTED SUPPORTED SUPPORTED: AgentCore Memory Session Summarization SUPPORTED SUPPORTED SUPPORTED: AgentCore Memory Pre Processing Step SUPPORTED SUPPORTED Post Processing Step SUPPORTED SUPPORTED KB Generation Routing/Optimizations SUPPORTED SUPPORTED Idle Timeouts SUPPORTED SUPPORTED User Input (as a tool) SUPPORTED SUPPORTED Traces SUPPORTED SUPPORTED SUPPORTED: AgentCore Observability Multi-Agent Collaboration - Supervisor Mode SUPPORTED SUPPORTED Multi-Agent Collaboration - Routing Mode SUPPORTED SUPPORTED Multi-Agent Collaboration - Conversation Relay SUPPORTED SUPPORTED Custom Bedrock Model Usage SUPPORTED SUPPORTED Chat Interface (via CLI) SUPPORTED SUPPORTED Custom Inference Configurations SUPPORTED SUPPORTED Agent Deployment N/A N/A SUPPORTED: AgentCore Runtime Lambda Parsing and Orchestration N/A N/A"},{"location":"user-guide/import-agent/overview.html#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started in 5 minutes</li> <li>Configuration Reference - Detailed parameter guide</li> <li>Design Choices - Details on the design of the generated agent</li> <li>Design Choices - Details on the design of the generated agent</li> </ul>"},{"location":"user-guide/import-agent/quickstart.html","title":"Import Agent Quick Start","text":"<p>Get started with importing your Bedrock Agent to AgentCore in just a few minutes.</p>"},{"location":"user-guide/import-agent/quickstart.html#prerequisites","title":"Prerequisites","text":"<ul> <li>AWS credentials configured with access to Bedrock Agents</li> <li>Use <code>ada</code> or <code>aws configure</code> to ensure that your credentials are available for the utility to assume.</li> <li>Bedrock AgentCore Starter Toolkit installed</li> <li>An existing Amazon Bedrock Agent</li> </ul>"},{"location":"user-guide/import-agent/quickstart.html#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/import-agent/quickstart.html#interactive-mode-recommended","title":"Interactive Mode (Recommended)","text":"<p>The simplest way to get started is with interactive mode:</p> <pre><code>agentcore import-agent\n</code></pre> <p>The utility will guide you through:</p> <ol> <li>Agent Selection: Choose your Bedrock Agent and alias</li> <li>Target Platform: Select LangChain/LangGraph or Strands</li> <li>AgentCore Primitives: Configure Memory, Code Interpreter, Observability</li> <li>Deployment Options: Deploy to AgentCore Runtime or run locally</li> </ol>"},{"location":"user-guide/import-agent/quickstart.html#command-line-mode","title":"Command Line Mode","text":"<p>For automation or when you know your parameters:</p> <pre><code>agentcore import-agent \\\n  --region us-east-1 \\\n  --agent-id ABCD1234 \\\n  --agent-alias-id TSTALIASID \\\n  --target-platform strands \\\n  --output-dir ./my-agent \\\n  --deploy-runtime \\\n  --run-option runtime\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#step-by-step-walkthrough","title":"Step-by-Step Walkthrough","text":""},{"location":"user-guide/import-agent/quickstart.html#1-launch-the-import-utility","title":"1. Launch the Import Utility","text":"<pre><code>agentcore import-agent\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#2-configure-aws-region","title":"2. Configure AWS Region","text":"<pre><code>? Select AWS Region: us-east-1\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#3-select-your-agent","title":"3. Select Your Agent","text":"<p>The utility will list your available Bedrock Agents in the selected region:</p> <pre><code>? Select Bedrock Agent:\n  &gt; my-customer-service-agent (ID: ABCD1234)\n    my-research-agent (ID: EFGH5678)\n    my-code-assistant (ID: IJKL9012)\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#4-choose-agent-alias","title":"4. Choose Agent Alias","text":"<pre><code>? Select Agent Alias:\n  &gt; TSTALIASID (Test)\n    PRODALIASID (Production)\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#5-select-target-platform","title":"5. Select Target Platform","text":"<pre><code>? Choose target platform:\n  &gt; strands (1.0.x)\n    langchain (0.3.x) + langgraph (0.5.x)\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#7-deployment-options","title":"7. Deployment Options","text":"<pre><code>? Deploy to AgentCore Runtime? [y/N]: Y\n? How would you like to run the agent?\n  &gt; Run on AgentCore Runtime\n    Install dependencies and run locally\n    Don't run now\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#generated-output","title":"Generated Output","text":"<p>After completion, you'll find:</p> <pre><code>./output/\n\u251c\u2500\u2500 strands_agent.py          # Your converted agent\n\u251c\u2500\u2500 requirements.txt          # Dependencies\n\u251c\u2500\u2500 .agentcore-config.yaml   # Deployment configuration\n\u2514\u2500\u2500 README.md                # Generated documentation\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#testing-your-agent","title":"Testing Your Agent","text":""},{"location":"user-guide/import-agent/quickstart.html#local-testing","title":"Local Testing","text":"<pre><code>cd ./output\npython -m pip install -r requirements.txt\npython strands_agent.py\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#agentcore-runtime-testing","title":"AgentCore Runtime Testing","text":"<p>If deployed to runtime:</p> <pre><code>cd ./output\nagentcore invoke \"Hello, test message\"\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#common-options","title":"Common Options","text":""},{"location":"user-guide/import-agent/quickstart.html#enable-debug-mode","title":"Enable Debug Mode","text":"<p>Get detailed logging in the output agent:</p> <pre><code>agentcore import-agent --debug\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#disable-specific-primitives","title":"Disable Specific Primitives","text":"<p>Skip certain AgentCore features:</p> <pre><code>agentcore import-agent \\\n  --disable-memory \\\n  --disable-code-interpreter\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#custom-output-directory","title":"Custom Output Directory","text":"<p>Specify where to generate files:</p> <pre><code>agentcore import-agent --output-dir ./my-custom-agent\n</code></pre>"},{"location":"user-guide/import-agent/quickstart.html#next-steps","title":"Next Steps","text":"<ul> <li>Review Generated Code: Examine the converted agent implementation</li> <li>Test Functionality: Verify your agent works as expected</li> <li>Customize Integration: Add custom AgentCore primitive configurations</li> <li>Production Deployment: Deploy to AgentCore Runtime for production usage</li> </ul> <p>For detailed configuration options, see the Configuration Reference.</p>"},{"location":"user-guide/memory/quickstart.html","title":"Getting Started with AgentCore Memory","text":"<p>Amazon Bedrock AgentCore Memory lets you create and manage memory resources that store conversation context for your AI agents. This section guides you through installing dependencies and implementing both short-term and long-term memory features.</p> <p>The steps are as follows</p> <ol> <li>Create a memory resource containing a semantic strategy</li> <li>Write events (conversation history) to the memory resource.</li> <li>Retrieve memory records from long term memory</li> </ol>"},{"location":"user-guide/memory/quickstart.html#prerequisites","title":"Prerequisites","text":""},{"location":"user-guide/memory/quickstart.html#before-starting-make-sure-you-have","title":"Before starting, make sure you have:","text":"<ul> <li>AWS Account with credentials configured (<code>aws configure</code>)</li> <li>Python 3.10+ installed</li> </ul> <p>To get started with Amazon Bedrock AgentCore Memory, make a folder for this quick start, create a virtual environment, and install the dependencies. The below command can be run directly in the terminal.</p> <pre><code>mkdir agentcore-memory-quickstart\ncd agentcore-memory-quickstart\npython -m venv .venv\nsource .venv/bin/activate\npip install bedrock-agentcore\npip install bedrock-agentcore-starter-toolkit\n</code></pre> <p>Note: The AgentCore Starter Toolkit is intended to help developers get started quickly. For the complete set of AgentCore Memory operations, see the Boto3 documentation: bedrock-agentcore-control and bedrock-agentcore.</p> <p>Full example: See the complete code example that demonstrates steps 1-3.</p>"},{"location":"user-guide/memory/quickstart.html#step-one-create-a-memory-resource","title":"Step One: Create a Memory Resource","text":"<p>A memory resource is needed to start storing information for your agent. By default, memory events (which we refer to as short-term memory) can be written to a memory resource. In order for insights to be extracted and placed into long term memory records, the resource requires a 'memory strategy' - a configuration that defines how conversational data should be processed, and what information to extract (such as facts, preferences, or summaries).</p> <p>We are going to create a memory resource with a semantic strategy so that both short term and long term memory can be utilized. This will take 2-3 minutes. Memory resources can also be created in the AWS console.</p> <pre><code>from bedrock_agentcore_starter_toolkit.operations.memory.manager import MemoryManager\nfrom bedrock_agentcore.memory.session import MemorySessionManager\nfrom bedrock_agentcore.memory.constants import ConversationalMessage, MessageRole\nfrom bedrock_agentcore_starter_toolkit.operations.memory.models.strategies import SemanticStrategy\nimport time\n\nmemory_manager = MemoryManager(region_name=\"us-west-2\")\n\nprint(\"Creating memory resource...\")\n\nmemory = memory_manager.get_or_create_memory(\n    name=\"CustomerSupportSemantic\",\n    description=\"Customer support memory store\",\n    strategies=[\n        SemanticStrategy(\n            name=\"semanticLongTermMemory\",\n            namespaces=['/strategies/{memoryStrategyId}/actors/{actorId}'],\n        )\n    ]\n)\n\nprint(f\"Memory ID: {memory.get('id')}\")\n</code></pre> <p>You can call list_memories to see that the memory resource has been created with:</p> <pre><code>memories = memory_manager.list_memories()\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#step-two-write-events-to-memory","title":"Step Two: Write events to memory","text":"<p>Writing events to memory has multiple purposes. First, event contents (most commonly conversation history) are stored as short term memory. Second, relevant insights are pulled from events and written into memory records as a part of long term memory.</p> <p>The memory resource id, actor id, and session id are required to create an event. We are going to create three events, simulating messages between an end user and a chat bot.</p> <pre><code># Create a session to store memory events\nsession_manager = MemorySessionManager(\n    memory_id=memory.get(\"id\"),\n    region_name=\"us-west-2\")\n\nsession = session_manager.create_memory_session(\n    actor_id=\"User1\",\n    session_id=\"OrderSupportSession1\"\n)\n\n# Write memory events (conversation turns)\nsession.add_turns(\n    messages=[\n        ConversationalMessage(\n            \"Hi, how can I help you today?\",\n            MessageRole.ASSISTANT)],\n)\n\nsession.add_turns(\n    messages=[\n        ConversationalMessage(\n            \"Hi, I am a new customer. I just made an order, but it hasn't arrived. The Order number is #35476\",\n            MessageRole.USER)],\n)\n\nsession.add_turns(\n    messages=[\n        ConversationalMessage(\n            \"I'm sorry to hear that. Let me look up your order.\",\n            MessageRole.ASSISTANT)],\n)\n</code></pre> <p>You can get events (turns) for a specific actor after they\u2019ve been written.</p> <pre><code># Get the last k turns in the session\nturns = session.get_last_k_turns(k=5)\n\nfor turn in turns:\n    print(f\"Turn: {turn}\")\n</code></pre> <p>In this case, we can see the last three events for the actor and session.</p>"},{"location":"user-guide/memory/quickstart.html#step-three-retrieve-records-from-long-term-memory","title":"Step Three: Retrieve records from long term memory","text":"<p>After the events were written to the memory resource, they were analyzed and useful information was sent to long term memory. Since the memory contains a semantic long term memory strategy, the system extracts and stores factual information.</p> <p>You can list all memory records with:</p> <pre><code># List all memory records\nmemory_records = session.list_long_term_memory_records(\n    namespace_prefix=\"/\"\n)\n\nfor record in memory_records:\n    print(f\"Memory record: {record}\")\n    print(\"--------------------------------------------------------------------\")\n</code></pre> <p>Or ask for the most relevant information as part of a semantic search:</p> <pre><code># Perform a semantic search\nmemory_records = session.search_long_term_memories(\n    query=\"can you summarize the support issue\",\n    namespace_prefix=\"/\",\n    top_k=3\n)\n</code></pre> <p>Important information about the user is likely stored is long term memory. Agents can use long term memory rather than a full conversation history to make sure that LLMs are not overloaded with context.</p>"},{"location":"user-guide/memory/quickstart.html#cleanup","title":"Cleanup","text":"<p>When you're done with the memory resource, you can delete it:</p> <pre><code># Delete the memory resource\nmemory_manager.delete_memory(memory_id=memory.get(\"id\"))\n</code></pre>"},{"location":"user-guide/memory/quickstart.html#whats-next","title":"What\u2019s Next?","text":"<p>Consider the following as you continue your AgentCore journey</p> <ul> <li>Add another strategy to your memory resource</li> <li>Enable observability for more visibility into how memory is working</li> <li>Look at the vast collection of samples to familiarize yourself with other use cases.</li> </ul>"},{"location":"user-guide/observability/quickstart.html","title":"Getting Started with AgentCore Observability","text":"<p>Amazon Bedrock AgentCore Observability helps you trace, debug, and monitor agent performance in production environments. This guide will help you get started with implementing observability features in your agent applications.</p>"},{"location":"user-guide/observability/quickstart.html#what-is-agentcore-observability","title":"What is AgentCore Observability?","text":"<p>AgentCore Observability provides:</p> <ul> <li>Detailed visualizations of each step in the agent workflow</li> <li>Real-time visibility into operational performance through CloudWatch dashboards</li> <li>Telemetry for key metrics such as session count, latency, duration, token usage, and error rates</li> <li>Rich metadata tagging and filtering for issue investigation</li> <li>Standardized OpenTelemetry (OTEL)-compatible format for easy integration with existing monitoring stacks</li> <li>Flexibility to be used with all AI agent frameworks and any large language model</li> </ul>"},{"location":"user-guide/observability/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have:</p> <ul> <li>AWS Account with credentials configured (<code>aws configure</code>) with model access enabled to the Foundation Model you would like to use.</li> <li>Python 3.10+ installed</li> <li>Enable transaction search on Amazon CloudWatch. Only once, first-time users must enable CloudWatch Transaction Search to view Bedrock AgentCore spans and traces</li> <li>Add the OpenTelemetry library Include <code>aws-opentelemetry-distro</code> (ADOT) in your requirements.txt file.</li> <li>Ensure that your framework is configured to emit traces (eg. <code>strands-agents[otel]</code> package), you may sometimes need to include <code>&lt;your-agent-framework-auto-instrumentor&gt;</code> # e.g., <code>opentelemetry-instrumentation-langchain</code></li> </ul> <p>AgentCore Observability offers two ways to configure monitoring to match different infrastructure needs: 1. AgentCore Runtime-hosted agents 2. Non-runtime hosted agents</p> <p>As a one time setup per account, first time users would need to enable Transaction Search on Amazon CloudWatch. There are two ways to do this, via the API and via the CloudWatch Console.</p>"},{"location":"user-guide/observability/quickstart.html#enabling-transaction-search-on-cloudwatch","title":"Enabling Transaction Search on CloudWatch","text":"<p>After you enable Transaction Search, it can take ten minutes for spans to become available for search and analysis. Please choose one of the options below:</p>"},{"location":"user-guide/observability/quickstart.html#option-1-enabling-transaction-search-using-an-api","title":"Option 1 : Enabling Transaction Search using an API","text":"<p>Step 1: Create a policy that grants access to ingest spans in CloudWatch Logs using AWS CLI</p> <p>An example is shown below on how to format your AWS CLI command with PutResourcePolicy.</p> <pre><code>aws logs put-resource-policy --policy-name MyResourcePolicy --policy-document '{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"TransactionSearchXRayAccess\", \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"xray.amazonaws.com\" }, \"Action\": \"logs:PutLogEvents\", \"Resource\": [ \"arn:partition:logs:region:account-id:log-group:aws/spans:*\", \"arn:partition:logs:region:account-id:log-group:/aws/application-signals/data:*\" ], \"Condition\": { \"ArnLike\": { \"aws:SourceArn\": \"arn:partition:xray:region:account-id:*\" }, \"StringEquals\": { \"aws:SourceAccount\": \"account-id\" } } } ]}'\n</code></pre> <p>Step 2: Configure the destination of trace segments</p> <p>An example is shown below on how to format your AWS CLI command with UpdateTraceSegmentDestination.</p> <pre><code>aws xray update-trace-segment-destination --destination CloudWatchLogs\n</code></pre> <p>Optional Step : Configure the amount of spans to index</p> <p>Configure your desired sampling percentage with UpdateIndexingRule.</p> <pre><code>aws xray update-indexing-rule --name \"Default\" --rule '{\"Probabilistic\": {\"DesiredSamplingPercentage\": number}}'\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#option-2-enabling-transaction-search-in-the-cloudwatch-console","title":"Option 2: Enabling Transaction Search in the CloudWatch console","text":"<ul> <li>Open the CloudWatch console at https://console.aws.amazon.com/cloudwatch/.</li> <li>From the navigation pane, under Application Signals, choose Transaction Search.</li> <li>Choose Enable Transaction Search.</li> <li>Select the box to ingest spans as structured logs, and enter a percentage of spans to be indexed. You can index spans at 1% for free and change the percentage later based on your requirements.</li> </ul> <p>Let's now proceed to exploring the two ways to configure observability.</p>"},{"location":"user-guide/observability/quickstart.html#enabling-observability-for-agentcore-runtime-hosted-agents","title":"Enabling Observability for AgentCore Runtime hosted Agents","text":"<p>AgentCore Runtime-hosted agents are deployed and executed directly within the AgentCore environment, providing automatic instrumentation with minimal configuration. This approach offers the fastest path to deployment and is ideal for rapid development and testing.</p> <p>For a complete example please refer to this notebook</p>"},{"location":"user-guide/observability/quickstart.html#step-0-setup-folder-and-virtual-environment","title":"Step 0: Setup folder and virtual environment","text":"<p>Create a new folder for this quickstart, create and initialize a new python virtual environment</p> <pre><code>mkdir agentcore-observability-quickstart\ncd agentcore-observability-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-1-create-your-agent-shown-below-is-an-example-with-strands-agents-sdk","title":"Step 1 : Create your Agent, shown below is an example with Strands Agents SDK:","text":"<p>To enable OTEL exporting, please note to install Strands Agents with otel extra dependencies:</p> <pre><code>pip install 'strands-agents[otel]'\n</code></pre> <p>Highlighted below are the steps to host a strands agent on AgentCore Runtime to get started:</p> <pre><code>##  Save this as strands_claude.py\nfrom strands import Agent, tool\nfrom strands_tools import calculator # Import the calculator tool\nimport argparse\nimport json\nfrom bedrock_agentcore.runtime import BedrockAgentCoreApp\nfrom strands.models import BedrockModel\n\napp = BedrockAgentCoreApp()\n\n# Create a custom tool\n@tool\ndef weather():\n    \"\"\" Get weather \"\"\" # Dummy implementation\n    return \"sunny\"\n\n\nmodel_id = \"us.anthropic.claude-3-7-sonnet-20250219-v1:0\"\nmodel = BedrockModel(\n    model_id=model_id,\n)\nagent = Agent(\n    model=model,\n    tools=[calculator, weather],\n    system_prompt=\"You're a helpful assistant. You can do simple math calculation, and tell the weather.\"\n)\n\n@app.entrypoint\ndef strands_agent_bedrock(payload):\n    \"\"\"\n    Invoke the agent with a payload\n    \"\"\"\n    user_input = payload.get(\"prompt\")\n    print(\"User input:\", user_input)\n    response = agent(user_input)\n    return response.message['content'][0]['text']\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-2-deploy-and-invoke-your-agent-on-agentcore-runtime","title":"Step 2 : Deploy and invoke your Agent on AgentCore Runtime","text":"<p>Now that you created an agent ready to be hosted on AgentCore runtime, you can easily deploy it using the <code>bedrock_agentcore_starter_toolkit</code> package as shown below :</p> <pre><code>from bedrock_agentcore_starter_toolkit import Runtime\nfrom boto3.session import Session\nboto_session = Session()\nregion = boto_session.region_name\n\nagentcore_runtime = Runtime()\nagent_name = \"strands_claude_getting_started\"\nresponse = agentcore_runtime.configure(\n    entrypoint=\"strands_claude.py\", # file created in Step 1\n    auto_create_execution_role=True,\n    auto_create_ecr=True,\n    requirements_file=\"requirements.txt\", # ensure aws-opentelemetry-distro exists along with your libraries required to run your agent\n    region=region,\n    agent_name=agent_name\n)\n\nlaunch_result = agentcore_runtime.launch()\nlaunch_result\n</code></pre> <p>In these simple steps you deployed your strands agent on runtime with the Bedrock agentcore starter toolkit that automaticcally instruments your agent invocation using Open Telemetry. Now, you can invoke your agent using the command shown below and see the Traces, sessions and metrics on GenAI Obsrvability dashboard on Amazon Cloudwatch.</p> <pre><code>invoke_response = agentcore_runtime.invoke({\"prompt\": \"How is the weather now?\"})\ninvoke_response\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#enabling-observability-for-non-agentcore-hosted-agents","title":"Enabling Observability for Non-AgentCore-Hosted Agents","text":"<p>For agents running outside of the AgentCore runtime, deliver the same monitoring capabilities for agents deployed on your own infrastructure, allowing consistent observability regardless of where your agents run. Additionally, you would need to  follow the steps below to configure the environment variables needed to observe your agents.</p> <p>For a complete example please refer to this notebook</p>"},{"location":"user-guide/observability/quickstart.html#step-1-configure-aws-environment-variables","title":"Step 1: Configure AWS Environment Variables","text":"<pre><code>export AWS_ACCOUNT_ID=&lt;account id&gt;\nexport AWS_DEFAULT_REGION=&lt;default region&gt;\nexport AWS_REGION=&lt;region&gt;\nexport AWS_ACCESS_KEY_ID=&lt;access key id&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;secret key&gt;\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-2-configure-cloudwatch-logging","title":"Step 2: Configure CloudWatch logging:","text":"<p>Create a log group and log stream for your agent in Amazon CloudWatch which you can use to configure below environment variables.</p>"},{"location":"user-guide/observability/quickstart.html#step-3-configure-opentelemetry-environment-variables","title":"Step 3: Configure OpenTelemetry Environment Variables","text":"<pre><code>export AGENT_OBSERVABILITY_ENABLED=true # Activates the ADOT pipeline\nexport OTEL_PYTHON_DISTRO=aws_distro # Uses AWS Distro for OpenTelemetry\nexport OTEL_PYTHON_CONFIGURATOR=aws_configurator # Sets AWS configurator for ADOT SDK\nexport OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf # Configures export protocol\nexport  OTEL_EXPORTER_OTLP_LOGS_HEADERS=x-aws-log-group=&lt;YOUR-LOG-GROUP&gt;,x-aws-log-stream=&lt;YOUR-LOG-STREAM&gt;,x-aws- metric-namespace=&lt;YOUR-NAMESPACE&gt;\n# Directs logs to CloudWatch groups\nexport OTEL_RESOURCE_ATTRIBUTES=service.name=&lt;YOUR-AGENT-NAME&gt; # Identifies your agent in observability data\n</code></pre> <p>Replace <code>&lt;YOUR-AGENT-NAME&gt;</code> with a unique name to identify this agent in the GenAI Observability dashboard and logs.</p>"},{"location":"user-guide/observability/quickstart.html#step-4-create-an-agent-locally","title":"Step 4: Create an agent locally","text":"<pre><code># Create agent.py -  Strands agent that is a weather assistant\nfrom strands import Agent\nfrom strands_tools import http_request\n\n# Define a weather-focused system prompt\nWEATHER_SYSTEM_PROMPT = \"\"\"You are a weather assistant with HTTP capabilities. You can:\n\n1. Make HTTP requests to the National Weather Service API\n2. Process and display weather forecast data\n3. Provide weather information for locations in the United States\n\nWhen retrieving weather information:\n1. First get the coordinates or grid information using https://api.weather.gov/points/{latitude},{longitude} or https://api.weather.gov/points/{zipcode}\n2. Then use the returned forecast URL to get the actual forecast\n\nWhen displaying responses:\n- Format weather data in a human-readable way\n- Highlight important information like temperature, precipitation, and alerts\n- Handle errors appropriately\n- Convert technical terms to user-friendly language\n\nAlways explain the weather conditions clearly and provide context for the forecast.\n\"\"\"\n\n# Create an agent with HTTP capabilities\nweather_agent = Agent(\n    system_prompt=WEATHER_SYSTEM_PROMPT,\n    tools=[http_request],  # Explicitly enable http_request tool\n)\n\nresponse = weather_agent(\"What's the weather like in Seattle?\")\nprint(response)\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#step-5-run-your-agent-with-automatic-instrumentation-command","title":"Step 5: Run your agent with automatic instrumentation command","text":"<p>With aws-opetelemetry-distro in your requirements.txt, <code>opentelemetry-instrument</code> command will:</p> <ul> <li>Load your OTEL configuration from your environment variables</li> <li>Automatically instrument Strands, Amazon Bedrock calls, agent tool and databases, and other requests made by agent</li> <li>Send traces to CloudWatch</li> <li>Enable you to visualize the agent's decision-making process in the GenAI Observability dashboard</li> </ul> <pre><code>opentelemetry-instrument python agent.py\n</code></pre> <p>You can now view your traces, sessions and metrics on GenAI Observability Dashboard on Amazon CloudWatch with the help of YOUR-AGENT-NAME that you configured in your environment variable.</p> <p>To correlate traces across multiple agent runs, you can associate a session ID with your telemetry data using OpenTelemetry baggage:</p> <pre><code>from opentelemetry import baggage, context\nctx = baggage.set_baggage(\"session.id\", session_id)\n</code></pre> <p>Run the session-enabled version following command, complete implementation provided in the notebook:</p> <pre><code>opentelemetry-instrument python strands_travel_agent_with_session.py --session-id \"user-session-123\"\n</code></pre>"},{"location":"user-guide/observability/quickstart.html#agentcore-observability-on-genai-observability-on-amazon-cloudwatch","title":"AgentCore Observability on GenAI Observability on Amazon CloudWatch","text":"<p>After implementing observability, you can view the collected data in CloudWatch:</p>"},{"location":"user-guide/observability/quickstart.html#bedrock-agentcore-overview-on-genai-observability-dashboard","title":"Bedrock AgentCore Overview on GenAI Observability dashboard","text":"<ol> <li>Open the GenAI Observability on CloudWatch console</li> <li>You are able to view the data related to model invocations and agents on Bedrock AgentCore on the dashboard.</li> <li>In the Bedrock Agentcore tab you are able to see Agents View, Sessions View and Traces View.</li> <li>Agents View lists all your Agents that are on and not on runtime, you can also click on the agent and view further details like runtime metrics, sessions and traces specific to an agent.</li> <li>In the Sessions View tab, you can navigate across all the sessions associated with agents.</li> <li>In the Trace View tab, you can look into the traces and span information for agents. Also explore the trace trajectory and timeline by clicking on a trace.</li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-logs-in-cloudwatch","title":"View Logs in CloudWatch","text":"<ol> <li>Open the CloudWatch console</li> <li>In the left navigation pane, expand Logs and select Log groups</li> <li> <p>Search for your agent's log group:</p> </li> <li> <p>Standard logs (stdout/stderr) Location: <code>/aws/bedrock-agentcore/runtimes/&lt;agent_id&gt;-&lt;endpoint_name&gt;/[runtime-logs] &lt;UUID&gt;</code></p> </li> <li>OTEL structured logs: <code>/aws/bedrock-agentcore/runtimes/&lt;agent_id&gt;-&lt;endpoint_name&gt;/runtime-logs</code></li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-traces-and-spans","title":"View Traces and Spans","text":"<ol> <li>Open the CloudWatch console</li> <li>Select Transaction Search from the left navigation</li> <li>Location: <code>/aws/spans/default</code></li> <li>Filter by service name or other criteria</li> <li>Select a trace to view the detailed execution graph</li> </ol>"},{"location":"user-guide/observability/quickstart.html#view-metrics","title":"View Metrics","text":"<ol> <li>Open the CloudWatch console</li> <li>Select Metrics from the left navigation</li> <li>Browse to the <code>bedrock-agentcore</code> namespace</li> <li>Explore the available metrics</li> </ol>"},{"location":"user-guide/observability/quickstart.html#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple, Then Expand - The default observability provided by AgentCore captures most critical metrics automatically, including model calls, token usage, and tool execution.</li> <li>Configure for Development Stage - Tailor your observability configuration to match your current development phase and progressively adjust.</li> <li>Use Consistent Naming - Establish naming conventions for services, spans, and attributes from the start</li> <li>Filter Sensitive Data - Prevent exposure of confidential information by filtering sensitive data from observability attributes and payloads.</li> <li>Set up alerts - Configure CloudWatch alarms to notify you of potential issues before they impact users</li> </ol>"},{"location":"user-guide/runtime/async.html","title":"Handle Asynchronous and Long Running Agents","text":"<p>AgentCore Runtime can handle asynchronous processing and long running agents. Asynchronous tasks allow your agent to continue processing after responding to the client and handle long-running operations without blocking responses.</p> <p>With async processing, your agent can:</p> <ul> <li>Start a task that might take minutes or hours</li> <li>Immediately respond to the user saying \"I've started working on this\"</li> <li>Continue processing in the background</li> <li>Allow the user to check back later for results</li> </ul>"},{"location":"user-guide/runtime/async.html#key-concepts","title":"Key Concepts","text":""},{"location":"user-guide/runtime/async.html#asynchronous-processing-model","title":"Asynchronous Processing Model","text":"<p>The Amazon Bedrock AgentCore SDK supports both synchronous and asynchronous processing through a unified API. This creates a flexible implementation pattern for both clients and agent developers. Agent clients can work with the same API without differentiating between synchronous and asynchronous on the client side. With the ability to invoke the same session across invocations, agent developers can reuse context and build upon this context incrementally without implementing complex task management logic.</p>"},{"location":"user-guide/runtime/async.html#runtime-session-lifecycle-management","title":"Runtime Session Lifecycle Management","text":"<p>Agent code communicates its processing status using the \"/ping\" health status:</p> <ul> <li>\"Healthy\": Ready for new work, no background tasks running</li> <li>\"HealthyBusy\": Currently processing background tasks</li> </ul> <p>A session in idle state for 15 minutes gets automatically terminated.</p>"},{"location":"user-guide/runtime/async.html#three-ways-to-manage-async-tasks","title":"Three Ways to Manage Async Tasks","text":""},{"location":"user-guide/runtime/async.html#1-async-task-decorator-recommended","title":"1. Async Task Decorator (Recommended)","text":"<p>The simplest way to track asynchronous functions. The SDK automatically manages the ping status:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.async_task\nasync def background_work():\n    await asyncio.sleep(10)  # Status becomes \"HealthyBusy\"\n    return \"done\"\n\n@app.entrypoint\nasync def handler(event):\n    asyncio.create_task(background_work())\n    return {\"status\": \"started\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>How it works: - The <code>@app.async_task</code> decorator tracks function execution - When the function runs, ping status changes to \"HealthyBusy\" - When the function completes, status returns to \"Healthy\"</p>"},{"location":"user-guide/runtime/async.html#2-manual-task-management","title":"2. Manual Task Management","text":"<p>For more control over task tracking, use the API methods directly:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nimport threading\nimport time\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef handler(event):\n    \"\"\"Start tracking a task manually\"\"\"\n    # Start tracking the task\n    task_id = app.add_async_task(\"data_processing\", {\"batch\": 100})\n\n    # Start background work\n    def background_work():\n        time.sleep(30)  # Simulate work\n        app.complete_async_task(task_id)  # Mark as complete\n\n    threading.Thread(target=background_work, daemon=True).start()\n\n    return {\"status\": \"Task started\", \"task_id\": task_id}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>API Methods: - <code>app.add_async_task(name, metadata)</code> - Start tracking a task - <code>app.complete_async_task(task_id)</code> - Mark task as complete - <code>app.get_async_task_info()</code> - Get information about running tasks</p>"},{"location":"user-guide/runtime/async.html#3-custom-ping-handler","title":"3. Custom Ping Handler","text":"<p>Override automatic status with custom logic:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom bedrock_agentcore.runtime.models import PingStatus\n\napp = BedrockAgentCoreApp()\n\n# Global state to track custom conditions\nprocessing_data = False\n\n@app.ping\ndef custom_status():\n    \"\"\"Custom ping handler with your own logic\"\"\"\n    if processing_data or system_busy():\n        return PingStatus.HEALTHY_BUSY\n    return PingStatus.HEALTHY\n\n@app.entrypoint\ndef handler(event):\n    global processing_data\n\n    if event.get(\"action\") == \"start_processing\":\n        processing_data = True\n        # Start your processing...\n        return {\"status\": \"Processing started\"}\n\n    return {\"status\": \"Ready\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"user-guide/runtime/async.html#complete-example-with-strands","title":"Complete Example with Strands","text":"<p>Here's a practical example combining async tasks with the Strands AI framework:</p> <pre><code>import threading\nimport time\nfrom strands import Agent, tool\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\n# Initialize app with debug mode for task management\napp = BedrockAgentCoreApp(debug=True)\n\n@tool\ndef start_background_task(duration: int = 5) -&gt; str:\n    \"\"\"Start a simple background task that runs for specified duration.\"\"\"\n    # Start tracking the async task\n    task_id = app.add_async_task(\"background_processing\", {\"duration\": duration})\n\n    # Run task in background thread\n    def background_work():\n        time.sleep(duration)  # Simulate work\n        app.complete_async_task(task_id)  # Mark as complete\n\n    threading.Thread(target=background_work, daemon=True).start()\n    return f\"Started background task (ID: {task_id}) for {duration} seconds. Agent status is now BUSY.\"\n\n# Create agent with the tool\nagent = Agent(tools=[start_background_task])\n\n@app.entrypoint\ndef main(payload):\n    \"\"\"Main entrypoint - handles user messages.\"\"\"\n    user_message = payload.get(\"prompt\", \"Try: start_background_task(3)\")\n    return {\"message\": agent(user_message).message}\n\nif __name__ == \"__main__\":\n    print(\"\ud83d\ude80 Simple Async Strands Example\")\n    print(\"Test: curl -X POST http://localhost:8080/invocations -H 'Content-Type: application/json' -d '{\\\"prompt\\\": \\\"start a 3 second task\\\"}'\")\n    app.run()\n</code></pre> <p>This example demonstrates: - Creating a background task that runs asynchronously - Tracking the task's status with <code>add_async_task</code> and <code>complete_async_task</code> - Responding immediately to the user while processing continues - Managing the agent's health status automatically</p>"},{"location":"user-guide/runtime/async.html#ping-status-priority","title":"Ping Status Priority","text":"<p>The ping status is determined in this priority order:</p> <ol> <li>Forced Status (debug actions like <code>force_busy</code>)</li> <li>Custom Handler (<code>@app.ping</code> decorator)</li> <li>Automatic (based on active <code>@app.async_task</code> functions)</li> </ol>"},{"location":"user-guide/runtime/async.html#debug-and-testing-features","title":"Debug and Testing Features","text":"<p>Enable debug mode for additional testing capabilities:</p> <pre><code>app = BedrockAgentCoreApp(debug=True)\n</code></pre> <p>Debug Actions (via POST with <code>\"_agent_core_app_action\"</code>): - <code>\"ping_status\"</code> - Check current status - <code>\"job_status\"</code> - List running tasks - <code>\"force_busy\"</code> / <code>\"force_healthy\"</code> - Force status - <code>\"clear_forced_status\"</code> - Clear forced status</p> <p>API Methods: <pre><code>task_id = app.add_async_task(\"task_name\", metadata={})\nsuccess = app.complete_async_task(task_id)\nstatus = app.get_current_ping_status()\ninfo = app.get_async_task_info()\n</code></pre></p>"},{"location":"user-guide/runtime/async.html#testing-your-async-agent","title":"Testing Your Async Agent","text":""},{"location":"user-guide/runtime/async.html#local-testing-with-curl","title":"Local Testing with curl","text":"<pre><code># Start your agent\npython my_async_agent.py\n\n# Test ping endpoint\ncurl http://localhost:8080/ping\n\n# Start a background task\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"start a background task\"}'\n\n# Check if status changed to HealthyBusy\ncurl http://localhost:8080/ping\n</code></pre>"},{"location":"user-guide/runtime/async.html#local-testing-with-agentcore-cli","title":"Local Testing with AgentCore CLI","text":"<pre><code># Configure and test locally\nagentcore configure -e my_async_agent.py\nagentcore launch -l\n\n# Test in another terminal\nagentcore invoke '{\"prompt\": \"start processing\"}' -l\n\n# Check status via ping\ncurl http://localhost:8080/ping\n</code></pre>"},{"location":"user-guide/runtime/async.html#common-patterns","title":"Common Patterns","text":"<p>Long-Running Processing: <pre><code>@tool\ndef start_data_processing(dataset_size: str = \"medium\") -&gt; str:\n    task_id = app.add_async_task(\"data_processing\", {\"size\": dataset_size})\n\n    def process_data():\n        time.sleep(1800)  # Simulate processing\n        app.complete_async_task(task_id)\n\n    threading.Thread(target=process_data, daemon=True).start()\n    return f\"\ud83d\ude80 Processing started (Task {task_id}). I'll continue in the background!\"\n</code></pre></p> <p>Progress Monitoring: <pre><code>def save_progress(task_id: int, progress: dict):\n    with open(f\"task_progress_{task_id}.json\", 'w') as f:\n        json.dump(progress, f)\n\n@tool\ndef get_progress(task_id: int = None) -&gt; str:\n    # Find and read progress file\n    # Return formatted status\n    pass\n</code></pre></p>"},{"location":"user-guide/runtime/notebook.html","title":"Jupyter Notebook Support","text":"<p>Local Testing Only</p> <p>The notebook interface is intended for local development and testing only. It has rough edges and is not recommended for production use. For production deployment, use the Boto3 SDK instead.</p> <p>The AgentCore Runtime provides basic Jupyter notebook support for quick experimentation and testing.</p>"},{"location":"user-guide/runtime/notebook.html#basic-example","title":"Basic Example","text":"<pre><code># Import the notebook Runtime class\nfrom bedrock_agentcore_starter_toolkit.notebook import Runtime\n\n# Initialize\nruntime = Runtime()\n\n# Configure your agent\nconfig = runtime.configure(\n    entrypoint=\"my_agent.py\",\n    execution_role=\"arn:aws:iam::123456789012:role/MyExecutionRole\"\n)\n\n# Test locally\nlocal_result = runtime.launch(local=True)\nprint(f\"Local container: {local_result.tag}\")\n\n# Test your agent\nresponse = runtime.invoke({\"prompt\": \"Hello from notebook!\"})\nprint(response)\n</code></pre>"},{"location":"user-guide/runtime/notebook.html#simple-agent-example","title":"Simple Agent Example","text":"<p>Create a simple agent file first:</p> <pre><code># my_agent.py\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef handler(payload):\n    prompt = payload.get(\"prompt\", \"Hello\")\n    return {\"result\": f\"You said: {prompt}\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Then use it in your notebook:</p> <pre><code>from bedrock_agentcore_starter_toolkit.notebook import Runtime\n\nruntime = Runtime()\n\n# Configure\nruntime.configure(\n    entrypoint=\"my_agent.py\",\n    execution_role=\"arn:aws:iam::123456789012:role/MyRole\"\n)\n\n# Launch locally for testing\nruntime.launch(local=True)\n\n# Test the agent\nresponse = runtime.invoke({\"prompt\": \"Test from notebook\"})\nprint(response)  # {\"result\": \"You said: Test from notebook\"}\n</code></pre>"},{"location":"user-guide/runtime/notebook.html#available-methods","title":"Available Methods","text":"<ul> <li><code>configure()</code> - Set up agent configuration</li> <li><code>launch(local=True)</code> - Build and run locally</li> <li><code>invoke(payload)</code> - Test your agent</li> <li><code>status()</code> - Check agent status</li> </ul>"},{"location":"user-guide/runtime/notebook.html#limitations","title":"Limitations","text":"<ul> <li>Local testing focus - Not optimized for production workflows</li> <li>Basic error handling - Limited error reporting compared to CLI</li> <li>Configuration limitations - Fewer options than full CLI interface</li> <li>No interactive prompts - All configuration must be provided programmatically</li> </ul> <p>For full-featured development and production deployment, use the AgentCore CLI instead.</p>"},{"location":"user-guide/runtime/overview.html","title":"AgentCore Runtime SDK Overview","text":"<p>The Amazon Bedrock AgentCore Runtime SDK transforms your Python functions into production-ready AI agents with built-in HTTP service wrapper, session management, and complete deployment workflows.</p>"},{"location":"user-guide/runtime/overview.html#quick-start","title":"Quick Start","text":"<pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef my_agent(payload):\n    return {\"result\": f\"Hello {payload.get('name', 'World')}!\"}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <pre><code># Configure and deploy your agent\nagentcore configure --entrypoint my_agent.py --non-interactive\nagentcore launch\nagentcore invoke '{\"name\": \"Alice\"}'\n</code></pre>"},{"location":"user-guide/runtime/overview.html#what-is-the-agentcore-runtime-sdk","title":"What is the AgentCore Runtime SDK?","text":"<p>The Runtime SDK is a comprehensive Python framework that bridges the gap between your AI agent code and Amazon Bedrock AgentCore's managed infrastructure. It provides HTTP service wrapper, decorator-based programming, session management, authentication integration, streaming support, async task management, and complete local development tools.</p>"},{"location":"user-guide/runtime/overview.html#core-components","title":"Core Components","text":"<p>BedrockAgentCoreApp - HTTP service wrapper with: - <code>/invocations</code> endpoint for agent logic - <code>/ping</code> endpoint for health checks - Built-in logging, error handling, and session management</p> <p>Key Decorators: - <code>@app.entrypoint</code> - Define your agent's main logic - <code>@app.ping</code> - Custom health checks - <code>@app.async_task</code> - Background processing</p>"},{"location":"user-guide/runtime/overview.html#deployment-modes","title":"Deployment Modes","text":""},{"location":"user-guide/runtime/overview.html#cloud-build-recommended","title":"\ud83d\ude80 Cloud Build (RECOMMENDED)","text":"<p><pre><code>agentcore configure --entrypoint my_agent.py\nagentcore launch                    # Uses CodeBuild - no Docker needed\n</code></pre> - No Docker required - builds in the cloud - Production-ready - standardized ARM64 containers - Works everywhere - SageMaker Notebooks, Cloud9, laptops</p>"},{"location":"user-guide/runtime/overview.html#local-development","title":"\ud83d\udcbb Local Development","text":"<p><pre><code>agentcore launch --local           # Build and run locally\n</code></pre> - Fast iteration - immediate feedback and debugging - Requires: Docker, Finch, or Podman</p>"},{"location":"user-guide/runtime/overview.html#hybrid-build","title":"\ud83d\udd27 Hybrid Build","text":"<p><pre><code>agentcore launch --local-build     # Build locally, deploy to cloud\n</code></pre> - Custom builds with cloud deployment - Requires: Docker, Finch, or Podman</p>"},{"location":"user-guide/runtime/overview.html#agent-development-patterns","title":"Agent Development Patterns","text":""},{"location":"user-guide/runtime/overview.html#synchronous-agents","title":"Synchronous Agents","text":"<pre><code>from bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef simple_agent(payload):\n    prompt = payload.get(\"prompt\", \"\")\n    if \"weather\" in prompt.lower():\n        return {\"result\": \"It's sunny today!\"}\n    return {\"result\": f\"You said: {prompt}\"}\n</code></pre>"},{"location":"user-guide/runtime/overview.html#streaming-agents","title":"Streaming Agents","text":"<pre><code>from strands import Agent\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\napp = BedrockAgentCoreApp()\nagent = Agent()\n\n@app.entrypoint\nasync def streaming_agent(payload):\n    \"\"\"Streaming agent with real-time responses\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello\")\n\n    # Stream responses as they're generated\n    stream = agent.stream_async(user_message)\n    async for event in stream:\n        if \"data\" in event:\n            yield event[\"data\"]          # Stream data chunks\n        elif \"message\" in event:\n            yield event[\"message\"]       # Stream message parts\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Key Streaming Features: - Server-Sent Events (SSE): Automatic SSE formatting for web clients - Error Handling: Graceful error streaming with error events - Generator Support: Both sync and async generators supported - Real-time Processing: Immediate response chunks as they're available</p>"},{"location":"user-guide/runtime/overview.html#framework-integration","title":"Framework Integration","text":"<p>The SDK works seamlessly with popular AI frameworks:</p> <p>Strands Integration: <pre><code>from strands import Agent\nfrom bedrock_agentcore import BedrockAgentCoreApp\n\nagent = Agent(tools=[your_tools])\napp = BedrockAgentCoreApp()\n\n@app.entrypoint\ndef strands_agent(payload):\n    result = agent(payload.get(\"prompt\"))\n    return {\"result\": result.message}\n</code></pre> Custom Framework Integration: <pre><code>@app.entrypoint\nasync def custom_framework_agent(payload):\n    \"\"\"Works with any async framework\"\"\"\n    response = await your_framework.process(payload)\n\n    # Can yield for streaming\n    for chunk in response.stream():\n        yield {\"chunk\": chunk}\n</code></pre></p>"},{"location":"user-guide/runtime/overview.html#session-management","title":"Session Management","text":"<p>Built-in session handling with automatic creation, 15-minute timeout, and cross-invocation persistence:</p> <pre><code>from bedrock_agentcore.runtime.context import RequestContext\n\n@app.entrypoint\ndef session_aware_agent(payload, context: RequestContext):\n    \"\"\"Agent with session awareness\"\"\"\n    session_id = context.session_id\n    user_message = payload.get(\"prompt\")\n\n    # Your session-aware logic here\n    return {\n        \"result\": f\"Session {session_id}: {user_message}\",\n        \"session_id\": session_id\n    }\n</code></pre> <pre><code># CLI session management\n# Using AgentCore CLI with session management\nagentcore invoke '{\"prompt\": \"Hello, remember this conversation\"}' --session-id \"conversation-123\"\n\nagentcore invoke '{\"prompt\": \"What did I say earlier?\"}' --session-id \"conversation-123\"\n</code></pre>"},{"location":"user-guide/runtime/overview.html#authentication-authorization","title":"Authentication &amp; Authorization","text":"<p>The SDK integrates with AgentCore's identity services providing automatic AWS credential validation (IAM SigV4) by default or JWT Bearer tokens for OAuth-compatible authentication:</p> <pre><code># Configure JWT authorization using AgentCore CLI\nagentcore configure --entrypoint my_agent.py \\\n  --authorizer-config '{\"customJWTAuthorizer\": {\"discoveryUrl\": \"https://cognito-idp.region.amazonaws.com/pool/.well-known/openid-configuration\", \"allowedClients\": [\"your-client-id\"]}}'\n</code></pre>"},{"location":"user-guide/runtime/overview.html#asynchronous-processing","title":"Asynchronous Processing","text":"<p>AgentCore Runtime supports asynchronous processing for long-running tasks. Your agent can start background work and immediately respond to users, with automatic health status management.</p>"},{"location":"user-guide/runtime/overview.html#key-features","title":"Key Features","text":"<p>Automatic Status Management: - Agent status changes to \"HealthyBusy\" during background processing - Returns to \"Healthy\" when tasks complete - Sessions automatically terminate after 15 minutes of inactivity</p> <p>Three Processing Approaches:</p> <ol> <li> <p>Async Task Decorator (Recommended) <pre><code>@app.async_task\nasync def background_work():\n    await process_data()  # Status becomes \"HealthyBusy\"\n    return \"done\"\n\n@app.entrypoint\nasync def handler(event):\n    asyncio.create_task(background_work())\n    return {\"status\": \"started\"}\n</code></pre></p> </li> <li> <p>Manual Task Management <pre><code>@app.entrypoint\ndef handler(event):\n    task_id = app.add_async_task(\"data_processing\", {\"batch\": 100})\n\n    def background_work():\n        time.sleep(30)\n        app.complete_async_task(task_id)\n\n    threading.Thread(target=background_work, daemon=True).start()\n    return {\"task_id\": task_id}\n</code></pre></p> </li> <li> <p>Custom Ping Handler <pre><code>@app.ping\ndef custom_status():\n    if processing_data or system_busy():\n        return PingStatus.HEALTHY_BUSY\n    return PingStatus.HEALTHY\n</code></pre></p> </li> </ol> <p>Common Use Cases: - Data processing that takes minutes or hours - File uploads and conversions - External API calls with retries - Batch operations and reports</p> <p>See the Async Processing Guide for detailed examples and testing strategies.</p>"},{"location":"user-guide/runtime/overview.html#local-development_1","title":"Local Development","text":""},{"location":"user-guide/runtime/overview.html#debug-mode","title":"Debug Mode","text":"<pre><code>app = BedrockAgentCoreApp(debug=True)  # Enhanced logging\n\nif __name__ == \"__main__\":\n    app.run()  # Auto-detects Docker vs local\n</code></pre>"},{"location":"user-guide/runtime/overview.html#complete-development-workflow","title":"Complete Development Workflow","text":"<pre><code># 1. Configure\nagentcore configure --entrypoint my_agent.py\n\n# 2. Develop locally\nagentcore launch --local\n\n# 3. Test\nagentcore invoke '{\"prompt\": \"Hello\"}'\nagentcore invoke '{\"prompt\": \"Remember this\"}' --session-id \"test\"\n\n# 4. Deploy to cloud\nagentcore launch\n\n# 5. Monitor\nagentcore status\n</code></pre> <p>The AgentCore Runtime SDK provides everything needed to build, test, and deploy production-ready AI agents with minimal setup and maximum flexibility.</p>"},{"location":"user-guide/runtime/permissions.html","title":"Runtime Permissions","text":"<p>This guide covers the IAM permissions required to run agents with Amazon Bedrock AgentCore Runtime.</p> <p>The toolkit requires two types of IAM roles for different phases of agent deployment:</p> <ul> <li>Runtime Execution Role: Used by Bedrock AgentCore Runtime to execute your agent</li> <li>CodeBuild Execution Role: Used by AWS CodeBuild to build and push container images (ARM64 architecture)</li> </ul> <p>Both roles can be automatically created by the toolkit or manually specified using existing roles.</p>"},{"location":"user-guide/runtime/permissions.html#auto-role-creation-feature","title":"Auto Role Creation Feature","text":""},{"location":"user-guide/runtime/permissions.html#overview","title":"Overview","text":"<p>The Bedrock AgentCore Starter Toolkit includes an auto role creation feature that automatically generates the Runtime Execution Role when you don't specify an existing role.</p>"},{"location":"user-guide/runtime/permissions.html#what-gets-auto-created","title":"What Gets Auto-Created","text":"<p>When you run <code>agentcore configure</code> without specifying the <code>--execution-role</code> parameter, the toolkit automatically creates:</p>"},{"location":"user-guide/runtime/permissions.html#runtime-execution-role","title":"Runtime Execution Role","text":"<ul> <li>Name: <code>AmazonBedrockAgentCoreSDKRuntime-{region}-{hash}</code></li> <li>Purpose: Used by Bedrock AgentCore to execute your agent</li> <li>Permissions: All required runtime permissions (ECR, CloudWatch, Bedrock, etc.)</li> </ul> <p>Note: The CodeBuild Execution Role (<code>AmazonBedrockAgentCoreSDKCodeBuild-{region}-{hash}</code>) is always auto-created when using CodeBuild deployment, regardless of this setting.</p>"},{"location":"user-guide/runtime/permissions.html#benefits-of-auto-role-creation","title":"Benefits of Auto Role Creation","text":"<p>\ud83d\ude80 Instant Setup <pre><code># One command creates everything you need\nagentcore configure -e my_agent.py\n</code></pre></p>"},{"location":"user-guide/runtime/permissions.html#usage-examples","title":"Usage Examples","text":"<p>Basic Auto-Creation: <pre><code># Creates all required roles and resources\nagentcore configure -e my_agent.py\n</code></pre></p> <p>Auto-Creation with Default Deployment: <pre><code># Uses CodeBuild by default\nagentcore configure -e my_agent.py\nagentcore launch\n</code></pre></p>"},{"location":"user-guide/runtime/permissions.html#developercaller-permissions","title":"Developer/Caller Permissions","text":""},{"location":"user-guide/runtime/permissions.html#overview_1","title":"Overview","text":"<p>Developers using the Bedrock AgentCore Starter Toolkit need specific IAM permissions to create roles, manage CodeBuild projects, and deploy agents. These permissions are separate from the execution roles and are required for the toolkit's operational functionality.</p>"},{"location":"user-guide/runtime/permissions.html#required-caller-policy","title":"Required Caller Policy","text":"<p>Attach the following policy to your IAM user or role:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n      \"Sid\": \"IAMRoleManagement\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iam:CreateRole\",\n        \"iam:DeleteRole\",\n        \"iam:GetRole\",\n        \"iam:PutRolePolicy\",\n        \"iam:DeleteRolePolicy\",\n        \"iam:AttachRolePolicy\",\n        \"iam:DetachRolePolicy\",\n        \"iam:TagRole\",\n        \"iam:ListRolePolicies\",\n        \"iam:ListAttachedRolePolicies\"\n      ],\n      \"Resource\": [\n        \"arn:aws:iam::*:role/*BedrockAgentCore*\",\n        \"arn:aws:iam::*:role/service-role/*BedrockAgentCore*\"\n      ]\n    },\n    {\n      \"Sid\": \"CodeBuildProjectAccess\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"codebuild:StartBuild\",\n        \"codebuild:BatchGetBuilds\",\n        \"codebuild:ListBuildsForProject\",\n        \"codebuild:CreateProject\",\n        \"codebuild:UpdateProject\",\n        \"codebuild:BatchGetProjects\"\n      ],\n      \"Resource\": [\n        \"arn:aws:codebuild:*:*:project/bedrock-agentcore-*\",\n        \"arn:aws:codebuild:*:*:build/bedrock-agentcore-*\"\n      ]\n    },\n    {\n      \"Sid\": \"CodeBuildListAccess\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"codebuild:ListProjects\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Sid\": \"IAMPassRoleAccess\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iam:PassRole\"\n      ],\n      \"Resource\": [\n        \"arn:aws:iam::*:role/AmazonBedrockAgentCore*\",\n        \"arn:aws:iam::*:role/service-role/AmazonBedrockAgentCore*\"\n      ]\n    },\n    {\n      \"Sid\": \"CloudWatchLogsAccess\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"logs:GetLogEvents\",\n        \"logs:DescribeLogGroups\",\n        \"logs:DescribeLogStreams\"\n      ],\n      \"Resource\": [\n        \"arn:aws:logs:*:*:log-group:/aws/bedrock-agentcore/*\",\n        \"arn:aws:logs:*:*:log-group:/aws/codebuild/*\"\n      ]\n    },\n    {\n      \"Sid\": \"S3Access\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"s3:GetObject\",\n        \"s3:PutObject\",\n        \"s3:ListBucket\",\n        \"s3:CreateBucket\",\n        \"s3:PutLifecycleConfiguration\"\n      ],\n      \"Resource\": [\n        \"arn:aws:s3:::bedrock-agentcore-*\",\n        \"arn:aws:s3:::bedrock-agentcore-*/*\"\n      ]\n    },\n    {\n      \"Sid\": \"ECRRepositoryAccess\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:CreateRepository\",\n        \"ecr:DescribeRepositories\",\n        \"ecr:GetRepositoryPolicy\",\n        \"ecr:InitiateLayerUpload\",\n        \"ecr:CompleteLayerUpload\",\n        \"ecr:PutImage\",\n        \"ecr:UploadLayerPart\",\n        \"ecr:BatchCheckLayerAvailability\",\n        \"ecr:GetDownloadUrlForLayer\",\n        \"ecr:BatchGetImage\",\n        \"ecr:ListImages\",\n        \"ecr:TagResource\"\n      ],\n      \"Resource\": [\n        \"arn:aws:ecr:*:*:repository/bedrock-agentcore-*\"\n      ]\n    },\n    {\n      \"Sid\": \"ECRAuthorizationAccess\",\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"ecr:GetAuthorizationToken\"\n      ],\n      \"Resource\": \"*\"\n    },\n    {\n      \"Sid\": \"BedrockAgentCoreRuntimeIdentityServiceLinkedRolePermissions\",\n      \"Effect\": \"Allow\",\n      \"Action\": \"iam:CreateServiceLinkedRole\",\n      \"Resource\": \"arn:aws:iam::*:role/aws-service-role/runtime-identity.bedrock-agentcore.amazonaws.com/AWSServiceRoleForBedrockAgentCoreRuntimeIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"iam:AWSServiceName\": \"runtime-identity.bedrock-agentcore.amazonaws.com\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#additional-required-permissions","title":"Additional Required Permissions","text":"<p>You also need: - AgentCore Full Access: <code>BedrockAgentCoreFullAccess</code> managed policy - Bedrock Access (one of the following):   - Option 1 (Development): <code>AmazonBedrockFullAccess</code> managed policy   - Option 2 (Production Recommended): Custom policy with scoped permissions for specific models and actions</p>"},{"location":"user-guide/runtime/permissions.html#production-security-best-practices","title":"Production Security Best Practices","text":"<p>When moving from development to production, consider these security enhancements:</p>"},{"location":"user-guide/runtime/permissions.html#1-scope-down-resource-access","title":"1. Scope Down Resource Access","text":"<p>Instead of granting broad access to all resources, limit permissions to specific resources:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"LimitedModelAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:InvokeModelWithResponseStream\"\n            ],\n            \"Resource\": [\n                \"arn:aws:bedrock:region:accountId:foundation-model/anthropic.claude-3-sonnet-20240229-v1:0\",\n                \"arn:aws:bedrock:region:accountId:foundation-model/anthropic.claude-3-haiku-20240307-v1:0\"\n            ]\n        },\n        {\n            \"Sid\": \"LimitedECRAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:BatchGetImage\",\n                \"ecr:GetDownloadUrlForLayer\"\n            ],\n            \"Resource\": [\n                \"arn:aws:ecr:region:accountId:repository/bedrock-agentcore-your-agent-name\"\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#2-use-infrastructure-as-code","title":"2. Use Infrastructure as Code","text":"<p>Consider using AWS CDK, CloudFormation, or Terraform to define your roles with precise permissions.</p>"},{"location":"user-guide/runtime/permissions.html#codebuild-integration","title":"CodeBuild Integration","text":"<p>The toolkit uses AWS CodeBuild for ARM64 container builds, especially useful in cloud development environments where Docker is not available (such as SageMaker notebooks, Cloud9, or other managed environments).</p>"},{"location":"user-guide/runtime/permissions.html#runtime-execution-role_1","title":"Runtime Execution Role","text":"<p>The Runtime Execution Role is an IAM role that AgentCore Runtime assumes to run an agent. Replace the following:</p> <ul> <li><code>region</code> with the AWS Region that you are using</li> <li><code>accountId</code> with your AWS account ID</li> <li><code>agentName</code> with the name of your agent. You'll need to decide the agent name before creating the role and AgentCore Runtime.</li> </ul>"},{"location":"user-guide/runtime/permissions.html#permissions-policy","title":"Permissions Policy","text":"<pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"ECRImageAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:BatchGetImage\",\n                \"ecr:GetDownloadUrlForLayer\"\n            ],\n            \"Resource\": [\n                \"arn:aws:ecr:region:accountId:repository/*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:DescribeLogStreams\",\n                \"logs:CreateLogGroup\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:region:accountId:log-group:/aws/bedrock-agentcore/runtimes/*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:DescribeLogGroups\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:region:accountId:log-group:*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"logs:CreateLogStream\",\n                \"logs:PutLogEvents\"\n            ],\n            \"Resource\": [\n                \"arn:aws:logs:region:accountId:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*\"\n            ]\n        },\n        {\n            \"Sid\": \"ECRTokenAccess\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"ecr:GetAuthorizationToken\"\n            ],\n            \"Resource\": \"*\"\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"xray:PutTraceSegments\",\n                \"xray:PutTelemetryRecords\",\n                \"xray:GetSamplingRules\",\n                \"xray:GetSamplingTargets\"\n            ],\n            \"Resource\": [\"*\"]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Resource\": \"*\",\n            \"Action\": \"cloudwatch:PutMetricData\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"cloudwatch:namespace\": \"bedrock-agentcore\"\n                }\n            }\n        },\n        {\n            \"Sid\": \"BedrockModelInvocation\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"bedrock:InvokeModel\",\n                \"bedrock:InvokeModelWithResponseStream\"\n            ],\n            \"Resource\": [\n                \"arn:aws:bedrock:*::foundation-model/*\",\n                \"arn:aws:bedrock:region:accountId:*\"\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#trust-policy","title":"Trust Policy","text":"<p>The trust relationship for the AgentCore Runtime execution role should allow AgentCore Runtime to assume the role:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"AssumeRolePolicy\",\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"bedrock-agentcore.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\",\n      \"Condition\": {\n            \"StringEquals\": {\n                \"aws:SourceAccount\": \"accountId\"\n            },\n            \"ArnLike\": {\n                \"aws:SourceArn\": \"arn:aws:bedrock-agentcore:region:accountId:*\"\n            }\n       }\n    }\n  ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#codebuild-execution-role","title":"CodeBuild Execution Role","text":"<p>The CodeBuild Execution Role is used by AWS CodeBuild to build your agent's Docker container for ARM64 architecture and push it to Amazon ECR.</p>"},{"location":"user-guide/runtime/permissions.html#trust-policy_1","title":"Trust Policy","text":"<p>The CodeBuild execution role must trust the <code>codebuild.amazonaws.com</code> service:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Service\": \"codebuild.amazonaws.com\"\n      },\n      \"Action\": \"sts:AssumeRole\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"aws:SourceAccount\": \"YOUR_ACCOUNT_ID\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"user-guide/runtime/permissions.html#permissions-policy_1","title":"Permissions Policy","text":"<p>The CodeBuild execution role requires the following permissions:</p>"},{"location":"user-guide/runtime/permissions.html#ecr-repository-access","title":"ECR Repository Access","text":"<pre><code>{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"ecr:GetAuthorizationToken\"\n  ],\n  \"Resource\": \"*\"\n},\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"ecr:BatchCheckLayerAvailability\",\n    \"ecr:BatchGetImage\",\n    \"ecr:GetDownloadUrlForLayer\",\n    \"ecr:PutImage\",\n    \"ecr:InitiateLayerUpload\",\n    \"ecr:UploadLayerPart\",\n    \"ecr:CompleteLayerUpload\"\n  ],\n  \"Resource\": \"arn:aws:ecr:YOUR_REGION:YOUR_ACCOUNT_ID:repository/YOUR_ECR_REPOSITORY\"\n}\n</code></pre> <p>Purpose: Allows CodeBuild to authenticate with ECR and push the built container image.</p>"},{"location":"user-guide/runtime/permissions.html#cloudwatch-logs-for-build-process","title":"CloudWatch Logs for Build Process","text":"<pre><code>{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"logs:CreateLogGroup\",\n    \"logs:CreateLogStream\",\n    \"logs:PutLogEvents\"\n  ],\n  \"Resource\": [\n    \"arn:aws:logs:YOUR_REGION:YOUR_ACCOUNT_ID:log-group:/aws/codebuild/bedrock-agentcore-*\"\n  ]\n}\n</code></pre> <p>Purpose: Enables CodeBuild to create and write to log groups for build monitoring.</p>"},{"location":"user-guide/runtime/permissions.html#s3-source-access","title":"S3 Source Access","text":"<pre><code>{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"s3:GetObject\"\n  ],\n  \"Resource\": [\n    \"arn:aws:s3:::bedrock-agentcore-codebuild-sources-YOUR_ACCOUNT_ID-YOUR_REGION/*\"\n  ]\n}\n</code></pre> <p>Purpose: Allows CodeBuild to access the source code uploaded to the toolkit's managed S3 bucket.</p>"},{"location":"user-guide/runtime/permissions.html#toolkit-implementation-details","title":"Toolkit Implementation Details","text":""},{"location":"user-guide/runtime/permissions.html#role-naming-convention","title":"Role Naming Convention","text":"<p>The toolkit uses deterministic naming for auto-created roles:</p> <ul> <li>Runtime Role: <code>AmazonBedrockAgentCoreSDKRuntime-{region}-{hash}</code></li> <li>CodeBuild Role: <code>AmazonBedrockAgentCoreSDKCodeBuild-{region}-{hash}</code></li> </ul> <p>Where <code>{hash}</code> is a deterministic 10-character hash based on your agent name, ensuring consistent role names across deployments.</p>"},{"location":"user-guide/runtime/quickstart.html","title":"QuickStart: Your First Agent in 5 Minutes! \ud83d\ude80","text":"<p>This tutorial shows you how to use the Amazon Bedrock AgentCore starter toolkit to deploy an agent to an AgentCore Runtime.</p> <p>The starter toolkit is a Command Line Interface (CLI) toolkit that you can use to deploy AI agents to an AgentCore Runtime. You can use the toolkit with popular Python agent frameworks, such as LangGraph or Strands Agents. This tutorial uses Strands Agents.</p>"},{"location":"user-guide/runtime/quickstart.html#prerequisites","title":"Prerequisites","text":"<p>Before you start, make sure you have:</p> <ul> <li>AWS Account with credentials configured. To configure your AWS credentials, see Configuration and credential file settings in the AWS CLI.</li> <li>Python 3.10+ installed</li> <li>Boto3 installed</li> <li>AWS Permissions: To create and deploy an agent with the starter toolkit, you must have appropriate permissions. For information, see Use the starter toolkit.</li> <li>Model access: Anthropic Claude Sonnet 4.0 enabled in the Amazon Bedrock console. For information about using a different model with the Strands Agents see the Model Providers section in the Strands Agents SDK documentation.</li> </ul>"},{"location":"user-guide/runtime/quickstart.html#step-1-setup-project-and-install-dependencies","title":"Step 1: Setup Project and Install Dependencies","text":"<p>Create a project folder and install the required packages:</p> <pre><code>mkdir agentcore-runtime-quickstart\ncd agentcore-runtime-quickstart\npython3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>On Windows, use: <code>.venv\\Scripts\\activate</code></p> <p>Upgrade pip to the latest version:</p> <pre><code>pip install --upgrade pip\n</code></pre> <p>Install the following required packages:</p> <ul> <li>bedrock-agentcore - The Amazon Bedrock AgentCore SDK for building AI agents</li> <li>strands-agents - The Strands Agents SDK</li> <li>bedrock-agentcore-starter-toolkit - The Amazon Bedrock AgentCore starter toolkit</li> </ul> <pre><code>pip install bedrock-agentcore strands-agents bedrock-agentcore-starter-toolkit\n</code></pre> <p>Verify installation:</p> <pre><code>agentcore --help\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#step-2-create-your-agent","title":"Step 2: Create Your Agent","text":"<p>Create a source file for your agent code named <code>my_agent.py</code>. Add the following code:</p> <pre><code>from bedrock_agentcore import BedrockAgentCoreApp\nfrom strands import Agent\n\napp = BedrockAgentCoreApp()\nagent = Agent()\n\n@app.entrypoint\ndef invoke(payload):\n    \"\"\"Your AI agent function\"\"\"\n    user_message = payload.get(\"prompt\", \"Hello! How can I help you today?\")\n    result = agent(user_message)\n    return {\"result\": result.message}\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Create <code>requirements.txt</code> and add the following:</p> <pre><code>bedrock-agentcore\nstrands-agents\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#step-3-test-locally","title":"Step 3: Test Locally","text":"<p>Open a terminal window and start your agent with the following command:</p> <pre><code>python my_agent.py\n</code></pre> <p>Test your agent by opening another terminal window and enter the following command:</p> <pre><code>curl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"Hello!\"}'\n</code></pre> <p>Success: You should see a response like <code>{\"result\": \"Hello! I'm here to help...\"}</code>.</p> <p>In the terminal window that's running the agent, enter <code>Ctrl+C</code> to stop the agent.</p> <p>Important: Make sure port 8080 is free before starting.</p>"},{"location":"user-guide/runtime/quickstart.html#step-4-configure-your-agent","title":"Step 4: Configure Your Agent","text":"<p>Configure and deploy your agent to AWS using the starter toolkit. The toolkit automatically creates the IAM execution role, container image, and Amazon Elastic Container Registry repository needed to host the agent in AgentCore Runtime. By default the toolkit hosts the agent in an AgentCore Runtime that is in the <code>us-west-2</code> AWS Region.</p> <p>Configure the agent. Use the default values:</p> <pre><code>agentcore configure -e my_agent.py\n</code></pre> <ul> <li>The <code>-e</code> or <code>--entrypoint</code> flag specifies the entrypoint file for your agent (the Python file containing your agent code)</li> <li>This command creates configuration for deployment to AWS</li> <li>Accept the default values unless you have specific requirements</li> <li>The configuration information is stored in a hidden file named <code>.bedrock_agentcore.yaml</code></li> <li>During configuration, you'll be prompted to choose memory options. Memory will be provisioned based on your choice: short-term memory (STM) only, or both short-term and long-term memory (LTM) with automatic extraction of facts, preferences, and summaries.</li> </ul> <p>Note: To continue without memory, use the <code>--disable-memory</code> flag: <code>agentcore configure -e my_agent.py --disable-memory</code></p>"},{"location":"user-guide/runtime/quickstart.html#using-a-different-region","title":"Using a Different Region","text":"<p>By default, the toolkit deploys to <code>us-west-2</code>. To use a different region:</p> <pre><code>agentcore configure -e my_agent.py -r us-east-1\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#step-5-enable-observability-for-your-agent","title":"Step 5: Enable Observability for Your Agent","text":"<p>Amazon Bedrock AgentCore Observability helps you trace, debug, and monitor agents that you host in AgentCore Runtime. First enable CloudWatch Transaction Search by following the instructions at Enabling AgentCore runtime observability. To observe your agent, see View observability data for your Amazon Bedrock AgentCore agents.</p>"},{"location":"user-guide/runtime/quickstart.html#step-6-deploy-to-agentcore-runtime","title":"Step 6: Deploy to AgentCore Runtime","text":"<p>Host your agent in AgentCore Runtime:</p> <pre><code>agentcore launch\n</code></pre> <p>This command:</p> <ul> <li>Builds your container using AWS CodeBuild (no Docker required locally)</li> <li>Creates necessary AWS resources (ECR repository, IAM roles, etc.)</li> <li>Deploys your agent to AgentCore Runtime</li> <li>Creates memory resources if you configured memory during the setup</li> <li>Configures CloudWatch logging</li> </ul> <p>In the output from <code>agentcore launch</code> note the following:</p> <ul> <li>The Amazon Resource Name (ARN) of the agent. You need it to invoke the agent with the InvokeAgentRuntime operation.</li> <li>The location of the logs in Amazon CloudWatch Logs</li> </ul> <p>If the deployment fails check for Common Issues.</p> <p>For other deployment options, see Deployment Modes.</p> <p>Note: Before invoking your agent, you can check the deployment status using <code>agentcore status</code> to verify that all resources including memory (if configured) are provisioned and ready.</p>"},{"location":"user-guide/runtime/quickstart.html#step-7-test-your-deployed-agent","title":"Step 7: Test Your Deployed Agent","text":"<p>Test your deployed agent:</p> <pre><code>agentcore invoke '{\"prompt\": \"tell me a joke\"}'\n</code></pre> <p>If you see a joke in the response, your agent is now running in an AgentCore Runtime and can be invoked. If not, check for Common Issues.</p>"},{"location":"user-guide/runtime/quickstart.html#step-8-invoke-your-agent-programmatically","title":"Step 8: Invoke Your Agent Programmatically","text":"<p>You can invoke the agent using the AWS SDK InvokeAgentRuntime operation. To call InvokeAgentRuntime, you need the ARN of the agent that you noted in Step 6: Deploy to AgentCore Runtime. You can also get the ARN from the <code>bedrock_agentcore:</code> section of the <code>.bedrock_agentcore.yaml</code> (hidden) file that the toolkit creates.</p> <p>Use the following boto3 (AWS SDK) code to invoke your agent. Replace <code>&lt;Add your ARN&gt;</code> with the ARN of your agent. Make sure that you have <code>bedrock-agentcore:InvokeAgentRuntime</code> permissions.</p> <p>Create a file named <code>invoke_agent.py</code> and add the following code:</p> <pre><code>import json\nimport uuid\nimport boto3\n\nagent_arn = \"&lt;Add your ARN&gt;\"\nprompt = \"Tell me a joke\"\n\n# Initialize the AgentCore client\nagent_core_client = boto3.client('bedrock-agentcore')\n\n# Prepare the payload\npayload = json.dumps({\"prompt\": prompt}).encode()\n\n# Invoke the agent\nresponse = agent_core_client.invoke_agent_runtime(\n    agentRuntimeArn=agent_arn,\n    runtimeSessionId=str(uuid.uuid4()),\n    payload=payload,\n    qualifier=\"DEFAULT\"\n)\n\ncontent = []\nfor chunk in response.get(\"response\", []):\n    content.append(chunk.decode('utf-8'))\nprint(json.loads(''.join(content)))\n</code></pre> <p>Open a terminal window and run the code with the following command:</p> <pre><code>python invoke_agent.py\n</code></pre> <p>If successful, you should see a joke in the response. If the call fails, check the logs that you noted in Step 6: Deploy to AgentCore Runtime.</p> <p>If you plan on integrating your agent with OAuth, you can't use the AWS SDK to call InvokeAgentRuntime. Instead, make a HTTPS request to InvokeAgentRuntime. For more information, see Authenticate and authorize with Inbound Auth and Outbound Auth.</p>"},{"location":"user-guide/runtime/quickstart.html#step-9-clean-up","title":"Step 9: Clean Up","text":"<p>If you no longer want to host the agent in the AgentCore Runtime, use the AgentCore console or the DeleteAgentRuntime AWS SDK operation to delete the AgentCore Runtime.</p> <pre><code>agentcore destroy\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#find-your-resources","title":"Find Your Resources","text":"<p>After deployment, view your resources in AWS Console:</p> Resource Location Agent Logs CloudWatch \u2192 Log groups \u2192 <code>/aws/bedrock-agentcore/runtimes/{agent-id}-DEFAULT</code> Memory Resources Bedrock AgentCore \u2192 Memory (if memory was configured during setup) Container Images ECR \u2192 Repositories \u2192 <code>bedrock-agentcore-{agent-name}</code> Build Logs CodeBuild \u2192 Build history IAM Role IAM \u2192 Roles \u2192 Search for \"BedrockAgentCore\""},{"location":"user-guide/runtime/quickstart.html#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"<p>Common issues and solutions when getting started with the Amazon Bedrock AgentCore starter toolkit. For more troubleshooting information, see Troubleshoot AgentCore Runtime.</p> Permission denied errors  Verify your AWS credentials and permissions:  - Verify AWS credentials: `aws sts get-caller-identity` - Check you have the required policies attached - Review caller permissions policy for detailed requirements   Docker not found warnings  You can ignore this warning:  - **Ignore this!** Default deployment uses CodeBuild (no Docker needed) - Only install Docker/Finch/Podman if you want to use `--local` or `--local-build` flags   Model access denied  Enable model access in the Bedrock console:  - Enable Anthropic Claude 4.0 in the Bedrock console - Make sure you're in the correct AWS region (us-west-2 by default)   CodeBuild build error  Check build logs and permissions:  - Check CodeBuild project logs in AWS console - Verify your caller permissions include CodeBuild access   Port 8080 in use (local only)  **Symptom**: Error stating port 8080 is already in use when testing locally.  **Solution**:  - Mac/Linux: `lsof -ti:8080 | xargs kill -9` - Windows: Find and stop the process using port 8080 in Task Manager - Or choose a different port in your configuration   Region mismatch  **Symptom**: Resources not found or deployment fails due to region mismatch.  **Solution**:  - Verify region with `aws configure get region` - Ensure all resources (agent, models, etc.) are in the same region - Use the `-r` flag during configuration to specify the correct region   Memory provisioning still in progress  **Symptom**: Error indicating memory is not yet ready when invoking the agent.  **Solution**:  - Memory provisioning can take 2-5 minutes, especially for long-term memory (LTM) - Check status with `agentcore status` until memory shows as active - Short-term memory (STM) is available immediately; LTM requires additional setup time"},{"location":"user-guide/runtime/quickstart.html#advanced-options-optional","title":"Advanced Options (Optional)","text":"<p>The starter toolkit has advanced configuration options for different deployment modes and custom IAM roles. For more information, see Runtime commands for the starter toolkit.</p>"},{"location":"user-guide/runtime/quickstart.html#deployment-modes","title":"Deployment Modes","text":"<p>Choose the right deployment approach for your needs:</p> <p>Default: CodeBuild + Cloud Runtime (RECOMMENDED)</p> <p>Suitable for production, managed environments, teams without Docker:</p> <pre><code>agentcore launch  # Uses CodeBuild (no Docker needed)\n</code></pre> <p>Local Development</p> <p>Suitable for development, rapid iteration, debugging:</p> <pre><code>agentcore launch --local  # Build and run locally (requires Docker/Finch/Podman)\n</code></pre> <p>Hybrid: Local Build + Cloud Runtime</p> <p>Suitable for teams with Docker expertise needing build customization:</p> <pre><code>agentcore launch --local-build  # Build locally, deploy to cloud (requires Docker/Finch/Podman)\n</code></pre> <p>Note: Docker is only required for <code>--local</code> and <code>--local-build</code> modes. The default mode uses AWS CodeBuild.</p>"},{"location":"user-guide/runtime/quickstart.html#custom-execution-role","title":"Custom Execution Role","text":"<p>Use an existing IAM role:</p> <pre><code>agentcore configure -e my_agent.py --execution-role arn:aws:iam::111122223333:role/MyRole\n</code></pre>"},{"location":"user-guide/runtime/quickstart.html#why-arm64","title":"Why ARM64?","text":"<p>AgentCore Runtime requires ARM64 containers (AWS Graviton). The toolkit handles this automatically:</p> <ul> <li>Default (CodeBuild): Builds ARM64 containers in the cloud - no Docker needed</li> <li>Local with Docker: Only containers built on ARM64 machines will work when deployed to agentcore runtime</li> </ul>"}]}